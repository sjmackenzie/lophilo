Index: linux-2.6.35/include/media/atmel-isi.h
===================================================================
--- linux-2.6.35/include/media/atmel-isi.h	(revision 0)
+++ linux-2.6.35/include/media/atmel-isi.h	(revision 150)
@@ -0,0 +1,476 @@
+/*
+ * Register definitions for the Atmel Image Sensor Interface.
+ *
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __ATMEL_ISI_H__
+#define __ATMEL_ISI_H__
+
+#include <linux/videodev2.h>
+
+/* ISI register offsets */
+#define ISI_CR1					0x0000
+#define ISI_CR2					0x0004
+#define ISI_SR					0x0008
+#define ISI_IER					0x000c
+#define ISI_IDR					0x0010
+#define ISI_IMR					0x0014
+#define ISI_PSIZE				0x0020
+#define ISI_PDECF				0x0024
+#define ISI_PPFBD				0x0028
+#define ISI_CDBA				0x002c
+#define ISI_Y2R_SET0				0x0030
+#define ISI_Y2R_SET1				0x0034
+#define ISI_R2Y_SET0				0x0038
+#define ISI_R2Y_SET1				0x003c
+#define ISI_R2Y_SET2				0x0040
+
+/* ISI_V2 register offsets */
+#define ISI_V2_CFG1				0x0000
+#define ISI_V2_CFG2				0x0004
+#define ISI_V2_PSIZE				0x0008
+#define ISI_V2_PDECF				0x000c
+#define ISI_V2_Y2R_SET0				0x0010
+#define ISI_V2_Y2R_SET1				0x0014
+#define ISI_V2_R2Y_SET0				0x0018
+#define ISI_V2_R2Y_SET1				0x001C
+#define ISI_V2_R2Y_SET2				0x0020
+#define ISI_V2_CTRL				0x0024
+#define ISI_V2_STATUS				0x0028
+#define ISI_V2_INTEN				0x002C
+#define ISI_V2_INTDIS				0x0030
+#define ISI_V2_INTMASK				0x0034
+#define ISI_V2_DMA_CHER				0x0038
+#define ISI_V2_DMA_CHDR				0x003C
+#define ISI_V2_DMA_CHSR				0x0040
+#define ISI_V2_DMA_P_ADDR			0x0044
+#define ISI_V2_DMA_P_CTRL			0x0048
+#define ISI_V2_DMA_P_DSCR			0x004C
+#define ISI_V2_DMA_C_ADDR			0x0050
+#define ISI_V2_DMA_C_CTRL			0x0054
+#define ISI_V2_DMA_C_DSCR			0x0058
+
+/* Bitfields in CR1 */
+#define ISI_RST_OFFSET				0
+#define ISI_RST_SIZE				1
+#define ISI_DIS_OFFSET				1
+#define ISI_DIS_SIZE				1
+#define ISI_HSYNC_POL_OFFSET			2
+#define ISI_HSYNC_POL_SIZE			1
+#define ISI_VSYNC_POL_OFFSET			3
+#define ISI_VSYNC_POL_SIZE			1
+#define ISI_PIXCLK_POL_OFFSET			4
+#define ISI_PIXCLK_POL_SIZE			1
+#define ISI_EMB_SYNC_OFFSET			6
+#define ISI_EMB_SYNC_SIZE			1
+#define ISI_CRC_SYNC_OFFSET			7
+#define ISI_CRC_SYNC_SIZE			1
+#define ISI_FRATE_OFFSET			8
+#define ISI_FRATE_SIZE				3
+#define ISI_FULL_OFFSET				12
+#define ISI_FULL_SIZE				1
+#define ISI_THMASK_OFFSET			13
+#define ISI_THMASK_SIZE				2
+#define ISI_CODEC_ON_OFFSET			15
+#define ISI_CODEC_ON_SIZE			1
+#define ISI_SLD_OFFSET				16
+#define ISI_SLD_SIZE				8
+#define ISI_SFD_OFFSET				24
+#define ISI_SFD_SIZE				8
+
+/* Bitfields in CFG1 */
+#define ISI_V2_HSYNC_POL_OFFSET			2
+#define ISI_V2_HSYNC_POL_SIZE			1
+#define ISI_V2_VSYNC_POL_OFFSET			3
+#define ISI_V2_VSYNC_POL_SIZE			1
+#define ISI_V2_PIXCLK_POL_OFFSET		4
+#define ISI_V2_PIXCLK_POL_SIZE			1
+#define ISI_V2_EMB_SYNC_OFFSET			6
+#define ISI_V2_EMB_SYNC_SIZE			1
+#define ISI_V2_CRC_SYNC_OFFSET			7
+#define ISI_V2_CRC_SYNC_SIZE			1
+#define ISI_V2_FRATE_OFFSET			8
+#define ISI_V2_FRATE_SIZE			3
+#define ISI_V2_DISCR_OFFSET			11
+#define ISI_V2_DISCR_SIZE			1
+#define ISI_V2_FULL_OFFSET			12
+#define ISI_V2_FULL_SIZE			1
+#define ISI_V2_THMASK_OFFSET			13
+#define ISI_V2_THMASK_SIZE			2
+#define ISI_V2_SLD_OFFSET			16
+#define ISI_V2_SLD_SIZE				8
+#define ISI_V2_SFD_OFFSET			24
+#define ISI_V2_SFD_SIZE				8
+
+/* Bitfields in CR2 */
+#define ISI_IM_VSIZE_OFFSET			0
+#define ISI_IM_VSIZE_SIZE			11
+#define ISI_GS_MODE_OFFSET			11
+#define ISI_GS_MODE_SIZE			1
+#define ISI_RGB_MODE_OFFSET			12
+#define ISI_RGB_MODE_SIZE			1
+#define ISI_GRAYSCALE_OFFSET			13
+#define ISI_GRAYSCALE_SIZE			1
+#define ISI_RGB_SWAP_OFFSET			14
+#define ISI_RGB_SWAP_SIZE			1
+#define ISI_COL_SPACE_OFFSET			15
+#define ISI_COL_SPACE_SIZE			1
+#define ISI_IM_HSIZE_OFFSET			16
+#define ISI_IM_HSIZE_SIZE			11
+#define ISI_YCC_SWAP_OFFSET			28
+#define ISI_YCC_SWAP_SIZE			2
+#define ISI_RGB_CFG_OFFSET			30
+#define ISI_RGB_CFG_SIZE			2
+
+/* Bitfields in CFG2 */
+#define ISI_V2_IM_VSIZE_OFFSET			0
+#define ISI_V2_IM_VSIZE_SIZE			11
+#define ISI_V2_GS_MODE_OFFSET			11
+#define ISI_V2_GS_MODE_SIZE			1
+#define ISI_V2_RGB_MODE_OFFSET			12
+#define ISI_V2_RGB_MODE_SIZE			1
+#define ISI_V2_GRAYSCALE_OFFSET			13
+#define ISI_V2_GRAYSCALE_SIZE			1
+#define ISI_V2_RGB_SWAP_OFFSET			14
+#define ISI_V2_RGB_SWAP_SIZE			1
+#define ISI_V2_COL_SPACE_OFFSET			15
+#define ISI_V2_COL_SPACE_SIZE			1
+#define ISI_V2_IM_HSIZE_OFFSET			16
+#define ISI_V2_IM_HSIZE_SIZE			11
+#define ISI_V2_YCC_SWAP_OFFSET			28
+#define ISI_V2_YCC_SWAP_SIZE			2
+#define ISI_V2_RGB_CFG_OFFSET			30
+#define ISI_V2_RGB_CFG_SIZE			2
+
+/* Bitfields in CTRL */
+#define ISI_V2_EN_OFFSET			0
+#define ISI_V2_EN_SIZE				1
+#define ISI_V2_DIS_OFFSET			1
+#define ISI_V2_DIS_SIZE				1
+#define ISI_V2_SRST_OFFSET			2
+#define ISI_V2_SRST_SIZE			1
+#define ISI_V2_CDC_OFFSET			8
+#define ISI_V2_CDC_SIZE				1
+
+/* Bitfields in SR/IER/IDR/IMR */
+#define ISI_SOF_OFFSET				0
+#define ISI_SOF_SIZE				1
+#define ISI_SOFTRST_OFFSET			2
+#define ISI_SOFTRST_SIZE			1
+#define ISI_CDC_STATUS_OFFSET			3
+#define ISI_CDC_STATUS_SIZE			1
+#define ISI_CRC_ERR_OFFSET			4
+#define ISI_CRC_ERR_SIZE			1
+#define ISI_FO_C_OVF_OFFSET			5
+#define ISI_FO_C_OVF_SIZE			1
+#define ISI_FO_P_OVF_OFFSET			6
+#define ISI_FO_P_OVF_SIZE			1
+#define ISI_FO_P_EMP_OFFSET			7
+#define ISI_FO_P_EMP_SIZE			1
+#define ISI_FO_C_EMP_OFFSET			8
+#define ISI_FO_C_EMP_SIZE			1
+#define ISI_FR_OVR_OFFSET			9
+#define ISI_FR_OVR_SIZE				1
+
+/* Bitfields in SR/IER/IDR/IMR(ISI_V2) */
+#define ISI_V2_ENABLE_OFFSET			0
+#define ISI_V2_ENABLE_SIZE			1
+#define ISI_V2_DIS_DONE_OFFSET			1
+#define ISI_V2_DIS_DONE_SIZE			1
+#define ISI_V2_SRST_OFFSET			2
+#define ISI_V2_SRST_SIZE			1
+#define ISI_V2_CDC_STATUS_OFFSET		8
+#define ISI_V2_CDC_STATUS_SIZE			1
+#define ISI_V2_VSYNC_OFFSET			10
+#define ISI_V2_VSYNC_SIZE			1
+#define ISI_V2_PXFR_DONE_OFFSET			16
+#define ISI_V2_PXFR_DONE_SIZE			1
+#define ISI_V2_CXFR_DONE_OFFSET			17
+#define ISI_V2_CXFR_DONE_SIZE			1
+#define ISI_V2_P_OVR_OFFSET			24
+#define ISI_V2_P_OVR_SIZE			1
+#define ISI_V2_C_OVR_OFFSET			25
+#define ISI_V2_C_OVR_SIZE			1
+#define ISI_V2_CRC_ERR_OFFSET			26
+#define ISI_V2_CRC_ERR_SIZE			1
+#define ISI_V2_FR_OVR_OFFSET			27
+#define ISI_V2_FR_OVR_SIZE			1
+
+/* Bitfields in PSIZE */
+#define ISI_PREV_VSIZE_OFFSET			0
+#define ISI_PREV_VSIZE_SIZE			10
+#define ISI_PREV_HSIZE_OFFSET			16
+#define ISI_PREV_HSIZE_SIZE			10
+
+/* Bitfields in PSIZE(ISI_V2) */
+#define ISI_V2_PREV_VSIZE_OFFSET		0
+#define ISI_V2_PREV_VSIZE_SIZE			10
+#define ISI_V2_PREV_HSIZE_OFFSET		16
+#define ISI_V2_PREV_HSIZE_SIZE			10
+
+/* Bitfields in PCDEF */
+#define ISI_DEC_FACTOR_OFFSET			0
+#define ISI_DEC_FACTOR_SIZE			8
+
+/* Bitfields in PCDEF */
+#define ISI_V2_DEC_FACTOR_OFFSET		0
+#define ISI_V2_DEC_FACTOR_SIZE			8
+
+/* Bitfields in PPFBD */
+#define ISI_PREV_FBD_ADDR_OFFSET		0
+#define ISI_PREV_FBD_ADDR_SIZE			32
+
+/* Bitfields in CDBA */
+#define ISI_CODEC_DMA_ADDR_OFFSET		0
+#define ISI_CODEC_DMA_ADDR_SIZE			32
+
+/* Bitfields in DMA_C_ADDR */
+#define ISI_V2_DMA_ADDR_OFFSET			0
+#define ISI_V2_DMA_ADDR_SIZE			32
+
+/* Bitfields in DMA_C_CTRL & in DMA_P_CTRL */
+#define ISI_V2_DMA_FETCH_OFFSET			0
+#define ISI_V2_DMA_FETCH_SIZE			1
+#define ISI_V2_DMA_WB_OFFSET			1
+#define ISI_V2_DMA_WB_SIZE			1
+#define ISI_V2_DMA_IEN_OFFSET			2
+#define ISI_V2_DMA_IEN_SIZE			1
+#define ISI_V2_DMA_DONE_OFFSET			3
+#define ISI_V2_DMA_DONE_SIZE			1
+
+/* Bitfields in DMA_CHER */
+#define ISI_V2_DMA_P_CH_EN_OFFSET		0
+#define ISI_V2_DMA_P_CH_EN_SIZE			1
+#define ISI_V2_DMA_C_CH_EN_OFFSET		1
+#define ISI_V2_DMA_C_CH_EN_SIZE			1
+
+/* Bitfields in Y2R_SET0 */
+#define ISI_Y2R_SET0_C3_OFFSET			24
+#define ISI_Y2R_SET0_C3_SIZE			8
+
+/* Bitfields in Y2R_SET0(ISI_V2) */
+#define ISI_V2_Y2R_SET0_C3_OFFSET		24
+#define ISI_V2_Y2R_SET0_C3_SIZE			8
+
+/* Bitfields in Y2R_SET1 */
+#define ISI_Y2R_SET1_C4_OFFSET			0
+#define ISI_Y2R_SET1_C4_SIZE			9
+#define ISI_YOFF_OFFSET				12
+#define ISI_YOFF_SIZE				1
+#define ISI_CROFF_OFFSET			13
+#define ISI_CROFF_SIZE				1
+#define ISI_CBOFF_OFFSET			14
+#define ISI_CBOFF_SIZE				1
+
+/* Bitfields in Y2R_SET1(ISI_V2) */
+#define ISI_V2_Y2R_SET1_C4_OFFSET		0
+#define ISI_V2_Y2R_SET1_C4_SIZE			9
+#define ISI_V2_YOFF_OFFSET			12
+#define ISI_V2_YOFF_SIZE			1
+#define ISI_V2_CROFF_OFFSET			13
+#define ISI_V2_CROFF_SIZE			1
+#define ISI_V2_CBOFF_OFFSET			14
+#define ISI_V2_CBOFF_SIZE			1
+
+/* Bitfields in R2Y_SET0 */
+#define ISI_C0_OFFSET				0
+#define ISI_C0_SIZE				8
+#define ISI_C1_OFFSET				8
+#define ISI_C1_SIZE				8
+#define ISI_C2_OFFSET				16
+#define ISI_C2_SIZE				8
+#define ISI_ROFF_OFFSET				24
+#define ISI_ROFF_SIZE				1
+
+/* Bitfields in R2Y_SET0(ISI_V2) */
+#define ISI_V2_C0_OFFSET			0
+#define ISI_V2_C0_SIZE				8
+#define ISI_V2_C1_OFFSET			8
+#define ISI_V2_C1_SIZE				8
+#define ISI_V2_C2_OFFSET			16
+#define ISI_V2_C2_SIZE				8
+#define ISI_V2_ROFF_OFFSET			24
+#define ISI_V2_ROFF_SIZE			1
+
+/* Bitfields in R2Y_SET1 */
+#define ISI_R2Y_SET1_C3_OFFSET			0
+#define ISI_R2Y_SET1_C3_SIZE			8
+#define ISI_R2Y_SET1_C4_OFFSET			8
+#define ISI_R2Y_SET1_C4_SIZE			8
+#define ISI_C5_OFFSET				16
+#define ISI_C5_SIZE				8
+#define ISI_GOFF_OFFSET				24
+#define ISI_GOFF_SIZE				1
+
+/* Bitfields in R2Y_SET1(ISI_V2) */
+#define ISI_V2_R2Y_SET1_C3_OFFSET		0
+#define ISI_V2_R2Y_SET1_C3_SIZE			8
+#define ISI_V2_R2Y_SET1_C4_OFFSET		8
+#define ISI_V2_R2Y_SET1_C4_SIZE			8
+#define ISI_V2_C5_OFFSET			16
+#define ISI_V2_C5_SIZE				8
+#define ISI_V2_GOFF_OFFSET			24
+#define ISI_V2_GOFF_SIZE			1
+
+/* Bitfields in R2Y_SET2 */
+#define ISI_C6_OFFSET				0
+#define ISI_C6_SIZE				8
+#define ISI_C7_OFFSET				8
+#define ISI_C7_SIZE				8
+#define ISI_C8_OFFSET				16
+#define ISI_C8_SIZE				8
+#define ISI_BOFF_OFFSET				24
+#define ISI_BOFF_SIZE				1
+
+/* Bitfields in R2Y_SET2(ISI_V2) */
+#define ISI_V2_C6_OFFSET			0
+#define ISI_V2_C6_SIZE				8
+#define ISI_V2_C7_OFFSET			8
+#define ISI_V2_C7_SIZE				8
+#define ISI_V2_C8_OFFSET			16
+#define ISI_V2_C8_SIZE				8
+#define ISI_V2_BOFF_OFFSET			24
+#define ISI_V2_BOFF_SIZE			1
+
+/* Constants for FRATE */
+#define ISI_FRATE_CAPTURE_ALL			0
+
+/* Constants for FRATE(ISI_V2) */
+#define ISI_V2_FRATE_CAPTURE_ALL		0
+
+/* Constants for YCC_SWAP */
+#define ISI_YCC_SWAP_DEFAULT			0
+#define ISI_YCC_SWAP_MODE_1			1
+#define ISI_YCC_SWAP_MODE_2			2
+#define ISI_YCC_SWAP_MODE_3			3
+
+/* Constants for YCC_SWAP(ISI_V2) */
+#define ISI_V2_YCC_SWAP_DEFAULT			0
+#define ISI_V2_YCC_SWAP_MODE_1			1
+#define ISI_V2_YCC_SWAP_MODE_2			2
+#define ISI_V2_YCC_SWAP_MODE_3			3
+
+/* Constants for RGB_CFG */
+#define ISI_RGB_CFG_DEFAULT			0
+#define ISI_RGB_CFG_MODE_1			1
+#define ISI_RGB_CFG_MODE_2			2
+#define ISI_RGB_CFG_MODE_3			3
+
+/* Constants for RGB_CFG(ISI_V2) */
+#define ISI_V2_RGB_CFG_DEFAULT			0
+#define ISI_V2_RGB_CFG_MODE_1			1
+#define ISI_V2_RGB_CFG_MODE_2			2
+#define ISI_V2_RGB_CFG_MODE_3			3
+
+/* Bit manipulation macros */
+#define ISI_BIT(name)					\
+	(1 << ISI_##name##_OFFSET)
+#define ISI_BF(name, value)				\
+	(((value) & ((1 << ISI_##name##_SIZE) - 1))	\
+	 << ISI_##name##_OFFSET)
+#define ISI_BFEXT(name, value)				\
+	(((value) >> ISI_##name##_OFFSET)		\
+	 & ((1 << ISI_##name##_SIZE) - 1))
+#define ISI_BFINS(name, value, old)			\
+	(((old) & ~(((1 << ISI_##name##_SIZE) - 1)	\
+		    << ISI_##name##_OFFSET))\
+	 | ISI_BF(name, value))
+
+/* Register access macros */
+#define isi_readl(port, reg)				\
+	__raw_readl((port)->regs + ISI_##reg)
+#define isi_writel(port, reg, value)			\
+	__raw_writel((value), (port)->regs + ISI_##reg)
+
+#define ATMEL_V4L2_VID_FLAGS (V4L2_CAP_VIDEO_OUTPUT)
+
+struct atmel_isi;
+
+enum atmel_isi_pixfmt {
+	ATMEL_ISI_PIXFMT_GREY,		/* Greyscale */
+	ATMEL_ISI_PIXFMT_CbYCrY,
+	ATMEL_ISI_PIXFMT_CrYCbY,
+	ATMEL_ISI_PIXFMT_YCbYCr,
+	ATMEL_ISI_PIXFMT_YCrYCb,
+	ATMEL_ISI_PIXFMT_RGB24,
+	ATMEL_ISI_PIXFMT_BGR24,
+	ATMEL_ISI_PIXFMT_RGB16,
+	ATMEL_ISI_PIXFMT_BGR16,
+	ATMEL_ISI_PIXFMT_GRB16,		/* G[2:0] R[4:0]/B[4:0] G[5:3] */
+	ATMEL_ISI_PIXFMT_GBR16,		/* G[2:0] B[4:0]/R[4:0] G[5:3] */
+	ATMEL_ISI_PIXFMT_RGB24_REV,
+	ATMEL_ISI_PIXFMT_BGR24_REV,
+	ATMEL_ISI_PIXFMT_RGB16_REV,
+	ATMEL_ISI_PIXFMT_BGR16_REV,
+	ATMEL_ISI_PIXFMT_GRB16_REV,	/* G[2:0] R[4:0]/B[4:0] G[5:3] */
+	ATMEL_ISI_PIXFMT_GBR16_REV,	/* G[2:0] B[4:0]/R[4:0] G[5:3] */
+};
+
+struct atmel_isi_format {
+	struct v4l2_pix_format pix;
+	enum atmel_isi_pixfmt input_format;
+};
+
+struct isi_platform_data {
+	u16 image_hsize;
+	u16 image_vsize;
+	u16 prev_hsize;
+	u16 prev_vsize;
+	u16 cr1_flags;
+#define ISI_HSYNC_ACT_LOW	0x01
+#define ISI_VSYNC_ACT_LOW	0x02
+#define ISI_PXCLK_ACT_FALLING	0x04
+#define ISI_EMB_SYNC		0x08
+#define ISI_CRC_SYNC		0x10
+#define ISI_FULL		0x20
+	u8 gs_mode;
+#define ISI_GS_2PIX_PER_WORD	0x00
+#define ISI_GS_1PIX_PER_WORD	0x01
+	u8 pixfmt;
+	u8 sfd;
+	u8 sld;
+	u8 thmask;
+#define ISI_BURST_4_8_16	0x00
+#define ISI_BURST_8_16		0x01
+#define ISI_BURST_16		0x02
+	u8 frate;
+#define ISI_FRATE_DIV_2		0x01
+#define ISI_FRATE_DIV_3		0x02
+#define ISI_FRATE_DIV_4		0x03
+#define ISI_FRATE_DIV_5		0x04
+#define ISI_FRATE_DIV_6		0x05
+#define ISI_FRATE_DIV_7		0x06
+#define ISI_FRATE_DIV_8		0x07
+	int capture_v4l2_fmt;
+	int streaming_v4l2_fmt;
+};
+
+struct atmel_isi_camera {
+	const char		*name;
+	struct module		*owner;
+	struct list_head	list;
+	unsigned int		hsync_act_low:1;
+	unsigned int		vsync_act_low:1;
+	unsigned int		pclk_act_falling:1;
+	unsigned int		has_emb_sync:1;
+	/* ISI supports up to 17 formats */
+	unsigned int		pixelformats[17];
+	int (*get_format)(struct atmel_isi_camera *cam,
+			  struct atmel_isi_format *fmt);
+	int (*set_format)(struct atmel_isi_camera *cam,
+			  struct atmel_isi_format *fmt);
+	int (*start_capture)(struct atmel_isi_camera *cam,
+			  struct atmel_isi_format *fmt);
+	int (*stop_capture)(struct atmel_isi_camera *cam);
+	struct atmel_isi	*isi;
+};
+
+extern int atmel_isi_register_camera(struct atmel_isi_camera *cam);
+extern void atmel_isi_unregister_camera(struct atmel_isi_camera *cam);
+
+
+#endif /* __ATMEL_ISI_H__ */
Index: linux-2.6.35/include/asm-generic/gpio.h
===================================================================
--- linux-2.6.35/include/asm-generic/gpio.h	(revision 149)
+++ linux-2.6.35/include/asm-generic/gpio.h	(revision 150)
@@ -22,11 +22,13 @@
 #define ARCH_NR_GPIOS		256
 #endif
 
+#ifndef __HAVE_ARCH_GPIO_IS_VALID
 static inline int gpio_is_valid(int number)
 {
 	/* only some non-negative numbers are valid */
 	return ((unsigned)number) < ARCH_NR_GPIOS;
 }
+#endif
 
 struct device;
 struct seq_file;
@@ -185,11 +187,13 @@
 
 #else	/* !CONFIG_HAVE_GPIO_LIB */
 
+#ifndef __HAVE_ARCH_GPIO_IS_VALID
 static inline int gpio_is_valid(int number)
 {
 	/* only non-negative numbers are valid */
 	return number >= 0;
 }
+#endif
 
 /* platforms that don't directly support access to GPIOs through I2C, SPI,
  * or other blocking infrastructure can use these wrappers.
Index: linux-2.6.35/include/linux/dmaengine.h
===================================================================
--- linux-2.6.35/include/linux/dmaengine.h	(revision 149)
+++ linux-2.6.35/include/linux/dmaengine.h	(revision 150)
@@ -67,10 +67,11 @@
 	DMA_PRIVATE,
 	DMA_ASYNC_TX,
 	DMA_SLAVE,
+	DMA_CYCLIC,
 };
 
 /* last transaction type for creation of the capabilities mask */
-#define DMA_TX_TYPE_END (DMA_SLAVE + 1)
+#define DMA_TX_TYPE_END (DMA_CYCLIC + 1)
 
 
 /**
@@ -114,11 +115,20 @@
  * @DMA_TERMINATE_ALL: terminate all ongoing transfers
  * @DMA_PAUSE: pause ongoing transfers
  * @DMA_RESUME: resume paused transfer
+ * @DMA_SLAVE_CONFIG: this command is only implemented by DMA controllers
+ * that need to runtime reconfigure the slave channels (as opposed to passing
+ * configuration data in statically from the platform). An additional
+ * argument of struct dma_slave_config must be passed in with this
+ * command.
+ * @FSLDMA_EXTERNAL_START: this command will put the Freescale DMA controller
+ * into external start mode.
  */
 enum dma_ctrl_cmd {
 	DMA_TERMINATE_ALL,
 	DMA_PAUSE,
 	DMA_RESUME,
+	DMA_SLAVE_CONFIG,
+	FSLDMA_EXTERNAL_START,
 };
 
 /**
@@ -199,6 +209,71 @@
 	atomic_t *idr_ref;
 };
 
+/**
+ * enum dma_slave_buswidth - defines bus with of the DMA slave
+ * device, source or target buses
+ */
+enum dma_slave_buswidth {
+	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
+	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
+	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
+	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
+	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
+};
+
+/**
+ * struct dma_slave_config - dma slave channel runtime config
+ * @direction: whether the data shall go in or out on this slave
+ * channel, right now. DMA_TO_DEVICE and DMA_FROM_DEVICE are
+ * legal values, DMA_BIDIRECTIONAL is not acceptable since we
+ * need to differentiate source and target addresses.
+ * @src_addr: this is the physical address where DMA slave data
+ * should be read (RX), if the source is memory this argument is
+ * ignored.
+ * @dst_addr: this is the physical address where DMA slave data
+ * should be written (TX), if the source is memory this argument
+ * is ignored.
+ * @src_addr_width: this is the width in bytes of the source (RX)
+ * register where DMA data shall be read. If the source
+ * is memory this may be ignored depending on architecture.
+ * Legal values: 1, 2, 4, 8.
+ * @dst_addr_width: same as src_addr_width but for destination
+ * target (TX) mutatis mutandis.
+ * @src_maxburst: the maximum number of words (note: words, as in
+ * units of the src_addr_width member, not bytes) that can be sent
+ * in one burst to the device. Typically something like half the
+ * FIFO depth on I/O peripherals so you don't overflow it. This
+ * may or may not be applicable on memory sources.
+ * @dst_maxburst: same as src_maxburst but for destination target
+ * mutatis mutandis.
+ *
+ * This struct is passed in as configuration data to a DMA engine
+ * in order to set up a certain channel for DMA transport at runtime.
+ * The DMA device/engine has to provide support for an additional
+ * command in the channel config interface, DMA_SLAVE_CONFIG
+ * and this struct will then be passed in as an argument to the
+ * DMA engine device_control() function.
+ *
+ * The rationale for adding configuration information to this struct
+ * is as follows: if it is likely that most DMA slave controllers in
+ * the world will support the configuration option, then make it
+ * generic. If not: if it is fixed so that it be sent in static from
+ * the platform data, then prefer to do that. Else, if it is neither
+ * fixed at runtime, nor generic enough (such as bus mastership on
+ * some CPU family and whatnot) then create a custom slave config
+ * struct and pass that, then make this config a member of that
+ * struct, if applicable.
+ */
+struct dma_slave_config {
+	enum dma_data_direction direction;
+	dma_addr_t src_addr;
+	dma_addr_t dst_addr;
+	enum dma_slave_buswidth src_addr_width;
+	enum dma_slave_buswidth dst_addr_width;
+	u32 src_maxburst;
+	u32 dst_maxburst;
+};
+
 static inline const char *dma_chan_name(struct dma_chan *chan)
 {
 	return dev_name(&chan->dev->device);
@@ -351,6 +426,9 @@
  * @device_prep_dma_memset: prepares a memset operation
  * @device_prep_dma_interrupt: prepares an end of chain interrupt operation
  * @device_prep_slave_sg: prepares a slave dma operation
+ * @device_prep_dma_cyclic: prepare a cyclic dma operation suitable for audio.
+ *	The function takes a buffer of size buf_len. The callback function will
+ *	be called after period_len bytes have been transferred.
  * @device_control: manipulate all pending operations on a channel, returns
  *	zero or error code
  * @device_tx_status: poll for transaction completion, the optional
@@ -407,6 +485,9 @@
 		struct dma_chan *chan, struct scatterlist *sgl,
 		unsigned int sg_len, enum dma_data_direction direction,
 		unsigned long flags);
+	struct dma_async_tx_descriptor *(*device_prep_dma_cyclic)(
+		struct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,
+		size_t period_len, enum dma_data_direction direction);
 	int (*device_control)(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		unsigned long arg);
 
Index: linux-2.6.35/include/linux/netdevice.h
===================================================================
--- linux-2.6.35/include/linux/netdevice.h	(revision 149)
+++ linux-2.6.35/include/linux/netdevice.h	(revision 150)
@@ -869,13 +869,13 @@
 
 	struct net_device_stats	stats;
 
-#ifdef CONFIG_WIRELESS_EXT
+//#ifdef CONFIG_WIRELESS_EXT
 	/* List of functions to handle Wireless Extensions (instead of ioctl).
 	 * See <net/iw_handler.h> for details. Jean II */
 	const struct iw_handler_def *	wireless_handlers;
 	/* Instance data managed by the core of Wireless Extensions. */
 	struct iw_public_data *	wireless_data;
-#endif
+//#endif
 	/* Management operations */
 	const struct net_device_ops *netdev_ops;
 	const struct ethtool_ops *ethtool_ops;
Index: linux-2.6.35/include/linux/atmel-ssc.h
===================================================================
--- linux-2.6.35/include/linux/atmel-ssc.h	(revision 149)
+++ linux-2.6.35/include/linux/atmel-ssc.h	(revision 150)
@@ -3,9 +3,11 @@
 
 #include <linux/platform_device.h>
 #include <linux/list.h>
+#include <mach/cpu.h>
 
 struct ssc_device {
 	struct list_head	list;
+	resource_size_t		phybase;
 	void __iomem		*regs;
 	struct platform_device	*pdev;
 	struct clk		*clk;
@@ -309,4 +311,6 @@
 #define ssc_readl(base, reg)		__raw_readl(base + SSC_##reg)
 #define ssc_writel(base, reg, value)	__raw_writel((value), base + SSC_##reg)
 
+#define ssc_use_dmaengine()	cpu_is_at91sam9x5()
+
 #endif /* __INCLUDE_ATMEL_SSC_H */
Index: linux-2.6.35/include/video/atmel_lcdc.h
===================================================================
--- linux-2.6.35/include/video/atmel_lcdc.h	(revision 149)
+++ linux-2.6.35/include/video/atmel_lcdc.h	(revision 150)
@@ -47,11 +47,15 @@
 	struct clk		*bus_clk;
 	struct clk		*lcdc_clk;
 
+	struct lcd_dma_desc	*p_dma_desc;
+	dma_addr_t		dma_desc_phys;
+
 #ifdef CONFIG_BACKLIGHT_ATMEL_LCDC
 	struct backlight_device	*backlight;
 	u8			bl_power;
 #endif
 	bool			lcdcon_is_backlight;
+	bool			alpha_enabled;
 	u8			saved_lcdcon;
 
 	u8			default_bpp;
@@ -63,6 +67,12 @@
 	u32			pseudo_palette[16];
 };
 
+struct lcd_dma_desc {
+	u32	address;
+	u32	control;
+	u32	next;
+};
+
 #define ATMEL_LCDC_DMABADDR1	0x00
 #define ATMEL_LCDC_DMABADDR2	0x04
 #define ATMEL_LCDC_DMAFRMPT1	0x08
@@ -213,6 +223,11 @@
 #define	ATMEL_LCDC_OWRI		(1 << 5)
 #define	ATMEL_LCDC_MERI		(1 << 6)
 
+#if !defined(CONFIG_ARCH_AT91SAM9X5)
 #define ATMEL_LCDC_LUT(n)	(0x0c00 + ((n)*4))
+#else
+/* Base layer CLUT */
+#define ATMEL_LCDC_LUT(n)	(0x0400 + ((n)*4))
+#endif
 
 #endif /* __ATMEL_LCDC_H__ */
Index: linux-2.6.35/net/wireless/Kconfig
===================================================================
--- linux-2.6.35/net/wireless/Kconfig	(revision 149)
+++ linux-2.6.35/net/wireless/Kconfig	(revision 150)
@@ -114,6 +114,7 @@
 	bool "cfg80211 wireless extensions compatibility"
 	depends on CFG80211
 	select WEXT_CORE
+	select WIRELESS_EXT
 	default y
 	help
 	  Enable this option if you need old userspace for wireless
Index: linux-2.6.35/sound/soc/codecs/wm8731.c
===================================================================
--- linux-2.6.35/sound/soc/codecs/wm8731.c	(revision 149)
+++ linux-2.6.35/sound/soc/codecs/wm8731.c	(revision 150)
@@ -60,7 +60,9 @@
  */
 static const u16 wm8731_reg[WM8731_CACHEREGNUM] = {
 	0x0097, 0x0097, 0x0079, 0x0079,
-	0x000a, 0x0008, 0x009f, 0x000a,
+	0x001a, 0x0008, 0x009f, 0x000a, 
+	/*change by embest,we don't need use alsamixer to open the audio patch for android*/ 
+	/*0x000a, 0x0008, 0x009f, 0x000a,*/
 	0x0000, 0x0000
 };
 
@@ -231,6 +233,8 @@
 	u16 srate = (coeff_div[i].sr << 2) |
 		(coeff_div[i].bosr << 1) | coeff_div[i].usb;
 
+	//printk(KERN_WARNING "srate = 0x%04x\n", srate);
+
 	snd_soc_write(codec, WM8731_SRATE, srate);
 
 	/* bit size */
@@ -246,6 +250,9 @@
 	}
 
 	snd_soc_write(codec, WM8731_IFACE, iface);
+
+	//printk(KERN_WARNING "read iface = 0x%04x\n", snd_soc_read(codec, WM8731_IFACE));
+
 	return 0;
 }
 
@@ -256,6 +263,11 @@
 	struct snd_soc_device *socdev = rtd->socdev;
 	struct snd_soc_codec *codec = socdev->card->codec;
 
+	/*add by embest,we don't need use alsamixer to open the audio patch for android*/
+	u16 dac_select_reg = snd_soc_read(codec, WM8731_APANA);
+	snd_soc_write(codec, WM8731_APANA, dac_select_reg | 0x10);
+	/*add done!*/
+
 	/* set active */
 	snd_soc_write(codec, WM8731_ACTIVE, 0x0001);
 
@@ -294,6 +306,10 @@
 	struct snd_soc_codec *codec = codec_dai->codec;
 	struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(codec);
 
+	//printk(KERN_WARNING "wm8731_set_dai_sysclk: id %d, freq %d, dir %d",
+	//		clk_id, freq, dir
+	//		);
+
 	switch (freq) {
 	case 11289600:
 	case 12000000:
Index: linux-2.6.35/sound/soc/atmel/Kconfig
===================================================================
--- linux-2.6.35/sound/soc/atmel/Kconfig	(revision 149)
+++ linux-2.6.35/sound/soc/atmel/Kconfig	(revision 150)
@@ -23,6 +23,15 @@
 	  Say Y if you want to add support for SoC audio on WM8731-based
 	  AT91sam9g20 evaluation board.
 
+config SND_AT91_SOC_SAM9X5_WM8731
+	tristate "SoC Audio support for WM8731-based at91sam9x5 board"
+	depends on ATMEL_SSC && SND_ATMEL_SOC && ARCH_AT91SAM9X5
+	select SND_ATMEL_SOC_SSC
+	select SND_SOC_WM8731
+	help
+	  Say Y if you want to add support for audio SoC on an
+	  at91sam9x5 based board that is using WM8731 codec.
+
 config SND_AT32_SOC_PLAYPAQ
         tristate "SoC Audio support for PlayPaq with WM8510"
         depends on SND_ATMEL_SOC && BOARD_PLAYPAQ
Index: linux-2.6.35/sound/soc/atmel/atmel-pcm.c
===================================================================
--- linux-2.6.35/sound/soc/atmel/atmel-pcm.c	(revision 149)
+++ linux-2.6.35/sound/soc/atmel/atmel-pcm.c	(revision 150)
@@ -31,12 +31,17 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+//#define DEBUG 12
+//#define VERBOSE 12
+//#define VERBOSE_DEBUG 12
+
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
 #include <linux/dma-mapping.h>
 #include <linux/atmel_pdc.h>
+#include <linux/dmaengine.h>
 #include <linux/atmel-ssc.h>
 
 #include <sound/core.h>
@@ -44,6 +49,8 @@
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 
+#include <mach/at_hdmac.h>
+
 #include "atmel-pcm.h"
 
 
@@ -53,7 +60,7 @@
 /* TODO: These values were taken from the AT91 platform driver, check
  *	 them against real values for AT32
  */
-static const struct snd_pcm_hardware atmel_pcm_hardware = {
+static const struct snd_pcm_hardware atmel_pcm_pdc_hardware = {
 	.info			= SNDRV_PCM_INFO_MMAP |
 				  SNDRV_PCM_INFO_MMAP_VALID |
 				  SNDRV_PCM_INFO_INTERLEAVED |
@@ -66,7 +73,23 @@
 	.buffer_bytes_max	= 32 * 1024,
 };
 
+static const struct snd_pcm_hardware atmel_pcm_dma_hardware = {
+	.info			= SNDRV_PCM_INFO_MMAP |
+				  SNDRV_PCM_INFO_MMAP_VALID |
+				  SNDRV_PCM_INFO_INTERLEAVED |
+				  SNDRV_PCM_INFO_RESUME |
+				  SNDRV_PCM_INFO_PAUSE,
+	.formats		= SNDRV_PCM_FMTBIT_S16_LE,
+	.period_bytes_min   = 256, /* not too low to absorb DMA programming overhead */
+	.period_bytes_max	= 2 * 0xffff,	/* if 2 bytes format */
+	.periods_min        = 8,
+	.periods_max		= 1024,		/* no limit */
+	.buffer_bytes_max   = 64 * 1024, /* 64KiB */
+};
 
+static struct snd_pcm_hardware *atmel_pcm_hardware;
+
+
 /*--------------------------------------------------------------------------*\
  * Data types
 \*--------------------------------------------------------------------------*/
@@ -84,6 +107,12 @@
 	u32 pdc_xcr_save;
 	u32 pdc_xnpr_save;
 	u32 pdc_xncr_save;
+
+	/* dmaengine data */
+	struct at_dma_slave atslave;
+	struct dma_async_tx_descriptor *desc;
+	dma_cookie_t cookie;
+	struct dma_chan *dma_chan;
 };
 
 
@@ -95,7 +124,7 @@
 {
 	struct snd_pcm_substream *substream = pcm->streams[stream].substream;
 	struct snd_dma_buffer *buf = &substream->dma_buffer;
-	size_t size = atmel_pcm_hardware.buffer_bytes_max;
+	size_t size = atmel_pcm_hardware->buffer_bytes_max;
 
 	buf->dev.type = SNDRV_DMA_TYPE_DEV;
 	buf->dev.dev = pcm->card->dev;
@@ -117,7 +146,7 @@
 /*--------------------------------------------------------------------------*\
  * ISR
 \*--------------------------------------------------------------------------*/
-static void atmel_pcm_dma_irq(u32 ssc_sr,
+static void atmel_pcm_pdc_irq(u32 ssc_sr,
 	struct snd_pcm_substream *substream)
 {
 	struct atmel_runtime_data *prtd = substream->runtime->private_data;
@@ -143,7 +172,7 @@
 		ssc_writex(params->ssc->regs, params->pdc->xpr,
 			   prtd->period_ptr);
 		ssc_writex(params->ssc->regs, params->pdc->xcr,
-			   prtd->period_size / params->pdc_xfer_size);
+			   prtd->period_size / params->data_xfer_size);
 		ssc_writex(params->ssc->regs, ATMEL_PDC_PTCR,
 			   params->mask->pdc_enable);
 	}
@@ -157,14 +186,166 @@
 		ssc_writex(params->ssc->regs, params->pdc->xnpr,
 			   prtd->period_ptr);
 		ssc_writex(params->ssc->regs, params->pdc->xncr,
-			   prtd->period_size / params->pdc_xfer_size);
+			   prtd->period_size / params->data_xfer_size);
 	}
 
 	snd_pcm_period_elapsed(substream);
 }
 
+/**
+ * atmel_pcm_dma_irq: SSC interrupt handler for DMAENGINE enabled SSC
+ *
+ * We use DMAENGINE to send/receive data to/from SSC so this ISR is only to
+ * check if any overrun occured.
+ */
+static void atmel_pcm_dma_irq(u32 ssc_sr,
+	struct snd_pcm_substream *substream)
+{
+	struct atmel_runtime_data *prtd = substream->runtime->private_data;
+	struct atmel_pcm_dma_params *params = prtd->params;
 
+	  if (ssc_sr & params->mask->ssc_error) {
+  		if (snd_pcm_running(substream))
+  			pr_warning("atmel-pcm: buffer %s on %s"
+  			" (SSC_SR=%#x)\n",
+  			substream->stream == SNDRV_PCM_STREAM_PLAYBACK
+  			? "underrun" : "overrun",
+  			 params->name, ssc_sr);
+
+		 /* stop RX and capture stream: will be enabled again at restart */
+        ssc_writex(params->ssc->regs, SSC_CR, params->mask->ssc_disable);
+		snd_pcm_stop(substream, SNDRV_PCM_STATE_XRUN);
+        /* now drain RHR and read status to remove xrun condition */
+        ssc_readx(params->ssc->regs, SSC_RHR);
+        ssc_readx(params->ssc->regs, SSC_SR);
+	}
+}
+
 /*--------------------------------------------------------------------------*\
+ * DMAENGINE operations
+\*--------------------------------------------------------------------------*/
+static bool filter(struct dma_chan *chan, void *slave)
+{
+	struct	at_dma_slave		*sl = slave;
+
+	if (sl->dma_dev == chan->device->dev) {
+		chan->private = sl;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static int atmel_pcm_dma_alloc(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct atmel_runtime_data *prtd = runtime->private_data;
+	struct ssc_device *ssc = prtd->params->ssc;
+	struct at_dma_slave *sdata = NULL;
+
+	if (ssc->pdev)
+		sdata = ssc->pdev->dev.platform_data;
+
+	if (sdata && sdata->dma_dev) {
+		dma_cap_mask_t mask;
+
+		/* setup DMA addresses */
+		sdata->rx_reg = (dma_addr_t)ssc->phybase + SSC_RHR;
+		sdata->tx_reg = (dma_addr_t)ssc->phybase + SSC_THR;
+
+		/* Try to grab a DMA channel */
+		dma_cap_zero(mask);
+		dma_cap_set(DMA_CYCLIC, mask);
+		prtd->dma_chan = dma_request_channel(mask, filter, sdata);
+	}
+	if (!prtd->dma_chan) {
+		pr_err("atmel-pcm: "
+			"DMA channel not available, unable to use SSC-audio\n");
+		return -EBUSY;
+	}
+
+	return 0;
+}
+
+static void audio_dma_irq(void *data)
+{
+	struct snd_pcm_substream *substream = (struct snd_pcm_substream *)data;
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct atmel_runtime_data *prtd = runtime->private_data;
+
+	prtd->period_ptr += prtd->period_size;
+	if (prtd->period_ptr >= prtd->dma_buffer_end)
+		prtd->period_ptr = prtd->dma_buffer;
+
+	snd_pcm_period_elapsed(substream);
+}
+
+static void atmel_pcm_dma_slave_config(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct atmel_runtime_data *prtd = runtime->private_data;
+	struct dma_chan *chan = prtd->dma_chan;
+	struct dma_slave_config slave_config;
+	enum dma_slave_buswidth buswidth;
+
+	switch (prtd->params->data_xfer_size) {
+	case 1:
+		buswidth = DMA_SLAVE_BUSWIDTH_1_BYTE;
+		break;
+	case 2:
+		buswidth = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	case 4:
+		buswidth = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	default:
+		return;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		slave_config.direction = DMA_TO_DEVICE;
+		slave_config.dst_addr_width = buswidth;
+	} else {
+		slave_config.direction = DMA_FROM_DEVICE;
+		slave_config.src_addr_width = buswidth;
+	}
+
+	chan->device->device_control(chan, DMA_SLAVE_CONFIG,
+			(unsigned long)&slave_config);
+
+}
+
+static int atmel_pcm_dma_prep(struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct atmel_runtime_data *prtd = runtime->private_data;
+	struct dma_chan *chan = prtd->dma_chan;
+
+	if (prtd->desc)
+		/* already been there: redo the prep job */
+		chan->device->device_control(chan, DMA_TERMINATE_ALL, 0);
+
+	/* setup dma configuration */
+	atmel_pcm_dma_slave_config(substream);
+
+	prtd->desc = chan->device->device_prep_dma_cyclic(chan, prtd->dma_buffer,
+			prtd->period_size * prtd->periods,
+			prtd->period_size,
+			substream->stream == SNDRV_PCM_STREAM_PLAYBACK ?
+			DMA_TO_DEVICE : DMA_FROM_DEVICE);
+	if (!prtd->desc) {
+		dev_err(&chan->dev->device, "cannot prepare slave dma\n");
+		return -EINVAL;
+	}
+
+	prtd->desc->callback = audio_dma_irq;
+	prtd->desc->callback_param = substream;
+
+	return 0;
+}
+
+/*--------------------------------------------------------------------------*\
  * PCM operations
 \*--------------------------------------------------------------------------*/
 static int atmel_pcm_hw_params(struct snd_pcm_substream *substream,
@@ -173,6 +354,7 @@
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct atmel_runtime_data *prtd = runtime->private_data;
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	int ret;
 
 	/* this may get called several times by oss emulation
 	 * with different params */
@@ -181,15 +363,34 @@
 	runtime->dma_bytes = params_buffer_bytes(params);
 
 	prtd->params = snd_soc_dai_get_dma_data(rtd->dai->cpu_dai, substream);
-	prtd->params->dma_intr_handler = atmel_pcm_dma_irq;
-
 	prtd->dma_buffer = runtime->dma_addr;
 	prtd->dma_buffer_end = runtime->dma_addr + runtime->dma_bytes;
 	prtd->period_size = params_period_bytes(params);
+	prtd->periods = params_periods(params);
 
+	if (ssc_use_dmaengine()) {
+		if (prtd->dma_chan == NULL) {
+			ret = atmel_pcm_dma_alloc(substream, params);
+			if (ret)
+				return ret;
+		}
+		ret = atmel_pcm_dma_prep(substream);
+		if (ret) {
+			dma_release_channel(prtd->dma_chan);
+			prtd->dma_chan = NULL;
+			return ret;
+		}
+
+		prtd->params->dma_intr_handler = atmel_pcm_dma_irq;
+	} else {
+		prtd->params->dma_intr_handler = atmel_pcm_pdc_irq;
+	}
+
 	pr_debug("atmel-pcm: "
-		"hw_params: DMA for %s initialized "
+		"hw_params: %s%s for %s initialized "
 		"(dma_bytes=%u, period_size=%u)\n",
+		prtd->dma_chan ? "DMA " : "PDC",
+		prtd->dma_chan ? dma_chan_name(prtd->dma_chan): "",
 		prtd->params->name,
 		runtime->dma_bytes,
 		prtd->period_size);
@@ -202,15 +403,31 @@
 	struct atmel_pcm_dma_params *params = prtd->params;
 
 	if (params != NULL) {
-		ssc_writex(params->ssc->regs, SSC_PDC_PTCR,
-			   params->mask->pdc_disable);
+		if (ssc_use_dmaengine()) {
+			struct dma_chan *chan = prtd->dma_chan;
+
+			if (chan) {
+				chan->device->device_control(chan,
+							DMA_TERMINATE_ALL, 0);
+				prtd->cookie = 0;
+				prtd->desc = NULL;
+				dma_release_channel(chan);
+				prtd->dma_chan = NULL;
+			}
+		} else {
+			ssc_writex(params->ssc->regs, SSC_PDC_PTCR,
+				   params->mask->pdc_disable);
+		}
 		prtd->params->dma_intr_handler = NULL;
 	}
 
 	return 0;
 }
 
-static int atmel_pcm_prepare(struct snd_pcm_substream *substream)
+/*--------------------------------------------------------------------------*\
+ * PCM callbacks using PDC
+\*--------------------------------------------------------------------------*/
+static int atmel_pcm_pdc_prepare(struct snd_pcm_substream *substream)
 {
 	struct atmel_runtime_data *prtd = substream->runtime->private_data;
 	struct atmel_pcm_dma_params *params = prtd->params;
@@ -222,7 +439,7 @@
 	return 0;
 }
 
-static int atmel_pcm_trigger(struct snd_pcm_substream *substream,
+static int atmel_pcm_pdc_trigger(struct snd_pcm_substream *substream,
 	int cmd)
 {
 	struct snd_pcm_runtime *rtd = substream->runtime;
@@ -241,13 +458,13 @@
 		ssc_writex(params->ssc->regs, params->pdc->xpr,
 			   prtd->period_ptr);
 		ssc_writex(params->ssc->regs, params->pdc->xcr,
-			   prtd->period_size / params->pdc_xfer_size);
+			   prtd->period_size / params->data_xfer_size);
 
 		prtd->period_ptr += prtd->period_size;
 		ssc_writex(params->ssc->regs, params->pdc->xnpr,
 			   prtd->period_ptr);
 		ssc_writex(params->ssc->regs, params->pdc->xncr,
-			   prtd->period_size / params->pdc_xfer_size);
+			   prtd->period_size / params->data_xfer_size);
 
 		pr_debug("atmel-pcm: trigger: "
 			"period_ptr=%lx, xpr=%u, "
@@ -265,7 +482,7 @@
 
 		pr_debug("sr=%u imr=%u\n",
 			ssc_readx(params->ssc->regs, SSC_SR),
-			ssc_readx(params->ssc->regs, SSC_IER));
+			ssc_readx(params->ssc->regs, SSC_IMR));
 		break;		/* SNDRV_PCM_TRIGGER_START */
 
 	case SNDRV_PCM_TRIGGER_STOP:
@@ -288,7 +505,7 @@
 	return ret;
 }
 
-static snd_pcm_uframes_t atmel_pcm_pointer(
+static snd_pcm_uframes_t atmel_pcm_pdc_pointer(
 	struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -306,13 +523,109 @@
 	return x;
 }
 
+/*--------------------------------------------------------------------------*\
+ * PCM callbacks using DMAENGINE
+\*--------------------------------------------------------------------------*/
+static int atmel_pcm_dma_prepare(struct snd_pcm_substream *substream)
+{
+	struct atmel_runtime_data *prtd = substream->runtime->private_data;
+	struct atmel_pcm_dma_params *params = prtd->params;
+
+	ssc_writex(params->ssc->regs, SSC_IDR, params->mask->ssc_error);
+	return 0;
+}
+
+static int atmel_pcm_dma_trigger(struct snd_pcm_substream *substream,
+	int cmd)
+{
+	struct snd_pcm_runtime *rtd = substream->runtime;
+	struct atmel_runtime_data *prtd = rtd->private_data;
+	struct atmel_pcm_dma_params *params = prtd->params;
+	dma_cookie_t cookie;
+	int ret = 0;
+
+	pr_debug("atmel-pcm: trigger %d: buffer_size = %ld,"
+		" dma_area = %p, dma_bytes = %u\n",
+		cmd, rtd->buffer_size, rtd->dma_area, rtd->dma_bytes);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+
+
+		if (prtd->cookie < DMA_MIN_COOKIE) {
+			cookie = prtd->desc->tx_submit(prtd->desc);
+			if (dma_submit_error(cookie)) {
+				ret = -EINVAL;
+				break;
+			}
+			prtd->cookie = cookie;
+			prtd->period_ptr = prtd->dma_buffer;
+		}
+
+		pr_debug("atmel-pcm: trigger: start sr=0x%08x imr=0x%08u\n",
+			ssc_readx(params->ssc->regs, SSC_SR),
+			ssc_readx(params->ssc->regs, SSC_IMR));
+
+		/* fallback */
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+	case SNDRV_PCM_TRIGGER_RESUME:
+		prtd->dma_chan->device->device_control(prtd->dma_chan,
+							DMA_RESUME, 0);
+		
+    /* It not already done or comming from xrun state */
+    ssc_readx(params->ssc->regs, SSC_SR);
+    ssc_writex(params->ssc->regs, SSC_IER, params->mask->ssc_error);
+    ssc_writex(params->ssc->regs, SSC_CR, params->mask->ssc_enable);
+  
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+		pr_debug("atmel-pcm: trigger: stop cmd = %d\n", cmd);
+
+		ssc_writex(params->ssc->regs, SSC_IDR, params->mask->ssc_error);
+
+		/* fallback */
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+		prtd->dma_chan->device->device_control(prtd->dma_chan,
+							DMA_PAUSE, 0);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t atmel_pcm_dma_pointer(
+	struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct atmel_runtime_data *prtd = runtime->private_data;
+	snd_pcm_uframes_t x;
+
+	dev_vdbg(substream->pcm->card->dev, "%s: 0x%08x %ld\n",
+		__func__, prtd->period_ptr,
+		bytes_to_frames(runtime, prtd->period_ptr - prtd->dma_buffer));
+
+	x = bytes_to_frames(runtime, prtd->period_ptr - prtd->dma_buffer);
+
+	if (x >= runtime->buffer_size)
+		x = 0;
+
+	return x;
+}
+
+
+/*--------------------------------------------------------------------------*\
+ * PCM open/close/mmap
+\*--------------------------------------------------------------------------*/
 static int atmel_pcm_open(struct snd_pcm_substream *substream)
 {
 	struct snd_pcm_runtime *runtime = substream->runtime;
 	struct atmel_runtime_data *prtd;
 	int ret = 0;
 
-	snd_soc_set_runtime_hwparams(substream, &atmel_pcm_hardware);
+	snd_soc_set_runtime_hwparams(substream, atmel_pcm_hardware);
 
 	/* ensure that buffer size is a multiple of period size */
 	ret = snd_pcm_hw_constraint_integer(runtime,
@@ -353,9 +666,9 @@
 	.ioctl		= snd_pcm_lib_ioctl,
 	.hw_params	= atmel_pcm_hw_params,
 	.hw_free	= atmel_pcm_hw_free,
-	.prepare	= atmel_pcm_prepare,
-	.trigger	= atmel_pcm_trigger,
-	.pointer	= atmel_pcm_pointer,
+	.prepare	= atmel_pcm_pdc_prepare,
+	.trigger	= atmel_pcm_pdc_trigger,
+	.pointer	= atmel_pcm_pdc_pointer,
 	.mmap		= atmel_pcm_mmap,
 };
 
@@ -383,7 +696,7 @@
 	}
 
 	if (dai->capture.channels_min) {
-		pr_debug("at32-pcm:"
+		pr_debug("atmel-pcm:"
 				"Allocating PCM capture DMA buffer\n");
 		ret = atmel_pcm_preallocate_dma_buffer(pcm,
 			SNDRV_PCM_STREAM_CAPTURE);
@@ -430,14 +743,19 @@
 	prtd = runtime->private_data;
 	params = prtd->params;
 
-	/* disable the PDC and save the PDC registers */
+	if (ssc_use_dmaengine()) {
+		prtd->dma_chan->device->device_control(prtd->dma_chan,
+							DMA_PAUSE, 0);
+	} else {
+		/* disable the PDC and save the PDC registers */
 
-	ssc_writel(params->ssc->regs, PDC_PTCR, params->mask->pdc_disable);
+		ssc_writel(params->ssc->regs, PDC_PTCR, params->mask->pdc_disable);
 
-	prtd->pdc_xpr_save = ssc_readx(params->ssc->regs, params->pdc->xpr);
-	prtd->pdc_xcr_save = ssc_readx(params->ssc->regs, params->pdc->xcr);
-	prtd->pdc_xnpr_save = ssc_readx(params->ssc->regs, params->pdc->xnpr);
-	prtd->pdc_xncr_save = ssc_readx(params->ssc->regs, params->pdc->xncr);
+		prtd->pdc_xpr_save = ssc_readx(params->ssc->regs, params->pdc->xpr);
+		prtd->pdc_xcr_save = ssc_readx(params->ssc->regs, params->pdc->xcr);
+		prtd->pdc_xnpr_save = ssc_readx(params->ssc->regs, params->pdc->xnpr);
+		prtd->pdc_xncr_save = ssc_readx(params->ssc->regs, params->pdc->xncr);
+	}
 
 	return 0;
 }
@@ -457,13 +775,18 @@
 	prtd = runtime->private_data;
 	params = prtd->params;
 
-	/* restore the PDC registers and enable the PDC */
-	ssc_writex(params->ssc->regs, params->pdc->xpr, prtd->pdc_xpr_save);
-	ssc_writex(params->ssc->regs, params->pdc->xcr, prtd->pdc_xcr_save);
-	ssc_writex(params->ssc->regs, params->pdc->xnpr, prtd->pdc_xnpr_save);
-	ssc_writex(params->ssc->regs, params->pdc->xncr, prtd->pdc_xncr_save);
+	if (ssc_use_dmaengine()) {
+		prtd->dma_chan->device->device_control(prtd->dma_chan,
+							DMA_RESUME, 0);
+	} else {
+		/* restore the PDC registers and enable the PDC */
+		ssc_writex(params->ssc->regs, params->pdc->xpr, prtd->pdc_xpr_save);
+		ssc_writex(params->ssc->regs, params->pdc->xcr, prtd->pdc_xcr_save);
+		ssc_writex(params->ssc->regs, params->pdc->xnpr, prtd->pdc_xnpr_save);
+		ssc_writex(params->ssc->regs, params->pdc->xncr, prtd->pdc_xncr_save);
 
-	ssc_writel(params->ssc->regs, PDC_PTCR, params->mask->pdc_enable);
+		ssc_writel(params->ssc->regs, PDC_PTCR, params->mask->pdc_enable);
+	}
 	return 0;
 }
 #else
@@ -483,6 +806,15 @@
 
 static int __init atmel_pcm_modinit(void)
 {
+	if (ssc_use_dmaengine()) {
+		atmel_pcm_ops.prepare = atmel_pcm_dma_prepare;
+		atmel_pcm_ops.trigger = atmel_pcm_dma_trigger;
+		atmel_pcm_ops.pointer = atmel_pcm_dma_pointer;
+
+		atmel_pcm_hardware = &atmel_pcm_dma_hardware;
+	} else {
+		atmel_pcm_hardware = &atmel_pcm_pdc_hardware;
+	}
 	return snd_soc_register_platform(&atmel_soc_platform);
 }
 module_init(atmel_pcm_modinit);
Index: linux-2.6.35/sound/soc/atmel/atmel-pcm.h
===================================================================
--- linux-2.6.35/sound/soc/atmel/atmel-pcm.h	(revision 149)
+++ linux-2.6.35/sound/soc/atmel/atmel-pcm.h	(revision 150)
@@ -50,6 +50,7 @@
 struct atmel_ssc_mask {
 	u32	ssc_enable;		/* SSC recv/trans enable */
 	u32	ssc_disable;		/* SSC recv/trans disable */
+	u32	ssc_error;		/* SSC error conditions */
 	u32	ssc_endx;		/* SSC ENDTX or ENDRX */
 	u32	ssc_endbuf;		/* SSC TXBUFE or RXBUFF */
 	u32	pdc_enable;		/* PDC recv/trans enable */
@@ -60,13 +61,14 @@
  * This structure, shared between the PCM driver and the interface,
  * contains all information required by the PCM driver to perform the
  * PDC DMA operation.  All fields except dma_intr_handler() are initialized
- * by the interface.  The dms_intr_handler() pointer is set by the PCM
+ * by the interface.  The dma_intr_handler() pointer is set by the PCM
  * driver and called by the interface SSC interrupt handler if it is
  * non-NULL.
  */
 struct atmel_pcm_dma_params {
 	char *name;			/* stream identifier */
-	int pdc_xfer_size;		/* PDC counter increment in bytes */
+	int data_xfer_size;		/* PDC counter increment in bytes,
+					   DMA data transfer size in bytes */
 	struct ssc_device *ssc;		/* SSC device for stream */
 	struct atmel_pdc_regs *pdc;	/* PDC receive or transmit registers */
 	struct atmel_ssc_mask *mask;	/* SSC & PDC status bits */
Index: linux-2.6.35/sound/soc/atmel/atmel_ssc_dai.c
===================================================================
--- linux-2.6.35/sound/soc/atmel/atmel_ssc_dai.c	(revision 149)
+++ linux-2.6.35/sound/soc/atmel/atmel_ssc_dai.c	(revision 150)
@@ -48,7 +48,8 @@
 #include "atmel_ssc_dai.h"
 
 
-#if defined(CONFIG_ARCH_AT91SAM9260) || defined(CONFIG_ARCH_AT91SAM9G20)
+#if defined(CONFIG_ARCH_AT91SAM9260) || defined(CONFIG_ARCH_AT91SAM9G20) \
+	|| defined(CONFIG_ARCH_AT91SAM9X5)
 #define NUM_SSC_DEVICES		1
 #else
 #define NUM_SSC_DEVICES		3
@@ -86,6 +87,7 @@
 static struct atmel_ssc_mask ssc_rx_mask = {
 	.ssc_enable	= SSC_BIT(CR_RXEN),
 	.ssc_disable	= SSC_BIT(CR_RXDIS),
+	.ssc_error	= SSC_BIT(SR_OVRUN),
 	.ssc_endx	= SSC_BIT(SR_ENDRX),
 	.ssc_endbuf	= SSC_BIT(SR_RXBUFF),
 	.pdc_enable	= ATMEL_PDC_RXTEN,
@@ -183,7 +185,8 @@
 		if ((dma_params != NULL) &&
 			(dma_params->dma_intr_handler != NULL)) {
 			ssc_substream_mask = (dma_params->mask->ssc_endx |
-					dma_params->mask->ssc_endbuf);
+					dma_params->mask->ssc_endbuf |
+					dma_params->mask->ssc_error);
 			if (ssc_sr & ssc_substream_mask) {
 				dma_params->dma_intr_handler(ssc_sr,
 						dma_params->
@@ -378,19 +381,19 @@
 	switch (params_format(params)) {
 	case SNDRV_PCM_FORMAT_S8:
 		bits = 8;
-		dma_params->pdc_xfer_size = 1;
+		dma_params->data_xfer_size = 1;
 		break;
 	case SNDRV_PCM_FORMAT_S16_LE:
 		bits = 16;
-		dma_params->pdc_xfer_size = 2;
+		dma_params->data_xfer_size = 2;
 		break;
 	case SNDRV_PCM_FORMAT_S24_LE:
 		bits = 24;
-		dma_params->pdc_xfer_size = 4;
+		dma_params->data_xfer_size = 4;
 		break;
 	case SNDRV_PCM_FORMAT_S32_LE:
 		bits = 32;
-		dma_params->pdc_xfer_size = 4;
+		dma_params->data_xfer_size = 4;
 		break;
 	default:
 		printk(KERN_WARNING "atmel_ssc_dai: unsupported PCM format");
@@ -564,15 +567,17 @@
 		/* Reset the SSC and its PDC registers */
 		ssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_SWRST));
 
-		ssc_writel(ssc_p->ssc->regs, PDC_RPR, 0);
-		ssc_writel(ssc_p->ssc->regs, PDC_RCR, 0);
-		ssc_writel(ssc_p->ssc->regs, PDC_RNPR, 0);
-		ssc_writel(ssc_p->ssc->regs, PDC_RNCR, 0);
+		if (!ssc_use_dmaengine()) {
+			ssc_writel(ssc_p->ssc->regs, PDC_RPR, 0);
+			ssc_writel(ssc_p->ssc->regs, PDC_RCR, 0);
+			ssc_writel(ssc_p->ssc->regs, PDC_RNPR, 0);
+			ssc_writel(ssc_p->ssc->regs, PDC_RNCR, 0);
 
-		ssc_writel(ssc_p->ssc->regs, PDC_TPR, 0);
-		ssc_writel(ssc_p->ssc->regs, PDC_TCR, 0);
-		ssc_writel(ssc_p->ssc->regs, PDC_TNPR, 0);
-		ssc_writel(ssc_p->ssc->regs, PDC_TNCR, 0);
+			ssc_writel(ssc_p->ssc->regs, PDC_TPR, 0);
+			ssc_writel(ssc_p->ssc->regs, PDC_TCR, 0);
+			ssc_writel(ssc_p->ssc->regs, PDC_TNPR, 0);
+			ssc_writel(ssc_p->ssc->regs, PDC_TNCR, 0);
+		}
 
 		ret = request_irq(ssc_p->ssc->irq, atmel_ssc_interrupt, 0,
 				ssc_p->name, ssc_p);
@@ -630,13 +635,11 @@
 #ifdef CONFIG_PM
 static int atmel_ssc_suspend(struct snd_soc_dai *cpu_dai)
 {
-	struct atmel_ssc_info *ssc_p;
-
+    struct atmel_ssc_info *ssc_p = &ssc_info[cpu_dai->id];
+	
 	if (!cpu_dai->active)
-		return 0;
+		goto out;
 
-	ssc_p = &ssc_info[cpu_dai->id];
-
 	/* Save the status register before disabling transmit and receive */
 	ssc_p->ssc_state.ssc_sr = ssc_readl(ssc_p->ssc->regs, SR);
 	ssc_writel(ssc_p->ssc->regs, CR, SSC_BIT(CR_TXDIS) | SSC_BIT(CR_RXDIS));
@@ -651,6 +654,12 @@
 	ssc_p->ssc_state.ssc_tcmr = ssc_readl(ssc_p->ssc->regs, TCMR);
 	ssc_p->ssc_state.ssc_tfmr = ssc_readl(ssc_p->ssc->regs, TFMR);
 
+out:
+  if (ssc_p->initialized) {
+  pr_debug("atmel_ssc_dai: suspend - stop clock\n");
+  clk_disable(ssc_p->ssc->clk);
+  }
+
 	return 0;
 }
 
@@ -658,14 +667,16 @@
 
 static int atmel_ssc_resume(struct snd_soc_dai *cpu_dai)
 {
-	struct atmel_ssc_info *ssc_p;
-	u32 cr;
+	struct atmel_ssc_info *ssc_p = &ssc_info[cpu_dai->id];
+    u32 cr;
+    if (ssc_p->initialized) {
+	 pr_debug("atmel_ssc_dai: resume - restart clock\n");
+	 clk_enable(ssc_p->ssc->clk);
+	 }		 
 
 	if (!cpu_dai->active)
 		return 0;
 
-	ssc_p = &ssc_info[cpu_dai->id];
-
 	/* restore SSC register settings */
 	ssc_writel(ssc_p->ssc->regs, TFMR, ssc_p->ssc_state.ssc_tfmr);
 	ssc_writel(ssc_p->ssc->regs, TCMR, ssc_p->ssc_state.ssc_tcmr);
Index: linux-2.6.35/sound/soc/atmel/sam9g20_wm8731.c
===================================================================
--- linux-2.6.35/sound/soc/atmel/sam9g20_wm8731.c	(revision 149)
+++ linux-2.6.35/sound/soc/atmel/sam9g20_wm8731.c	(revision 150)
@@ -29,6 +29,10 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#define DEBUG 12
+#define VERBOSE 12
+#define VERBOSE_DEBUG 12
+
 #include <linux/module.h>
 #include <linux/moduleparam.h>
 #include <linux/kernel.h>
@@ -54,7 +58,8 @@
 #include "atmel-pcm.h"
 #include "atmel_ssc_dai.h"
 
-#define MCLK_RATE 12000000
+//#define MCLK_RATE 12000000
+#define MCLK_RATE 12288000
 
 /*
  * As shipped the board does not have inputs.  However, it is relatively
@@ -119,18 +124,31 @@
 }
 
 static const struct snd_soc_dapm_widget at91sam9g20ek_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+#if 0
 	SND_SOC_DAPM_MIC("Int Mic", NULL),
 	SND_SOC_DAPM_SPK("Ext Spk", NULL),
+#endif
 };
 
 static const struct snd_soc_dapm_route intercon[] = {
-
+	/* headphone connected to HPOUT */
+	{ "Headphone Jack", NULL, "RHPOUT" },
+	{ "Headphone Jack", NULL, "LHPOUT" },
+#if 0
 	/* speaker connected to LHPOUT */
 	{"Ext Spk", NULL, "LHPOUT"},
 
 	/* mic is connected to Mic Jack, with WM8731 Mic Bias */
 	{"MICIN", NULL, "Mic Bias"},
 	{"Mic Bias", NULL, "Int Mic"},
+#endif
+
+#if 0
+	/* inputs */
+	{"Line Input", NULL, "LLINEIN"},
+	{"Line Input", NULL, "RLINEIN"},
+#endif
 };
 
 /*
@@ -162,14 +180,17 @@
 	snd_soc_dapm_nc_pin(codec, "RLINEIN");
 	snd_soc_dapm_nc_pin(codec, "LLINEIN");
 
+#if 0
 #ifdef ENABLE_MIC_INPUT
 	snd_soc_dapm_enable_pin(codec, "Int Mic");
 #else
 	snd_soc_dapm_nc_pin(codec, "Int Mic");
 #endif
+#endif
 
 	/* always connected */
-	snd_soc_dapm_enable_pin(codec, "Ext Spk");
+	//snd_soc_dapm_enable_pin(codec, "Ext Spk");
+	snd_soc_dapm_enable_pin(codec, "Headphone Jack");
 
 	snd_soc_dapm_sync(codec);
 
@@ -186,7 +207,7 @@
 };
 
 static struct snd_soc_card snd_soc_at91sam9g20ek = {
-	.name = "AT91SAMG20-EK",
+	.name = "AT91SAM9-EK",
 	.platform = &atmel_soc_platform,
 	.dai_link = &at91sam9g20ek_dai,
 	.num_links = 1,
@@ -204,37 +225,56 @@
 {
 	struct atmel_ssc_info *ssc_p = at91sam9g20ek_dai.cpu_dai->private_data;
 	struct ssc_device *ssc = NULL;
-	struct clk *pllb;
 	int ret;
 
-	if (!(machine_is_at91sam9g20ek() || machine_is_at91sam9g20ek_2mmc()))
+	printk(KERN_CRIT "********** at91sam9g20ek_init()\n");
+
+	if (!(machine_is_at91sam9g20ek() || machine_is_at91sam9g20ek_2mmc()
+	   || machine_is_at91sam9x5ek()))
 		return -ENODEV;
 
-	/*
-	 * Codec MCLK is supplied by PCK0 - set it up.
-	 */
-	mclk = clk_get(NULL, "pck0");
-	if (IS_ERR(mclk)) {
-		printk(KERN_ERR "ASoC: Failed to get MCLK\n");
-		ret = PTR_ERR(mclk);
-		goto err;
+
+	if (!machine_is_at91sam9x5ek()) {
+		/*
+		 * Codec MCLK is supplied by PCK0 - set it up.
+		 */
+		struct clk *pllb;
+
+		mclk = clk_get(NULL, "pck0");
+		if (IS_ERR(mclk)) {
+			printk(KERN_ERR "ASoC: Failed to get MCLK\n");
+			ret = PTR_ERR(mclk);
+			goto err;
+		}
+
+		pllb = clk_get(NULL, "pllb");
+		if (IS_ERR(mclk)) {
+			printk(KERN_ERR "ASoC: Failed to get PLLB\n");
+			ret = PTR_ERR(mclk);
+			goto err_mclk;
+		}
+		ret = clk_set_parent(mclk, pllb);
+		clk_put(pllb);
+		if (ret != 0) {
+			printk(KERN_ERR "ASoC: Failed to set MCLK parent\n");
+			goto err_mclk;
+		}
+
+		clk_set_rate(mclk, MCLK_RATE);
 	}
 
-	pllb = clk_get(NULL, "pllb");
-	if (IS_ERR(mclk)) {
-		printk(KERN_ERR "ASoC: Failed to get PLLB\n");
-		ret = PTR_ERR(mclk);
-		goto err_mclk;
+	if (machine_is_at91sam9x5ek()) {
+		at91sam9g20ek_snd_devdata.card->set_bias_level = NULL;
+
+		/* remove some not supported rates in relation with clock
+		 * provided to the wm8731 codec */
+		wm8731_dai.playback.rates &= SNDRV_PCM_RATE_8000 |
+					     SNDRV_PCM_RATE_32000 |
+					     SNDRV_PCM_RATE_48000 |
+					     SNDRV_PCM_RATE_96000;
+		/*TODO: same for capture*/
 	}
-	ret = clk_set_parent(mclk, pllb);
-	clk_put(pllb);
-	if (ret != 0) {
-		printk(KERN_ERR "ASoC: Failed to set MCLK parent\n");
-		goto err_mclk;
-	}
 
-	clk_set_rate(mclk, MCLK_RATE);
-
 	/*
 	 * Request SSC device
 	 */
@@ -251,6 +291,7 @@
 	if (!at91sam9g20ek_snd_device) {
 		printk(KERN_ERR "ASoC: Platform device allocation failed\n");
 		ret = -ENOMEM;
+		goto err_ssc;
 	}
 
 	platform_set_drvdata(at91sam9g20ek_snd_device,
@@ -261,8 +302,11 @@
 	if (ret) {
 		printk(KERN_ERR "ASoC: Platform device allocation failed\n");
 		platform_device_put(at91sam9g20ek_snd_device);
+		goto err_ssc;
 	}
 
+	printk(KERN_INFO "ASoC: at91sam9g20ek_init ok\n");
+
 	return ret;
 
 err_ssc:
Index: linux-2.6.35/sound/soc/atmel/Makefile
===================================================================
--- linux-2.6.35/sound/soc/atmel/Makefile	(revision 149)
+++ linux-2.6.35/sound/soc/atmel/Makefile	(revision 150)
@@ -7,10 +7,12 @@
 
 # AT91 Machine Support
 snd-soc-sam9g20-wm8731-objs := sam9g20_wm8731.o
+snd-soc-sam9x5-wm8731-objs := sam9x5_wm8731.o
 
 # AT32 Machine Support
 snd-soc-playpaq-objs := playpaq_wm8510.o
 
 obj-$(CONFIG_SND_AT91_SOC_SAM9G20_WM8731) += snd-soc-sam9g20-wm8731.o
+obj-$(CONFIG_SND_AT91_SOC_SAM9X5_WM8731) += snd-soc-sam9x5-wm8731.o
 obj-$(CONFIG_SND_AT32_SOC_PLAYPAQ) += snd-soc-playpaq.o
 obj-$(CONFIG_SND_AT91_SOC_AFEB9260) += snd-soc-afeb9260.o
Index: linux-2.6.35/sound/soc/atmel/sam9x5_wm8731.c
===================================================================
--- linux-2.6.35/sound/soc/atmel/sam9x5_wm8731.c	(revision 0)
+++ linux-2.6.35/sound/soc/atmel/sam9x5_wm8731.c	(revision 150)
@@ -0,0 +1,247 @@
+/*
+ * sam9x5_wm8731  --	SoC audio for AT91SAM9X5-based boards
+ * 			that are using WM8731 as codec.
+ *
+ *  Copyright (C) 2011 Atmel,
+ *  		  Nicolas Ferre <nicolas.ferre@atmel.com>
+ *
+ * Based on sam9g20_wm8731.c by:
+ * Sedji Gaouaou <sedji.gaouaou@atmel.com>
+ *
+ * GPLv2
+ */
+
+//#define DEBUG 12
+//#define VERBOSE 12
+//#define VERBOSE_DEBUG 12
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/clk.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+
+#include <linux/atmel-ssc.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/soc-dapm.h>
+
+#include <asm/mach-types.h>
+#include <mach/hardware.h>
+#include <mach/gpio.h>
+
+#include "../codecs/wm8731.h"
+#include "atmel-pcm.h"
+#include "atmel_ssc_dai.h"
+
+#define MCLK_RATE 12000000
+
+static int at91sam9x5ek_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = substream->private_data;
+	struct snd_soc_dai *codec_dai = rtd->dai->codec_dai;
+	struct snd_soc_dai *cpu_dai = rtd->dai->cpu_dai;
+	int ret;
+
+	/* set codec DAI configuration */
+	ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+
+	/* set cpu DAI configuration */
+	ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_I2S |
+		SND_SOC_DAIFMT_NB_NF | SND_SOC_DAIFMT_CBM_CFM);
+	if (ret < 0)
+		return ret;
+
+	/* set the codec system clock for DAC and ADC */
+	ret = snd_soc_dai_set_sysclk(codec_dai, WM8731_SYSCLK, MCLK_RATE,
+		SND_SOC_CLOCK_IN);
+	if (ret < 0) {
+		printk(KERN_ERR "Failed to set WM8731 SYSCLK: %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static struct snd_soc_ops at91sam9x5ek_ops = {
+	.hw_params = at91sam9x5ek_hw_params,
+};
+
+/*
+ * Audio paths on at91sam9x5ek board:
+ *
+ *  |AT| ------> |        | ----> Headphone Jack
+ *  |  | <-CLK-> | WM8751 |
+ *  |91| <------ |        | <---- Line In Jack
+ */
+static const struct snd_soc_dapm_widget at91sam9x5ek_dapm_widgets[] = {
+	SND_SOC_DAPM_HP("Headphone Jack", NULL),
+	SND_SOC_DAPM_LINE("Line In Jack", NULL),
+};
+
+static const struct snd_soc_dapm_route intercon[] = {
+	/* headphone jack connected to HPOUT */
+	{"Headphone Jack", NULL, "RHPOUT"},
+	{"Headphone Jack", NULL, "LHPOUT"},
+
+	/* line in jack connected LINEIN */
+	{"LLINEIN", NULL, "Line In Jack"},
+	{"RLINEIN", NULL, "Line In Jack"},
+};
+
+/*
+ * Logic for a wm8731 as connected on a at91sam9x5 based board.
+ */
+static int at91sam9x5ek_wm8731_init(struct snd_soc_codec *codec)
+{
+	printk(KERN_DEBUG "ASoC: at91sam9x5ek_wm8731_init() called\n");
+
+	/* set not connected pins */
+	snd_soc_dapm_nc_pin(codec, "Mic Bias");
+	snd_soc_dapm_nc_pin(codec, "MICIN");
+	snd_soc_dapm_nc_pin(codec, "LOUT");
+	snd_soc_dapm_nc_pin(codec, "ROUT");
+
+	/* add specific widgets */
+	snd_soc_dapm_new_controls(codec, at91sam9x5ek_dapm_widgets,
+				  ARRAY_SIZE(at91sam9x5ek_dapm_widgets));
+	/* set up specific audio path interconnects */
+	snd_soc_dapm_add_routes(codec, intercon, ARRAY_SIZE(intercon));
+
+	/* always connected */
+	snd_soc_dapm_enable_pin(codec, "Headphone Jack");
+	snd_soc_dapm_enable_pin(codec, "Line In Jack");
+
+	/* signal a DAPM event */
+	snd_soc_dapm_sync(codec);
+	return 0;
+}
+
+static struct snd_soc_dai_link at91sam9x5ek_dai = {
+	.name = "WM8731",
+	.stream_name = "WM8731 PCM",
+	.cpu_dai = &atmel_ssc_dai[0],
+	.codec_dai = &wm8731_dai,
+	.init = at91sam9x5ek_wm8731_init,
+	.ops = &at91sam9x5ek_ops,
+};
+
+static struct snd_soc_card snd_soc_at91sam9x5ek = {
+	.name = "AT91SAM9X5",
+	.platform = &atmel_soc_platform,
+	.dai_link = &at91sam9x5ek_dai,
+	.num_links = 1,
+};
+
+static struct snd_soc_device at91sam9x5ek_snd_devdata = {
+	.card = &snd_soc_at91sam9x5ek,
+	.codec_dev = &soc_codec_dev_wm8731,
+};
+
+static struct platform_device *at91sam9x5ek_snd_device;
+
+static int __init at91sam9x5ek_init(void)
+{
+	struct atmel_ssc_info *ssc_p = at91sam9x5ek_dai.cpu_dai->private_data;
+	struct ssc_device *ssc = NULL;
+	int ret;
+
+	if (!machine_is_at91sam9x5ek())
+		return -ENODEV;
+
+	/* remove some not supported rates in relation with clock
+	 * provided to the wm8731 codec */
+	switch (MCLK_RATE) {
+	case 12288000:
+		wm8731_dai.playback.rates &= SNDRV_PCM_RATE_8000 |
+					     SNDRV_PCM_RATE_32000 |
+					     SNDRV_PCM_RATE_48000 |
+					     SNDRV_PCM_RATE_96000;
+		wm8731_dai.capture.rates &= SNDRV_PCM_RATE_8000 |
+					     SNDRV_PCM_RATE_32000 |
+					     SNDRV_PCM_RATE_48000 |
+					     SNDRV_PCM_RATE_96000;
+		break;
+	case 12000000:
+		/* all wm8731 rates supported */
+		break;
+	default:
+		printk(KERN_ERR "ASoC: codec Master clock rate not defined\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	/*
+	 * Request SSC device
+	 */
+	ssc = ssc_request(0);
+	if (IS_ERR(ssc)) {
+		printk(KERN_ERR "ASoC: Failed to request SSC 0\n");
+		ret = PTR_ERR(ssc);
+		ssc = NULL;
+		goto err_ssc;
+	}
+	ssc_p->ssc = ssc;
+
+	at91sam9x5ek_snd_device = platform_device_alloc("soc-audio", -1);
+	if (!at91sam9x5ek_snd_device) {
+		printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+		ret = -ENOMEM;
+		goto err_ssc;
+	}
+
+	platform_set_drvdata(at91sam9x5ek_snd_device,
+			&at91sam9x5ek_snd_devdata);
+	at91sam9x5ek_snd_devdata.dev = &at91sam9x5ek_snd_device->dev;
+
+	ret = platform_device_add(at91sam9x5ek_snd_device);
+	if (ret) {
+		printk(KERN_ERR "ASoC: Platform device allocation failed\n");
+		platform_device_put(at91sam9x5ek_snd_device);
+		goto err_ssc;
+	}
+
+	printk(KERN_INFO "ASoC: at91sam9x5ek_init ok\n");
+
+	return ret;
+
+err_ssc:
+	ssc_free(ssc);
+	ssc_p->ssc = NULL;
+err:
+	return ret;
+}
+
+static void __exit at91sam9x5ek_exit(void)
+{
+	struct atmel_ssc_info *ssc_p = at91sam9x5ek_dai.cpu_dai->private_data;
+	struct ssc_device *ssc;
+
+	if (ssc_p != NULL) {
+		ssc = ssc_p->ssc;
+		if (ssc != NULL)
+			ssc_free(ssc);
+		ssc_p->ssc = NULL;
+	}
+
+	platform_device_unregister(at91sam9x5ek_snd_device);
+	at91sam9x5ek_snd_device = NULL;
+}
+
+module_init(at91sam9x5ek_init);
+module_exit(at91sam9x5ek_exit);
+
+/* Module information */
+MODULE_AUTHOR("Nicolas Ferre <nicolas.ferre@atmel.com>");
+MODULE_DESCRIPTION("ALSA SoC machine driver for AT91SAM9x5 - WM8731");
+MODULE_LICENSE("GPL");
Index: linux-2.6.35/arch/arm/tools/mach-types
===================================================================
--- linux-2.6.35/arch/arm/tools/mach-types	(revision 149)
+++ linux-2.6.35/arch/arm/tools/mach-types	(revision 150)
@@ -12,7 +12,7 @@
 #
 #   http://www.arm.linux.org.uk/developer/machines/?action=new
 #
-# Last update: Mon Jul 12 21:10:14 2010
+# Last update: Thu Feb 24 09:23:10 2011
 #
 # machine_is_xxx	CONFIG_xxxx		MACH_TYPE_xxx		number
 #
@@ -1319,7 +1319,7 @@
 msm			MACH_MSM		MSM			1316
 ct5910			MACH_CT5910		CT5910			1317
 ct5912			MACH_CT5912		CT5912			1318
-hynet_ine		MACH_HYNET_INE		HYNET_INE		1319
+argonst_mp		MACH_HYNET_INE		HYNET_INE		1319
 hynet_app		MACH_HYNET_APP		HYNET_APP		1320
 msm7200			MACH_MSM7200		MSM7200			1321
 msm7600			MACH_MSM7600		MSM7600			1322
@@ -1777,7 +1777,7 @@
 sg560adsl		MACH_SG560ADSL		SG560ADSL		1786
 nextio_n2800_ica	MACH_NEXTIO_N2800_ICA	NEXTIO_N2800_ICA	1787
 dove_db			MACH_DOVE_DB		DOVE_DB			1788
-marvell_newdb		MACH_MARVELL_NEWDB	MARVELL_NEWDB		1789
+dove_avng		MACH_MARVELL_NEWDB	MARVELL_NEWDB		1789
 vandihud		MACH_VANDIHUD		VANDIHUD		1790
 magx_e8			MACH_MAGX_E8		MAGX_E8			1791
 magx_z6			MACH_MAGX_Z6		MAGX_Z6			1792
@@ -1877,7 +1877,7 @@
 esiblade		MACH_ESIBLADE		ESIBLADE		1886
 eye02			MACH_EYE02		EYE02			1887
 imx27kbd		MACH_IMX27KBD		IMX27KBD		1888
-sst61vc010_fpga		MACH_SST61VC010_FPGA	SST61VC010_FPGA		1889
+p87_fpga		MACH_SST61VC010_FPGA	SST61VC010_FPGA		1889
 kixvp435		MACH_KIXVP435		KIXVP435		1890
 kixnp435		MACH_KIXNP435		KIXNP435		1891
 africa			MACH_AFRICA		AFRICA			1892
@@ -2240,7 +2240,7 @@
 vs_v210			MACH_VS_V210		VS_V210			2252
 vs_v212			MACH_VS_V212		VS_V212			2253
 hmt			MACH_HMT		HMT			2254
-suen3			MACH_SUEN3		SUEN3			2255
+km_kirkwood		MACH_KM_KIRKWOOD	KM_KIRKWOOD		2255
 vesper			MACH_VESPER		VESPER			2256
 str9			MACH_STR9		STR9			2257
 omap3_wl_ff		MACH_OMAP3_WL_FF	OMAP3_WL_FF		2258
@@ -2308,7 +2308,7 @@
 tazkiosk		MACH_TAZKIOSK		TAZKIOSK		2320
 whiterabbit_mch		MACH_WHITERABBIT_MCH	WHITERABBIT_MCH		2321
 sbox9263		MACH_SBOX9263		SBOX9263		2322
-oreo			MACH_OREO		OREO			2323
+oreo_camera		MACH_OREO		OREO			2323
 smdk6442		MACH_SMDK6442		SMDK6442		2324
 openrd_base		MACH_OPENRD_BASE	OPENRD_BASE		2325
 incredible		MACH_INCREDIBLE		INCREDIBLE		2326
@@ -2321,7 +2321,7 @@
 u380			MACH_U380		U380			2333
 oamp3_hualu		MACH_HUALU_BOARD	HUALU_BOARD		2334
 npcmx50			MACH_NPCMX50		NPCMX50			2335
-mx51_lange51		MACH_MX51_LANGE51	MX51_LANGE51		2336
+mx51_efikamx		MACH_MX51_EFIKAMX	MX51_EFIKAMX		2336
 mx51_lange52		MACH_MX51_LANGE52	MX51_LANGE52		2337
 riom			MACH_RIOM		RIOM			2338
 comcas			MACH_COMCAS		COMCAS			2339
@@ -2355,7 +2355,7 @@
 csb732			MACH_CSB732		CSB732			2367
 u8500			MACH_U8500		U8500			2368
 huqiu			MACH_HUQIU		HUQIU			2369
-mx51_kunlun		MACH_MX51_KUNLUN	MX51_KUNLUN		2370
+mx51_efikasb		MACH_MX51_EFIKASB	MX51_EFIKASB		2370
 pmt1g			MACH_PMT1G		PMT1G			2371
 htcelf			MACH_HTCELF		HTCELF			2372
 armadillo420		MACH_ARMADILLO420	ARMADILLO420		2373
@@ -2374,7 +2374,7 @@
 rbl01			MACH_RBL01		RBL01			2387
 omnifi			MACH_OMNIFI		OMNIFI			2388
 otavalo			MACH_OTAVALO		OTAVALO			2389
-sienna			MACH_SIENNA		SIENNA			2390
+siena			MACH_SIENNA		SIENNA			2390
 htc_excalibur_s620	MACH_HTC_EXCALIBUR_S620	HTC_EXCALIBUR_S620	2391
 htc_opal		MACH_HTC_OPAL		HTC_OPAL		2392
 touchbook		MACH_TOUCHBOOK		TOUCHBOOK		2393
@@ -2446,7 +2446,7 @@
 siogentoo2		MACH_SIOGENTOO2		SIOGENTOO2		2459
 sm3k			MACH_SM3K		SM3K			2460
 acer_tempo_f900		MACH_ACER_TEMPO_F900	ACER_TEMPO_F900		2461
-sst61vc010_dev		MACH_SST61VC010_DEV	SST61VC010_DEV		2462
+p87_dev			MACH_SST61VC010_DEV	SST61VC010_DEV		2462
 glittertind		MACH_GLITTERTIND	GLITTERTIND		2463
 omap_zoom3		MACH_OMAP_ZOOM3		OMAP_ZOOM3		2464
 omap_3630sdp		MACH_OMAP_3630SDP	OMAP_3630SDP		2465
@@ -2498,7 +2498,7 @@
 phy3250			MACH_PHY3250		PHY3250			2511
 ea3250			MACH_EA3250		EA3250			2512
 fdi3250			MACH_FDI3250		FDI3250			2513
-whitestone		MACH_WHITESTONE		WHITESTONE		2514
+htcwhitestone		MACH_WHITESTONE		WHITESTONE		2514
 at91sam9263nit		MACH_AT91SAM9263NIT	AT91SAM9263NIT		2515
 ccmx51			MACH_CCMX51		CCMX51			2516
 ccmx51js		MACH_CCMX51JS		CCMX51JS		2517
@@ -2561,7 +2561,7 @@
 emxx			MACH_EMXX		EMXX			2574
 outlaw			MACH_OUTLAW		OUTLAW			2575
 riot_bei2		MACH_RIOT_BEI2		RIOT_BEI2		2576
-riot_vox		MACH_RIOT_VOX		RIOT_VOX		2577
+riot_gx2		MACH_RIOT_VOX		RIOT_VOX		2577
 riot_x37		MACH_RIOT_X37		RIOT_X37		2578
 mega25mx		MACH_MEGA25MX		MEGA25MX		2579
 benzina2		MACH_BENZINA2		BENZINA2		2580
@@ -2582,7 +2582,7 @@
 pca101			MACH_PCA101		PCA101			2595
 buzzc			MACH_BUZZC		BUZZC			2596
 sasie2			MACH_SASIE2		SASIE2			2597
-davinci_cio		MACH_DAVINCI_CIO	DAVINCI_CIO		2598
+davinci_dm6467_cio	MACH_DAVINCI_CIO	DAVINCI_CIO		2598
 smartmeter_dl		MACH_SMARTMETER_DL	SMARTMETER_DL		2599
 wzl6410			MACH_WZL6410		WZL6410			2600
 wzl6410m		MACH_WZL6410M		WZL6410M		2601
@@ -2591,7 +2591,7 @@
 spacecom1		MACH_SPACECOM1		SPACECOM1		2604
 pingu920		MACH_PINGU920		PINGU920		2605
 bravoc			MACH_BRAVOC		BRAVOC			2606
-cybo2440		MACH_CYBO2440		CYBO2440		2607
+mydev			MACH_CYBO2440		CYBO2440		2607
 vdssw			MACH_VDSSW		VDSSW			2608
 romulus			MACH_ROMULUS		ROMULUS			2609
 omap_magic		MACH_OMAP_MAGIC		OMAP_MAGIC		2610
@@ -2622,7 +2622,7 @@
 gw2388			MACH_GW2388		GW2388			2635
 jadecpu			MACH_JADECPU		JADECPU			2636
 carlisle		MACH_CARLISLE		CARLISLE		2637
-lux_sf9			MACH_LUX_SFT9		LUX_SFT9		2638
+lux_sf9			MACH_LUX_SF9		LUX_SF9			2638
 nemid_tb		MACH_NEMID_TB		NEMID_TB		2639
 terrier			MACH_TERRIER		TERRIER			2640
 turbot			MACH_TURBOT		TURBOT			2641
@@ -2683,7 +2683,7 @@
 mw6410			MACH_MW6410		MW6410			2696
 terastation_wxl		MACH_TERASTATION_WXL	TERASTATION_WXL		2697
 cpu8000e		MACH_CPU8000E		CPU8000E		2698
-catania			MACH_CATANIA		CATANIA			2699
+catania_s		MACH_CATANIA		CATANIA			2699
 tokyo			MACH_TOKYO		TOKYO			2700
 msm7201a_surf		MACH_MSM7201A_SURF	MSM7201A_SURF		2701
 msm7201a_ffa		MACH_MSM7201A_FFA	MSM7201A_FFA		2702
@@ -2741,7 +2741,7 @@
 mt65xx			MACH_MT65XX		MT65XX			2754
 msm8x60_surf		MACH_MSM8X60_SURF	MSM8X60_SURF		2755
 msm8x60_sim		MACH_MSM8X60_SIM	MSM8X60_SIM		2756
-vmc300			MACH_VMC300		VMC300			2757
+cvc600			MACH_VMC300		VMC300			2757
 tcc8000_sdk		MACH_TCC8000_SDK	TCC8000_SDK		2758
 nanos			MACH_NANOS		NANOS			2759
 stamp9g10		MACH_STAMP9G10		STAMP9G10		2760
@@ -2750,7 +2750,7 @@
 smint01			MACH_SMINT01		SMINT01			2763
 prtlvt2			MACH_PRTLVT2		PRTLVT2			2764
 ap420			MACH_AP420		AP420			2765
-htcshift		MACH_HTCSHIFT		HTCSHIFT		2766
+htcclio			MACH_HTCSHIFT		HTCSHIFT		2766
 davinci_dm365_fc	MACH_DAVINCI_DM365_FC	DAVINCI_DM365_FC	2767
 msm8x55_surf		MACH_MSM8X55_SURF	MSM8X55_SURF		2768
 msm8x55_ffa		MACH_MSM8X55_FFA	MSM8X55_FFA		2769
@@ -2761,7 +2761,7 @@
 kopin_models		MACH_KOPIN_MODELS	KOPIN_MODELS		2774
 ttc_vision2		MACH_TTC_VISION2	TTC_VISION2		2775
 cns3420vb		MACH_CNS3420VB		CNS3420VB		2776
-lpc2			MACH_LPC2		LPC2			2777
+lpc_evo			MACH_LPC2		LPC2			2777
 olympus			MACH_OLYMPUS		OLYMPUS			2778
 vortex			MACH_VORTEX		VORTEX			2779
 s5pc200			MACH_S5PC200		S5PC200			2780
@@ -2788,7 +2788,7 @@
 neocoreomap		MACH_NEOCOREOMAP	NEOCOREOMAP		2801
 withings_wbp		MACH_WITHINGS_WBP	WITHINGS_WBP		2802
 dbps			MACH_DBPS		DBPS			2803
-sbc9261			MACH_SBC9261		SBC9261			2804
+at91sam9261		MACH_SBC9261		SBC9261			2804
 pcbfp0001		MACH_PCBFP0001		PCBFP0001		2805
 speedy			MACH_SPEEDY		SPEEDY			2806
 chrysaor		MACH_CHRYSAOR		CHRYSAOR		2807
@@ -2812,7 +2812,7 @@
 acer_a4			MACH_ACER_A4		ACER_A4			2825
 davinci_dm368_bip	MACH_DAVINCI_DM368_BIP	DAVINCI_DM368_BIP	2826
 eshare			MACH_ESHARE		ESHARE			2827
-hw_omapl138_europa	MACH_HW_OMAPL138_EUROPA	HW_OMAPL138_EUROPA	2828
+omapl138_europa		MACH_HW_OMAPL138_EUROPA	HW_OMAPL138_EUROPA	2828
 wlbargn			MACH_WLBARGN		WLBARGN			2829
 bm170			MACH_BM170		BM170			2830
 netspace_mini_v2	MACH_NETSPACE_MINI_V2	NETSPACE_MINI_V2	2831
@@ -2879,7 +2879,7 @@
 mecha			MACH_MECHA		MECHA			2892
 bubba3			MACH_BUBBA3		BUBBA3			2893
 pupitre			MACH_PUPITRE		PUPITRE			2894
-tegra_harmony		MACH_TEGRA_HARMONY	TEGRA_HARMONY		2895
+tegra_unused		MACH_TEGRA_HARMONY	TEGRA_HARMONY		2895
 tegra_vogue		MACH_TEGRA_VOGUE	TEGRA_VOGUE		2896
 tegra_e1165		MACH_TEGRA_E1165	TEGRA_E1165		2897
 simplenet		MACH_SIMPLENET		SIMPLENET		2898
@@ -2896,6 +2896,7 @@
 app3k_robin		MACH_APP3K_ROBIN	APP3K_ROBIN		2909
 pov15hd			MACH_POV15HD		POV15HD			2910
 stella			MACH_STELLA		STELLA			2911
+htc_iolite		MACH_MACH_HTC_IOLITE	MACH_HTC_IOLITE		2912
 linkstation_lschl	MACH_LINKSTATION_LSCHL	LINKSTATION_LSCHL	2913
 netwalker		MACH_NETWALKER		NETWALKER		2914
 acsx106			MACH_ACSX106		ACSX106			2915
@@ -2950,3 +2951,415 @@
 netviz			MACH_NETVIZ		NETVIZ			2964
 flexibity		MACH_FLEXIBITY		FLEXIBITY		2965
 wlan_computer		MACH_WLAN_COMPUTER	WLAN_COMPUTER		2966
+lpc24xx			MACH_LPC24XX		LPC24XX			2967
+spica			MACH_SPICA		SPICA			2968
+gpsdisplay		MACH_GPSDISPLAY		GPSDISPLAY		2969
+bipnet			MACH_BIPNET		BIPNET			2970
+overo_ctu_inertial	MACH_OVERO_CTU_INERTIAL	OVERO_CTU_INERTIAL	2971
+davinci_dm355_mmm	MACH_DAVINCI_DM355_MMM	DAVINCI_DM355_MMM	2972
+pc9260_v2		MACH_PC9260_V2		PC9260_V2		2973
+ptx7545			MACH_PTX7545		PTX7545			2974
+tm_efdc			MACH_TM_EFDC		TM_EFDC			2975
+remove_me		MACH_WALDO1		WALDO1			2976
+omap3_waldo1		MACH_OMAP3_WALDO1	OMAP3_WALDO1		2977
+flyer			MACH_FLYER		FLYER			2978
+tornado3240		MACH_TORNADO3240	TORNADO3240		2979
+soli_01			MACH_SOLI_01		SOLI_01			2980
+omapl138_europalc	MACH_OMAPL138_EUROPALC	OMAPL138_EUROPALC	2981
+helios_v1		MACH_HELIOS_V1		HELIOS_V1		2982
+netspace_lite_v2	MACH_NETSPACE_LITE_V2	NETSPACE_LITE_V2	2983
+ssc			MACH_SSC		SSC			2984
+premierwave_en		MACH_PREMIERWAVE_EN	PREMIERWAVE_EN		2985
+wasabi			MACH_WASABI		WASABI			2986
+vivo_w			MACH_VIVOW		VIVOW			2987
+mx50_rdp		MACH_MX50_RDP		MX50_RDP		2988
+universal_c210		MACH_UNIVERSAL_C210	UNIVERSAL_C210		2989
+real6410		MACH_REAL6410		REAL6410		2990
+spx_sakura		MACH_SPX_SAKURA		SPX_SAKURA		2991
+ij3k_2440		MACH_IJ3K_2440		IJ3K_2440		2992
+omap3_bc10		MACH_OMAP3_BC10		OMAP3_BC10		2993
+thebe			MACH_THEBE		THEBE			2994
+rv082			MACH_RV082		RV082			2995
+armlguest		MACH_ARMLGUEST		ARMLGUEST		2996
+tjinc1000		MACH_TJINC1000		TJINC1000		2997
+dockstar		MACH_DOCKSTAR		DOCKSTAR		2998
+ax8008			MACH_AX8008		AX8008			2999
+gnet_sgce		MACH_GNET_SGCE		GNET_SGCE		3000
+pxwnas_500_1000		MACH_PXWNAS_500_1000	PXWNAS_500_1000		3001
+ea20			MACH_EA20		EA20			3002
+awm2			MACH_AWM2		AWM2			3003
+ti8148evm		MACH_TI8148EVM		TI8148EVM		3004
+seaboard		MACH_SEABOARD		SEABOARD		3005
+linkstation_chlv2	MACH_LINKSTATION_CHLV2	LINKSTATION_CHLV2	3006
+tera_pro2_rack		MACH_TERA_PRO2_RACK	TERA_PRO2_RACK		3007
+rubys			MACH_RUBYS		RUBYS			3008
+aquarius		MACH_AQUARIUS		AQUARIUS		3009
+mx53_ard		MACH_MX53_ARD		MX53_ARD		3010
+mx53_smd		MACH_MX53_SMD		MX53_SMD		3011
+lswxl			MACH_LSWXL		LSWXL			3012
+dove_avng_v3		MACH_DOVE_AVNG_V3	DOVE_AVNG_V3		3013
+sdi_ess_9263		MACH_SDI_ESS_9263	SDI_ESS_9263		3014
+jocpu550		MACH_JOCPU550		JOCPU550		3015
+msm8x60_rumi3		MACH_MSM8X60_RUMI3	MSM8X60_RUMI3		3016
+msm8x60_ffa		MACH_MSM8X60_FFA	MSM8X60_FFA		3017
+yanomami		MACH_YANOMAMI		YANOMAMI		3018
+gta04			MACH_GTA04		GTA04			3019
+cm_a510			MACH_CM_A510		CM_A510			3020
+omap3_rfs200		MACH_OMAP3_RFS200	OMAP3_RFS200		3021
+kx33xx			MACH_KX33XX		KX33XX			3022
+ptx7510			MACH_PTX7510		PTX7510			3023
+top9000			MACH_TOP9000		TOP9000			3024
+teenote			MACH_TEENOTE		TEENOTE			3025
+ts3			MACH_TS3		TS3			3026
+a0			MACH_A0			A0			3027
+fsm9xxx_surf		MACH_FSM9XXX_SURF	FSM9XXX_SURF		3028
+fsm9xxx_ffa		MACH_FSM9XXX_FFA	FSM9XXX_FFA		3029
+frrhwcdma60w		MACH_FRRHWCDMA60W	FRRHWCDMA60W		3030
+remus			MACH_REMUS		REMUS			3031
+at91cap7xdk		MACH_AT91CAP7XDK	AT91CAP7XDK		3032
+at91cap7stk		MACH_AT91CAP7STK	AT91CAP7STK		3033
+kt_sbc_sam9_1		MACH_KT_SBC_SAM9_1	KT_SBC_SAM9_1		3034
+at91sam9263router	MACH_ORATISROUTER	ORATISROUTER		3035
+armada_xp_db		MACH_ARMADA_XP_DB	ARMADA_XP_DB		3036
+spdm			MACH_SPDM		SPDM			3037
+gtib			MACH_GTIB		GTIB			3038
+dgm3240			MACH_DGM3240		DGM3240			3039
+iv_atlas_i_lpe		MACH_ATLAS_I_LPE	ATLAS_I_LPE		3040
+htcmega			MACH_HTCMEGA		HTCMEGA			3041
+tricorder		MACH_TRICORDER		TRICORDER		3042
+tx28			MACH_TX28		TX28			3043
+bstbrd			MACH_BSTBRD		BSTBRD			3044
+pwb3090			MACH_PWB3090		PWB3090			3045
+idea6410		MACH_IDEA6410		IDEA6410		3046
+qbc9263			MACH_QBC9263		QBC9263			3047
+borabora		MACH_BORABORA		BORABORA		3048
+valdez			MACH_VALDEZ		VALDEZ			3049
+ls9g20			MACH_LS9G20		LS9G20			3050
+mios_v1			MACH_MIOS_V1		MIOS_V1			3051
+s5pc110_crespo		MACH_S5PC110_CRESPO	S5PC110_CRESPO		3052
+controltek9g20		MACH_CONTROLTEK9G20	CONTROLTEK9G20		3053
+tin307			MACH_TIN307		TIN307			3054
+tin510			MACH_TIN510		TIN510			3055
+ep3505			MACH_EP3517		EP3517			3056
+bluecheese		MACH_BLUECHEESE		BLUECHEESE		3057
+tem3x30			MACH_TEM3X30		TEM3X30			3058
+harvest_desoto		MACH_HARVEST_DESOTO	HARVEST_DESOTO		3059
+msm8x60_qrdc		MACH_MSM8X60_QRDC	MSM8X60_QRDC		3060
+spear900		MACH_SPEAR900		SPEAR900		3061
+pcontrol_g20		MACH_PCONTROL_G20	PCONTROL_G20		3062
+rdstor			MACH_RDSTOR		RDSTOR			3063
+usdloader		MACH_USDLOADER		USDLOADER		3064
+tsoploader		MACH_TSOPLOADER		TSOPLOADER		3065
+kronos			MACH_KRONOS		KRONOS			3066
+ffcore			MACH_FFCORE		FFCORE			3067
+mone			MACH_MONE		MONE			3068
+unit2s			MACH_UNIT2S		UNIT2S			3069
+acer_a5			MACH_ACER_A5		ACER_A5			3070
+etherpro_isp		MACH_ETHERPRO_ISP	ETHERPRO_ISP		3071
+stretchs7000		MACH_STRETCHS7000	STRETCHS7000		3072
+p87_smartsim		MACH_P87_SMARTSIM	P87_SMARTSIM		3073
+tulip			MACH_TULIP		TULIP			3074
+sunflower		MACH_SUNFLOWER		SUNFLOWER		3075
+rib			MACH_RIB		RIB			3076
+clod			MACH_CLOD		CLOD			3077
+rump			MACH_RUMP		RUMP			3078
+tenderloin		MACH_TENDERLOIN		TENDERLOIN		3079
+shortloin		MACH_SHORTLOIN		SHORTLOIN		3080
+roml1			MACH_CRESPO		CRESPO			3081
+antares			MACH_ANTARES		ANTARES			3082
+wb40n			MACH_WB40N		WB40N			3083
+herring			MACH_HERRING		HERRING			3084
+naxy400			MACH_NAXY400		NAXY400			3085
+naxy1200		MACH_NAXY1200		NAXY1200		3086
+vpr200			MACH_VPR200		VPR200			3087
+bug20			MACH_BUG20		BUG20			3088
+goflexnet		MACH_GOFLEXNET		GOFLEXNET		3089
+torbreck		MACH_TORBRECK		TORBRECK		3090
+saarb_mg1		MACH_SAARB_MG1		SAARB_MG1		3091
+callisto		MACH_CALLISTO		CALLISTO		3092
+multhsu			MACH_MULTHSU		MULTHSU			3093
+saluda			MACH_SALUDA		SALUDA			3094
+pemp_omap3_apollo	MACH_PEMP_OMAP3_APOLLO	PEMP_OMAP3_APOLLO	3095
+vc0718			MACH_VC0718		VC0718			3096
+mvblx			MACH_MVBLX		MVBLX			3097
+inhand_apeiron		MACH_INHAND_APEIRON	INHAND_APEIRON		3098
+inhand_fury		MACH_INHAND_FURY	INHAND_FURY		3099
+inhand_siren		MACH_INHAND_SIREN	INHAND_SIREN		3100
+hdnvp			MACH_HDNVP		HDNVP			3101
+softwinner		MACH_SOFTWINNER		SOFTWINNER		3102
+prima2_evb		MACH_PRIMA2_EVB		PRIMA2_EVB		3103
+nas6210			MACH_NAS6210		NAS6210			3104
+unisdev			MACH_UNISDEV		UNISDEV			3105
+sbca11			MACH_SBCA11		SBCA11			3106
+saga			MACH_SAGA		SAGA			3107
+ns_k330			MACH_NS_K330		NS_K330			3108
+tanna			MACH_TANNA		TANNA			3109
+imate8502		MACH_IMATE8502		IMATE8502		3110
+aspen			MACH_ASPEN		ASPEN			3111
+daintree_cwac		MACH_DAINTREE_CWAC	DAINTREE_CWAC		3112
+zmx25			MACH_ZMX25		ZMX25			3113
+maple1			MACH_MAPLE1		MAPLE1			3114
+qsd8x72_surf		MACH_QSD8X72_SURF	QSD8X72_SURF		3115
+qsd8x72_ffa		MACH_QSD8X72_FFA	QSD8X72_FFA		3116
+abilene			MACH_ABILENE		ABILENE			3117
+eigen_ttr		MACH_EIGEN_TTR		EIGEN_TTR		3118
+iomega_ix2_200		MACH_IOMEGA_IX2_200	IOMEGA_IX2_200		3119
+coretec_vcx7400		MACH_CORETEC_VCX7400	CORETEC_VCX7400		3120
+santiago		MACH_SANTIAGO		SANTIAGO		3121
+mx257sol		MACH_MX257SOL		MX257SOL		3122
+strasbourg		MACH_STRASBOURG		STRASBOURG		3123
+msm8x60_fluid		MACH_MSM8X60_FLUID	MSM8X60_FLUID		3124
+smartqv5		MACH_SMARTQV5		SMARTQV5		3125
+smartqv3		MACH_SMARTQV3		SMARTQV3		3126
+smartqv7		MACH_SMARTQV7		SMARTQV7		3127
+tegra_paz00		MACH_PAZ00		PAZ00			3128
+acmenetusfoxg20		MACH_ACMENETUSFOXG20	ACMENETUSFOXG20		3129
+htc_willow		MACH_HTCWILLOW		HTCWILLOW		3130
+fwbd_0404		MACH_FWBD_0404		FWBD_0404		3131
+hdgu			MACH_HDGU		HDGU			3132
+pyramid			MACH_PYRAMID		PYRAMID			3133
+epiphan			MACH_EPIPHAN		EPIPHAN			3134
+omap_bender		MACH_OMAP_BENDER	OMAP_BENDER		3135
+gurnard			MACH_GURNARD		GURNARD			3136
+gtl_it5100		MACH_GTL_IT5100		GTL_IT5100		3137
+bcm2708			MACH_BCM2708		BCM2708			3138
+mx51_ggc		MACH_MX51_GGC		MX51_GGC		3139
+sharespace		MACH_SHARESPACE		SHARESPACE		3140
+haba_knx_explorer	MACH_HABA_KNX_EXPLORER	HABA_KNX_EXPLORER	3141
+simtec_kirkmod		MACH_SIMTEC_KIRKMOD	SIMTEC_KIRKMOD		3142
+crux			MACH_CRUX		CRUX			3143
+mx51_bravo		MACH_MX51_BRAVO		MX51_BRAVO		3144
+charon			MACH_CHARON		CHARON			3145
+picocom3		MACH_PICOCOM3		PICOCOM3		3146
+picocom4		MACH_PICOCOM4		PICOCOM4		3147
+serrano			MACH_SERRANO		SERRANO			3148
+doubleshot		MACH_DOUBLESHOT		DOUBLESHOT		3149
+evsy			MACH_EVSY		EVSY			3150
+huashan			MACH_HUASHAN		HUASHAN			3151
+lausanne		MACH_LAUSANNE		LAUSANNE		3152
+emerald			MACH_EMERALD		EMERALD			3153
+tqma35			MACH_TQMA35		TQMA35			3154
+marvel			MACH_MARVEL		MARVEL			3155
+manuae			MACH_MANUAE		MANUAE			3156
+chacha			MACH_CHACHA		CHACHA			3157
+lemon			MACH_LEMON		LEMON			3158
+csc			MACH_CSC		CSC			3159
+gira_knxip_router	MACH_GIRA_KNXIP_ROUTER	GIRA_KNXIP_ROUTER	3160
+t20			MACH_T20		T20			3161
+hdmini			MACH_HDMINI		HDMINI			3162
+sciphone_g2		MACH_SCIPHONE_G2	SCIPHONE_G2		3163
+express			MACH_EXPRESS		EXPRESS			3164
+express_kt		MACH_EXPRESS_KT		EXPRESS_KT		3165
+maximasp		MACH_MAXIMASP		MAXIMASP		3166
+nitrogen_imx51		MACH_NITROGEN_IMX51	NITROGEN_IMX51		3167
+nitrogen_imx53		MACH_NITROGEN_IMX53	NITROGEN_IMX53		3168
+sunfire			MACH_SUNFIRE		SUNFIRE			3169
+arowana			MACH_AROWANA		AROWANA			3170
+tegra_daytona		MACH_TEGRA_DAYTONA	TEGRA_DAYTONA		3171
+tegra_swordfish		MACH_TEGRA_SWORDFISH	TEGRA_SWORDFISH		3172
+edison			MACH_EDISON		EDISON			3173
+svp8500v1		MACH_SVP8500V1		SVP8500V1		3174
+svp8500v2		MACH_SVP8500V2		SVP8500V2		3175
+svp5500			MACH_SVP5500		SVP5500			3176
+b5500			MACH_B5500		B5500			3177
+s5500			MACH_S5500		S5500			3178
+icon			MACH_ICON		ICON			3179
+elephant		MACH_ELEPHANT		ELEPHANT		3180
+msm8x60_charm_surf	MACH_MSM8X60_FUSION	MSM8X60_FUSION		3181
+shooter			MACH_SHOOTER		SHOOTER			3182
+spade_lte		MACH_SPADE_LTE		SPADE_LTE		3183
+philhwani		MACH_PHILHWANI		PHILHWANI		3184
+gsncomm			MACH_GSNCOMM		GSNCOMM			3185
+strasbourg_a2		MACH_STRASBOURG_A2	STRASBOURG_A2		3186
+mmm			MACH_MMM		MMM			3187
+davinci_dm365_bv	MACH_DAVINCI_DM365_BV	DAVINCI_DM365_BV	3188
+ag5evm			MACH_AG5EVM		AG5EVM			3189
+sc575plc		MACH_SC575PLC		SC575PLC		3190
+sc575hmi		MACH_SC575IPC		SC575IPC		3191
+omap3_tdm3730		MACH_OMAP3_TDM3730	OMAP3_TDM3730		3192
+rover_g7		MACH_G7			G7			3193
+top9000_eval		MACH_TOP9000_EVAL	TOP9000_EVAL		3194
+top9000_su		MACH_TOP9000_SU		TOP9000_SU		3195
+utm300			MACH_UTM300		UTM300			3196
+tsunagi			MACH_TSUNAGI		TSUNAGI			3197
+ts75xx			MACH_TS75XX		TS75XX			3198
+msm8x60_charm_ffa	MACH_MSM8X60_FUSN_FFA	MSM8X60_FUSN_FFA	3199
+ts47xx			MACH_TS47XX		TS47XX			3200
+da850_k5		MACH_DA850_K5		DA850_K5		3201
+ax502			MACH_AX502		AX502			3202
+igep0032		MACH_IGEP0032		IGEP0032		3203
+antero			MACH_ANTERO		ANTERO			3204
+synergy			MACH_SYNERGY		SYNERGY			3205
+ics_if_voip		MACH_ICS_IF_VOIP	ICS_IF_VOIP		3206
+wlf_cragg_6410		MACH_WLF_CRAGG_6410	WLF_CRAGG_6410		3207
+punica			MACH_PUNICA		PUNICA			3208
+trimslice		MACH_TRIMSLICE		TRIMSLICE		3209
+mx27_wmultra		MACH_MX27_WMULTRA	MX27_WMULTRA		3210
+mackerel		MACH_MACKEREL		MACKEREL		3211
+pvd_imx27		MACH_MACH_PVD_IMX27	MACH_PVD_IMX27		3212
+fa9x27			MACH_FA9X27		FA9X27			3213
+ns2816tb		MACH_NS2816TB		NS2816TB		3214
+ns2816_ntpad		MACH_NS2816_NTPAD	NS2816_NTPAD		3215
+ns2816_ntnb		MACH_NS2816_NTNB	NS2816_NTNB		3216
+kaen			MACH_KAEN		KAEN			3217
+nv1000			MACH_NV1000		NV1000			3218
+nuc950ts		MACH_NUC950TS		NUC950TS		3219
+nokia_rm680		MACH_NOKIA_RM680	NOKIA_RM680		3220
+ast2200			MACH_AST2200		AST2200			3221
+lead			MACH_LEAD		LEAD			3222
+unino1			MACH_UNINO1		UNINO1			3223
+greeco			MACH_GREECO		GREECO			3224
+verdi			MACH_VERDI		VERDI			3225
+dm6446_adbox		MACH_DM6446_ADBOX	DM6446_ADBOX		3226
+quad_salsa		MACH_QUAD_SALSA		QUAD_SALSA		3227
+abb_gma_1_1		MACH_ABB_GMA_1_1	ABB_GMA_1_1		3228
+svcid			MACH_SVCID		SVCID			3229
+msm8960_sim		MACH_MSM8960_SIM	MSM8960_SIM		3230
+msm8960_rumi3		MACH_MSM8960_RUMI3	MSM8960_RUMI3		3231
+icon_g			MACH_ICON_G		ICON_G			3232
+mb3			MACH_MB3		MB3			3233
+gsia18s			MACH_GSIA18S		GSIA18S			3234
+pivicc			MACH_PIVICC		PIVICC			3235
+pcm048			MACH_PCM048		PCM048			3236
+dds			MACH_DDS		DDS			3237
+chalten_xa1		MACH_CHALTEN_XA1	CHALTEN_XA1		3238
+ts48xx			MACH_TS48XX		TS48XX			3239
+tonga2_tfttimer		MACH_TONGA2_TFTTIMER	TONGA2_TFTTIMER		3240
+whistler		MACH_WHISTLER		WHISTLER		3241
+asl_phoenix		MACH_ASL_PHOENIX	ASL_PHOENIX		3242
+at91sam9263otlite	MACH_AT91SAM9263OTLITE	AT91SAM9263OTLITE	3243
+ddplug			MACH_DDPLUG		DDPLUG			3244
+d2plug			MACH_D2PLUG		D2PLUG			3245
+kzm9d			MACH_KZM9D		KZM9D			3246
+verdi_lte		MACH_VERDI_LTE		VERDI_LTE		3247
+nanozoom		MACH_NANOZOOM		NANOZOOM		3248
+dm3730_som_lv		MACH_DM3730_SOM_LV	DM3730_SOM_LV		3249
+dm3730_torpedo		MACH_DM3730_TORPEDO	DM3730_TORPEDO		3250
+anchovy			MACH_ANCHOVY		ANCHOVY			3251
+linux			MACH_LINUX		LINUX			3252
+re2rev20		MACH_RE2REV20		RE2REV20		3253
+re2rev21		MACH_RE2REV21		RE2REV21		3254
+cns21xx			MACH_CNS21XX		CNS21XX			3255
+rider			MACH_RIDER		RIDER			3257
+nsk330			MACH_NSK330		NSK330			3258
+cns2133evb		MACH_CNS2133EVB		CNS2133EVB		3259
+z3_816x_mod		MACH_Z3_816X_MOD	Z3_816X_MOD		3260
+z3_814x_mod		MACH_Z3_814X_MOD	Z3_814X_MOD		3261
+beect			MACH_BEECT		BEECT			3262
+dma_thunderbug		MACH_DMA_THUNDERBUG	DMA_THUNDERBUG		3263
+omn_at91sam9g20		MACH_OMN_AT91SAM9G20	OMN_AT91SAM9G20		3264
+mx25_e2s_uc		MACH_MX25_E2S_UC	MX25_E2S_UC		3265
+mione			MACH_MIONE		MIONE			3266
+top9000_tcu		MACH_TOP9000_TCU	TOP9000_TCU		3267
+top9000_bsl		MACH_TOP9000_BSL	TOP9000_BSL		3268
+kingdom			MACH_KINGDOM		KINGDOM			3269
+armadillo460		MACH_ARMADILLO460	ARMADILLO460		3270
+lq2			MACH_LQ2		LQ2			3271
+sweda_tms2		MACH_SWEDA_TMS2		SWEDA_TMS2		3272
+mx53_loco		MACH_MX53_LOCO		MX53_LOCO		3273
+acer_a7			MACH_MACH_ACER_A7	MACH_ACER_A7		3274
+acer_a8			MACH_ACER_A8		ACER_A8			3275
+acer_gauguin		MACH_ACER_GAUGUIN	ACER_GAUGUIN		3276
+guppy			MACH_GUPPY		GUPPY			3277
+mx61_ard		MACH_MX61_ARD		MX61_ARD		3278
+tx53			MACH_TX53		TX53			3279
+omapl138_case_a3	MACH_OMAPL138_CASE_A3	OMAPL138_CASE_A3	3280
+uemd			MACH_UEMD		UEMD			3281
+ccwmx51mut		MACH_CCWMX51MUT		CCWMX51MUT		3282
+rockhopper		MACH_ROCKHOPPER		ROCKHOPPER		3283
+nookcolor		MACH_NOOKCOLOR		NOOKCOLOR		3284
+hkdkc100		MACH_HKDKC100		HKDKC100		3285
+ts42xx			MACH_TS42XX		TS42XX			3286
+aebl			MACH_AEBL		AEBL			3287
+wario			MACH_WARIO		WARIO			3288
+gfs_spm			MACH_GFS_SPM		GFS_SPM			3289
+cm_t3730		MACH_CM_T3730		CM_T3730		3290
+isc3			MACH_ISC3		ISC3			3291
+rascal			MACH_RASCAL		RASCAL			3292
+hrefv60			MACH_HREFV60		HREFV60			3293
+tpt_2_0			MACH_TPT_2_0		TPT_2_0			3294
+pyramid_td		MACH_PYRAMID_TD		PYRAMID_TD		3295
+splendor		MACH_SPLENDOR		SPLENDOR		3296
+guf_planet		MACH_GUF_PLANET		GUF_PLANET		3297
+msm8x60_qt		MACH_MSM8X60_QT		MSM8X60_QT		3298
+htc_hd_mini		MACH_HTC_HD_MINI	HTC_HD_MINI		3299
+athene			MACH_ATHENE		ATHENE			3300
+deep_r_ek_1		MACH_DEEP_R_EK_1	DEEP_R_EK_1		3301
+vivow_ct		MACH_VIVOW_CT		VIVOW_CT		3302
+nery_1000		MACH_NERY_1000		NERY_1000		3303
+rfl109145_ssrv		MACH_RFL109145_SSRV	RFL109145_SSRV		3304
+nmh			MACH_NMH		NMH			3305
+wn802t			MACH_WN802T		WN802T			3306
+dragonet		MACH_DRAGONET		DRAGONET		3307
+geneva_b		MACH_GENEVA_B		GENEVA_B		3308
+at91sam9263desk16l	MACH_AT91SAM9263DESK16L	AT91SAM9263DESK16L	3309
+bcmhana_sv		MACH_BCMHANA_SV		BCMHANA_SV		3310
+bcmhana_tablet		MACH_BCMHANA_TABLET	BCMHANA_TABLET		3311
+koi			MACH_KOI		KOI			3312
+ts4800			MACH_TS4800		TS4800			3313
+tqma9263		MACH_TQMA9263		TQMA9263		3314
+holiday			MACH_HOLIDAY		HOLIDAY			3315
+dma_6410		MACH_DMA6410		DMA6410			3316
+pcats_overlay		MACH_PCATS_OVERLAY	PCATS_OVERLAY		3317
+hwgw6410		MACH_HWGW6410		HWGW6410		3318
+shenzhou		MACH_SHENZHOU		SHENZHOU		3319
+cwme9210		MACH_CWME9210		CWME9210		3320
+cwme9210js		MACH_CWME9210JS		CWME9210JS		3321
+pgs_v1			MACH_PGS_SITARA		PGS_SITARA		3322
+colibri_tegra2		MACH_COLIBRI_TEGRA2	COLIBRI_TEGRA2		3323
+w21			MACH_W21		W21			3324
+polysat1		MACH_POLYSAT1		POLYSAT1		3325
+dataway			MACH_DATAWAY		DATAWAY			3326
+cobral138		MACH_COBRAL138		COBRAL138		3327
+roverpcs8		MACH_ROVERPCS8		ROVERPCS8		3328
+marvelc			MACH_MARVELC		MARVELC			3329
+navefihid		MACH_NAVEFIHID		NAVEFIHID		3330
+dm365_cv100		MACH_DM365_CV100	DM365_CV100		3331
+able			MACH_ABLE		ABLE			3332
+legacy			MACH_LEGACY		LEGACY			3333
+icong			MACH_ICONG		ICONG			3334
+rover_g8		MACH_ROVER_G8		ROVER_G8		3335
+t5388p			MACH_T5388P		T5388P			3336
+dingo			MACH_DINGO		DINGO			3337
+goflexhome		MACH_GOFLEXHOME		GOFLEXHOME		3338
+mach_omap3517evm	MACH_MACH_OMAP3517EVM	MACH_OMAP3517EVM	3339
+lanreadyfn511		MACH_LANREADYFN511	LANREADYFN511		3340
+omap3_baia		MACH_OMAP3_BAIA		OMAP3_BAIA		3341
+omap3smartdisplay	MACH_OMAP3SMARTDISPLAY	OMAP3SMARTDISPLAY	3342
+xilinx			MACH_XILINX		XILINX			3343
+a2f			MACH_A2F		A2F			3344
+sky25			MACH_SKY25		SKY25			3345
+ccmx53			MACH_CCMX53		CCMX53			3346
+ccmx53js		MACH_CCMX53JS		CCMX53JS		3347
+ccwmx53			MACH_CCWMX53		CCWMX53			3348
+ccwmx53js		MACH_CCWMX53JS		CCWMX53JS		3349
+frisms			MACH_FRISMS		FRISMS			3350
+msm7x27a_ffa		MACH_MSM7X27A_FFA	MSM7X27A_FFA		3351
+msm7x27a_surf		MACH_MSM7X27A_SURF	MSM7X27A_SURF		3352
+msm7x27a_rumi3		MACH_MSM7X27A_RUMI3	MSM7X27A_RUMI3		3353
+dimmsam9g20		MACH_DIMMSAM9G20	DIMMSAM9G20		3354
+dimm_imx28		MACH_DIMM_IMX28		DIMM_IMX28		3355
+amk_a4			MACH_AMK_A4		AMK_A4			3356
+gnet_sgme		MACH_GNET_SGME		GNET_SGME		3357
+shooter_u		MACH_SHOOTER_U		SHOOTER_U		3358
+vmx53			MACH_VMX53		VMX53			3359
+rhino			MACH_RHINO		RHINO			3360
+armlex4210		MACH_ARMLEX4210		ARMLEX4210		3361
+swarcoextmodem		MACH_SWARCOEXTMODEM	SWARCOEXTMODEM		3362
+snowball		MACH_SNOWBALL		SNOWBALL		3363
+pcm049			MACH_PCM049		PCM049			3364
+vigor			MACH_VIGOR		VIGOR			3365
+oslo_amundsen		MACH_OSLO_AMUNDSEN	OSLO_AMUNDSEN		3366
+gsl_diamond		MACH_GSL_DIAMOND	GSL_DIAMOND		3367
+cv2201			MACH_CV2201		CV2201			3368
+cv2202			MACH_CV2202		CV2202			3369
+cv2203			MACH_CV2203		CV2203			3370
+vit_ibox		MACH_VIT_IBOX		VIT_IBOX		3371
+dm6441_esp		MACH_DM6441_ESP		DM6441_ESP		3372
+at91sam9x5ek		MACH_AT91SAM9X5EK	AT91SAM9X5EK		3373
+libra			MACH_LIBRA		LIBRA			3374
+easycrrh		MACH_EASYCRRH		EASYCRRH		3375
+tripel			MACH_TRIPEL		TRIPEL			3376
+endian_mini		MACH_ENDIAN_MINI	ENDIAN_MINI		3377
+xilinx_ep107		MACH_XILINX_EP107	XILINX_EP107		3378
+nuri			MACH_NURI		NURI			3379
Index: linux-2.6.35/arch/arm/mach-at91/gpio.c
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/gpio.c	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/gpio.c	(revision 150)
@@ -20,6 +20,7 @@
 #include <linux/module.h>
 #include <linux/io.h>
 
+#include <mach/cpu.h>
 #include <mach/hardware.h>
 #include <mach/at91_pio.h>
 #include <mach/gpio.h>
@@ -69,6 +70,12 @@
 
 static int gpio_banks;
 
+/*
+ * Functionnality can change with newer chips
+ */
+#define cpu_has_pio3()	(cpu_is_at91sam9x5())
+
+
 static inline void __iomem *pin_to_controller(unsigned pin)
 {
 	pin -= PIN_BASE;
@@ -86,6 +93,52 @@
 }
 
 
+static char peripheral_function(void __iomem *pio, unsigned mask)
+{
+	char	ret = 'X';
+	u8	select;
+
+	if (pio) {
+		if (cpu_has_pio3()) {
+			select = !!(__raw_readl(pio + PIO_ABCDSR1) & mask);
+			select |= (!!(__raw_readl(pio + PIO_ABCDSR2) & mask) << 1);
+			ret = 'A' + select;
+		} else {
+			ret = __raw_readl(pio + PIO_ABSR) & mask ?
+							'B' : 'A';
+		}
+	}
+
+	return ret;
+}
+
+static void gpio_printf(struct seq_file *s, void __iomem *pio, unsigned mask)
+{
+	char	*trigger = NULL;
+	char	*polarity = NULL;
+
+	if (__raw_readl(pio + PIO_IMR) & mask) {
+		if (!cpu_has_pio3() || !(__raw_readl(pio + PIO_AIMMR) & mask )) {
+			trigger = "edge";
+			polarity = "both";
+		} else {
+			if (__raw_readl(pio + PIO_ELSR) & mask) {
+				trigger = "level";
+				polarity = __raw_readl(pio + PIO_FRLHSR) & mask ?
+					"high" : "low";
+			} else {
+				trigger = "edge";
+				polarity = __raw_readl(pio + PIO_FRLHSR) & mask ?
+						"rising" : "falling";
+			}
+		}
+		seq_printf(s, "IRQ:%s-%s\t", trigger, polarity);
+	} else {
+		seq_printf(s, "GPIO:%s\t\t",
+				__raw_readl(pio + PIO_PDSR) & mask ? "1" : "0");
+	}
+}
+
 /*--------------------------------------------------------------------------*/
 
 /* Not all hardware capabilities are exposed through these calls; they
@@ -133,7 +186,14 @@
 
 	__raw_writel(mask, pio + PIO_IDR);
 	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
-	__raw_writel(mask, pio + PIO_ASR);
+	if (cpu_has_pio3()) {
+		__raw_writel(__raw_readl(pio + PIO_ABCDSR1) & ~mask,
+							pio + PIO_ABCDSR1);
+		__raw_writel(__raw_readl(pio + PIO_ABCDSR2) & ~mask,
+							pio + PIO_ABCDSR2);
+	} else {
+		__raw_writel(mask, pio + PIO_ASR);
+	}
 	__raw_writel(mask, pio + PIO_PDR);
 	return 0;
 }
@@ -153,7 +213,14 @@
 
 	__raw_writel(mask, pio + PIO_IDR);
 	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
-	__raw_writel(mask, pio + PIO_BSR);
+	if (cpu_has_pio3()) {
+		__raw_writel(__raw_readl(pio + PIO_ABCDSR1) | mask,
+							pio + PIO_ABCDSR1);
+		__raw_writel(__raw_readl(pio + PIO_ABCDSR2) & ~mask,
+							pio + PIO_ABCDSR2);
+	} else {
+		__raw_writel(mask, pio + PIO_BSR);
+	}
 	__raw_writel(mask, pio + PIO_PDR);
 	return 0;
 }
@@ -161,6 +228,48 @@
 
 
 /*
+ * mux the pin to the "C" internal peripheral role.
+ */
+int __init_or_module at91_set_C_periph(unsigned pin, int use_pullup)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio || !cpu_has_pio3())
+		return -EINVAL;
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
+	__raw_writel(__raw_readl(pio + PIO_ABCDSR1) & ~mask, pio + PIO_ABCDSR1);
+	__raw_writel(__raw_readl(pio + PIO_ABCDSR2) | mask, pio + PIO_ABCDSR2);
+	__raw_writel(mask, pio + PIO_PDR);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_C_periph);
+
+
+/*
+ * mux the pin to the "C" internal peripheral role.
+ */
+int __init_or_module at91_set_D_periph(unsigned pin, int use_pullup)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio || !cpu_has_pio3())
+		return -EINVAL;
+
+	__raw_writel(mask, pio + PIO_IDR);
+	__raw_writel(mask, pio + (use_pullup ? PIO_PUER : PIO_PUDR));
+	__raw_writel(__raw_readl(pio + PIO_ABCDSR1) | mask, pio + PIO_ABCDSR1);
+	__raw_writel(__raw_readl(pio + PIO_ABCDSR2) | mask, pio + PIO_ABCDSR2);
+	__raw_writel(mask, pio + PIO_PDR);
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_D_periph);
+
+
+/*
  * mux the pin to the gpio controller (instead of "A" or "B" peripheral), and
  * configure it for an input.
  */
@@ -213,12 +322,37 @@
 
 	if (!pio)
 		return -EINVAL;
+
+	if (cpu_has_pio3() && is_on)
+		__raw_writel(mask, pio + PIO_IFSCDR);
 	__raw_writel(mask, pio + (is_on ? PIO_IFER : PIO_IFDR));
 	return 0;
 }
 EXPORT_SYMBOL(at91_set_deglitch);
 
 /*
+ * enable/disable the debounce filter;
+ */
+int __init_or_module at91_set_debounce(unsigned pin, int is_on, int div)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio || !cpu_has_pio3())
+		return -EINVAL;
+
+	if (is_on) {
+		__raw_writel(mask, pio + PIO_IFSCER);
+		__raw_writel(div & PIO_SCDR_DIV, pio + PIO_SCDR);
+		__raw_writel(mask, pio + PIO_IFER);
+	} else {
+		__raw_writel(mask, pio + PIO_IFDR);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_debounce);
+
+/*
  * enable/disable the multi-driver; This is only valid for output and
  * allows the output pin to run as an open collector output.
  */
@@ -236,6 +370,41 @@
 EXPORT_SYMBOL(at91_set_multi_drive);
 
 /*
+ * enable/disable the pull-down.
+ * If pull-up already enabled while calling the function, we disable it.
+ */
+int __init_or_module at91_set_pulldown(unsigned pin, int is_on)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio || !cpu_has_pio3())
+		return -EINVAL;
+
+	/* Disable pull-up anyway */
+	__raw_writel(mask, pio + PIO_PUDR);
+	__raw_writel(mask, pio + (is_on ? PIO_PPDER : PIO_PPDDR));
+	return 0;
+}
+EXPORT_SYMBOL(at91_set_pulldown);
+
+/*
+ * disable Schmitt trigger
+ */
+int __init_or_module at91_disable_schmitt_trig(unsigned pin)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	if (!pio || !cpu_has_pio3())
+		return -EINVAL;
+
+	__raw_writel(__raw_readl(pio + PIO_SCHMITT) | mask, pio + PIO_SCHMITT);
+	return 0;
+}
+EXPORT_SYMBOL(at91_disable_schmitt_trig);
+
+/*
  * assuming the pin is muxed as a gpio output, set its value.
  */
 int at91_set_gpio_value(unsigned pin, int value)
@@ -337,7 +506,10 @@
  * To use any AT91_PIN_* as an externally triggered IRQ, first call
  * at91_set_gpio_input() then maybe enable its glitch filter.
  * Then just request_irq() with the pin ID; it works like any ARM IRQ
- * handler, though it always triggers on rising and falling edges.
+ * handler.
+ * First implementation always triggers on rising and falling edges
+ * whereas the newer PIO3a can be additionally configured to trigger on
+ * level, edge with any polarity.
  *
  * Alternatively, certain pins may be used directly as IRQ0..IRQ6 after
  * configuring them with at91_set_a_periph() or at91_set_b_periph().
@@ -373,11 +545,50 @@
 	}
 }
 
+/* Alternate irq type for PIO3a support */
+static int alt_gpio_irq_type(unsigned pin, unsigned type)
+{
+	void __iomem	*pio = pin_to_controller(pin);
+	unsigned	mask = pin_to_mask(pin);
+
+	switch (type) {
+	case IRQ_TYPE_EDGE_RISING:
+		__raw_writel(mask, pio + PIO_ESR);
+		__raw_writel(mask, pio + PIO_REHLSR);
+		break;
+	case IRQ_TYPE_EDGE_FALLING:
+		__raw_writel(mask, pio + PIO_ESR);
+		__raw_writel(mask, pio + PIO_FELLSR);
+		break;
+	case IRQ_TYPE_LEVEL_LOW:
+		__raw_writel(mask, pio + PIO_LSR);
+		__raw_writel(mask, pio + PIO_FELLSR);
+		break;
+	case IRQ_TYPE_LEVEL_HIGH:
+		__raw_writel(mask, pio + PIO_LSR);
+		__raw_writel(mask, pio + PIO_REHLSR);
+		break;
+	case IRQ_TYPE_EDGE_BOTH:
+		/* disable additional interrupt modes:
+		 * fall back to default behavior */
+		__raw_writel(mask, pio + PIO_AIMDR);
+		return 0;
+	case IRQ_TYPE_NONE:
+	default:
+		pr_warn("AT91: No type for irq %d\n", gpio_to_irq(pin));
+		return -EINVAL;
+	}
+
+	/* enable additional interrupt modes */
+	__raw_writel(mask, pio + PIO_AIMER);
+
+	return 0;
+}
+
 static struct irq_chip gpio_irqchip = {
 	.name		= "GPIO",
 	.mask		= gpio_irq_mask,
 	.unmask		= gpio_irq_unmask,
-	.set_type	= gpio_irq_type,
 	.set_wake	= gpio_irq_set_wake,
 };
 
@@ -444,7 +655,7 @@
 	/* print heading */
 	seq_printf(s, "Pin\t");
 	for (bank = 0; bank < gpio_banks; bank++) {
-		seq_printf(s, "PIO%c\t", 'A' + bank);
+		seq_printf(s, "PIO%c\t\t", 'A' + bank);
 	};
 	seq_printf(s, "\n\n");
 
@@ -458,11 +669,10 @@
 			unsigned	mask = pin_to_mask(pin);
 
 			if (__raw_readl(pio + PIO_PSR) & mask)
-				seq_printf(s, "GPIO:%s", __raw_readl(pio + PIO_PDSR) & mask ? "1" : "0");
+				gpio_printf(s, pio, mask);
 			else
-				seq_printf(s, "%s", __raw_readl(pio + PIO_ABSR) & mask ? "B" : "A");
-
-			seq_printf(s, "\t");
+				seq_printf(s, "%c\t\t",
+						peripheral_function(pio, mask));
 		}
 
 		seq_printf(s, "\n");
@@ -509,6 +719,11 @@
 	unsigned		pioc, pin;
 	struct at91_gpio_chip	*this, *prev;
 
+	if (cpu_has_pio3())
+		gpio_irqchip.set_type = alt_gpio_irq_type;
+	else
+		gpio_irqchip.set_type = gpio_irq_type;
+
 	for (pioc = 0, pin = PIN_BASE, this = gpio_chip, prev = NULL;
 			pioc++ < gpio_banks;
 			prev = this, this++) {
@@ -605,9 +820,8 @@
 					   at91_get_gpio_value(pin) ?
 					   "set" : "clear");
 			else
-				seq_printf(s, "[periph %s]\n",
-					   __raw_readl(pio + PIO_ABSR) &
-					   mask ? "B" : "A");
+				seq_printf(s, "[periph %c]\n",
+					   peripheral_function(pio, mask));
 		}
 	}
 }
Index: linux-2.6.35/arch/arm/mach-at91/Makefile
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/Makefile	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/Makefile	(revision 150)
@@ -18,6 +18,7 @@
 obj-$(CONFIG_ARCH_AT91SAM9RL)	+= at91sam9rl.o at91sam926x_time.o at91sam9rl_devices.o sam9_smc.o
 obj-$(CONFIG_ARCH_AT91SAM9G20)	+= at91sam9260.o at91sam926x_time.o at91sam9260_devices.o sam9_smc.o
 obj-$(CONFIG_ARCH_AT91SAM9G45)	+= at91sam9g45.o at91sam926x_time.o at91sam9g45_devices.o sam9_smc.o
+obj-$(CONFIG_ARCH_AT91SAM9X5)	+= at91sam9x5.o at91sam926x_time.o at91sam9x5_devices.o sam9_smc.o
 obj-$(CONFIG_ARCH_AT91CAP9)	+= at91cap9.o at91sam926x_time.o at91cap9_devices.o sam9_smc.o
 obj-$(CONFIG_ARCH_AT572D940HF)  += at572d940hf.o at91sam926x_time.o at572d940hf_devices.o sam9_smc.o
 obj-$(CONFIG_ARCH_AT91X40)	+= at91x40.o at91x40_time.o
@@ -69,6 +70,9 @@
 # AT91SAM9G45 board-specific support
 obj-$(CONFIG_MACH_AT91SAM9G45EKES) += board-sam9m10g45ek.o
 
+# AT91SAM9X5 board-specific support
+obj-$(CONFIG_MACH_AT91SAM9X5EK) += board-sam9x5cm.o board-sam9x5ek.o
+
 # AT91CAP9 board-specific support
 obj-$(CONFIG_MACH_AT91CAP9ADK)	+= board-cap9adk.o
 
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91cap9_ddrsdr.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91cap9_ddrsdr.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91cap9_ddrsdr.h	(revision 150)
@@ -15,7 +15,7 @@
 #ifndef AT91CAP9_DDRSDR_H
 #define AT91CAP9_DDRSDR_H
 
-#define AT91_DDRSDRC_MR		(AT91_DDRSDRC + 0x00)	/* Mode Register */
+#define AT91_DDRSDRC_MR		0x00	/* Mode Register */
 #define		AT91_DDRSDRC_MODE	(0xf << 0)		/* Command Mode */
 #define			AT91_DDRSDRC_MODE_NORMAL		0
 #define			AT91_DDRSDRC_MODE_NOP		1
@@ -25,10 +25,10 @@
 #define			AT91_DDRSDRC_MODE_EXT_LMR	5
 #define			AT91_DDRSDRC_MODE_DEEP		6
 
-#define AT91_DDRSDRC_RTR	(AT91_DDRSDRC + 0x04)	/* Refresh Timer Register */
+#define AT91_DDRSDRC_RTR	0x04	/* Refresh Timer Register */
 #define		AT91_DDRSDRC_COUNT	(0xfff << 0)		/* Refresh Timer Counter */
 
-#define AT91_DDRSDRC_CR		(AT91_DDRSDRC + 0x08)	/* Configuration Register */
+#define AT91_DDRSDRC_CR		0x08	/* Configuration Register */
 #define		AT91_DDRSDRC_NC		(3 << 0)		/* Number of Column Bits */
 #define			AT91_DDRSDRC_NC_SDR8	(0 << 0)
 #define			AT91_DDRSDRC_NC_SDR9	(1 << 0)
@@ -49,7 +49,7 @@
 #define		AT91_DDRSDRC_DLL	(1 << 7)		/* Reset DLL */
 #define		AT91_DDRSDRC_DICDS	(1 << 8)		/* Output impedance control */
 
-#define AT91_DDRSDRC_T0PR	(AT91_DDRSDRC + 0x0C)	/* Timing 0 Register */
+#define AT91_DDRSDRC_T0PR	0x0C	/* Timing 0 Register */
 #define		AT91_DDRSDRC_TRAS	(0xf <<  0)		/* Active to Precharge delay */
 #define		AT91_DDRSDRC_TRCD	(0xf <<  4)		/* Row to Column delay */
 #define		AT91_DDRSDRC_TWR	(0xf <<  8)		/* Write recovery delay */
@@ -59,13 +59,13 @@
 #define		AT91_DDRSDRC_TWTR	(1   << 24)		/* Internal Write to Read delay */
 #define		AT91_DDRSDRC_TMRD	(0xf << 28)		/* Load mode to active/refresh delay */
 
-#define AT91_DDRSDRC_T1PR	(AT91_DDRSDRC + 0x10)	/* Timing 1 Register */
+#define AT91_DDRSDRC_T1PR	0x10	/* Timing 1 Register */
 #define		AT91_DDRSDRC_TRFC	(0x1f << 0)		/* Row Cycle Delay */
 #define		AT91_DDRSDRC_TXSNR	(0xff << 8)		/* Exit self-refresh to non-read */
 #define		AT91_DDRSDRC_TXSRD	(0xff << 16)		/* Exit self-refresh to read */
 #define		AT91_DDRSDRC_TXP	(0xf  << 24)		/* Exit power-down delay */
 
-#define AT91_DDRSDRC_LPR	(AT91_DDRSDRC + 0x18)	/* Low Power Register */
+#define AT91_DDRSDRC_LPR	0x18	/* Low Power Register */
 #define		AT91_DDRSDRC_LPCB		(3 << 0)	/* Low-power Configurations */
 #define			AT91_DDRSDRC_LPCB_DISABLE		0
 #define			AT91_DDRSDRC_LPCB_SELF_REFRESH		1
@@ -80,14 +80,14 @@
 #define			AT91_DDRSDRC_TIMEOUT_64_CLK_CYCLES	(1 << 12)
 #define			AT91_DDRSDRC_TIMEOUT_128_CLK_CYCLES	(2 << 12)
 
-#define AT91_DDRSDRC_MDR	(AT91_DDRSDRC + 0x1C)	/* Memory Device Register */
+#define AT91_DDRSDRC_MDR	0x1C	/* Memory Device Register */
 #define		AT91_DDRSDRC_MD		(3 << 0)		/* Memory Device Type */
 #define			AT91_DDRSDRC_MD_SDR		0
 #define			AT91_DDRSDRC_MD_LOW_POWER_SDR	1
 #define			AT91_DDRSDRC_MD_DDR		2
 #define			AT91_DDRSDRC_MD_LOW_POWER_DDR	3
 
-#define AT91_DDRSDRC_DLLR	(AT91_DDRSDRC + 0x20)	/* DLL Information Register */
+#define AT91_DDRSDRC_DLLR	0x20	/* DLL Information Register */
 #define		AT91_DDRSDRC_MDINC	(1 << 0)		/* Master Delay increment */
 #define		AT91_DDRSDRC_MDDEC	(1 << 1)		/* Master Delay decrement */
 #define		AT91_DDRSDRC_MDOVF	(1 << 2)		/* Master Delay Overflow */
@@ -98,5 +98,11 @@
 #define		AT91_DDRSDRC_SDVAL	(0xff << 16)		/* Slave Delay value */
 #define		AT91_DDRSDRC_SDCVAL	(0xff << 24)		/* Slave Delay Correction value */
 
+/* Register access macros */
+#define at91_ramc_read(num, reg) \
+	at91_sys_read(AT91_DDRSDRC##num + reg)
+#define at91_ramc_write(num, reg, value) \
+	at91_sys_write(AT91_DDRSDRC##num + reg, value)
 
+
 #endif
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/hardware.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/hardware.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/hardware.h	(revision 150)
@@ -28,6 +28,8 @@
 #include <mach/at91sam9rl.h>
 #elif defined(CONFIG_ARCH_AT91SAM9G45)
 #include <mach/at91sam9g45.h>
+#elif defined(CONFIG_ARCH_AT91SAM9X5)
+#include <mach/at91sam9x5.h>
 #elif defined(CONFIG_ARCH_AT91CAP9)
 #include <mach/at91cap9.h>
 #elif defined(CONFIG_ARCH_AT91X40)
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/gpio.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/gpio.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/gpio.h	(revision 150)
@@ -15,10 +15,12 @@
 
 #include <linux/kernel.h>
 #include <asm/irq.h>
+#include <linux/init.h>
 
 #define PIN_BASE		NR_AIC_IRQS
 
 #define MAX_GPIO_BANKS		5
+#define ARCH_NR_GPIOS		256
 
 /* these pin numbers double as IRQ numbers, like AT91xxx_ID_* values */
 
@@ -188,14 +190,29 @@
 #define	AT91_PIN_PE31	(PIN_BASE + 0x80 + 31)
 
 #ifndef __ASSEMBLY__
+static inline int gpio_is_valid(int number)
+{
+	if (number >= PIN_BASE &&
+	    number < ARCH_NR_GPIOS)
+		return 1;
+	return 0;
+}
+#define __HAVE_ARCH_GPIO_IS_VALID 1
+
+
 /* setup setup routines, called from board init or driver probe() */
 extern int __init_or_module at91_set_GPIO_periph(unsigned pin, int use_pullup);
 extern int __init_or_module at91_set_A_periph(unsigned pin, int use_pullup);
 extern int __init_or_module at91_set_B_periph(unsigned pin, int use_pullup);
+extern int __init_or_module at91_set_C_periph(unsigned pin, int use_pullup);
+extern int __init_or_module at91_set_D_periph(unsigned pin, int use_pullup);
 extern int __init_or_module at91_set_gpio_input(unsigned pin, int use_pullup);
 extern int __init_or_module at91_set_gpio_output(unsigned pin, int value);
 extern int __init_or_module at91_set_deglitch(unsigned pin, int is_on);
+extern int __init_or_module at91_set_debounce(unsigned pin, int is_on, int div);
 extern int __init_or_module at91_set_multi_drive(unsigned pin, int is_on);
+extern int __init_or_module at91_set_pulldown(unsigned pin, int is_on);
+extern int __init_or_module at91_disable_schmitt_trig(unsigned pin);
 
 /* callable at any time */
 extern int at91_set_gpio_value(unsigned pin, int value);
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9260.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9260.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9260.h	(revision 150)
@@ -84,7 +84,7 @@
  * System Peripherals (offset from AT91_BASE_SYS)
  */
 #define AT91_ECC	(0xffffe800 - AT91_BASE_SYS)
-#define AT91_SDRAMC	(0xffffea00 - AT91_BASE_SYS)
+#define AT91_SDRAMC0	(0xffffea00 - AT91_BASE_SYS)
 #define AT91_SMC	(0xffffec00 - AT91_BASE_SYS)
 #define AT91_MATRIX	(0xffffee00 - AT91_BASE_SYS)
 #define AT91_CCFG	(0xffffef10 - AT91_BASE_SYS)
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9261.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9261.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9261.h	(revision 150)
@@ -68,7 +68,7 @@
 /*
  * System Peripherals (offset from AT91_BASE_SYS)
  */
-#define AT91_SDRAMC	(0xffffea00 - AT91_BASE_SYS)
+#define AT91_SDRAMC0	(0xffffea00 - AT91_BASE_SYS)
 #define AT91_SMC	(0xffffec00 - AT91_BASE_SYS)
 #define AT91_MATRIX	(0xffffee00 - AT91_BASE_SYS)
 #define AT91_AIC	(0xfffff000 - AT91_BASE_SYS)
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9_sdramc.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9_sdramc.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9_sdramc.h	(revision 150)
@@ -17,7 +17,7 @@
 #define AT91SAM9_SDRAMC_H
 
 /* SDRAM Controller (SDRAMC) registers */
-#define AT91_SDRAMC_MR		(AT91_SDRAMC + 0x00)	/* SDRAM Controller Mode Register */
+#define AT91_SDRAMC_MR		0x00	/* SDRAM Controller Mode Register */
 #define		AT91_SDRAMC_MODE	(0xf << 0)		/* Command Mode */
 #define			AT91_SDRAMC_MODE_NORMAL		0
 #define			AT91_SDRAMC_MODE_NOP		1
@@ -27,10 +27,10 @@
 #define			AT91_SDRAMC_MODE_EXT_LMR	5
 #define			AT91_SDRAMC_MODE_DEEP		6
 
-#define AT91_SDRAMC_TR		(AT91_SDRAMC + 0x04)	/* SDRAM Controller Refresh Timer Register */
+#define AT91_SDRAMC_TR		0x04	/* SDRAM Controller Refresh Timer Register */
 #define		AT91_SDRAMC_COUNT	(0xfff << 0)		/* Refresh Timer Counter */
 
-#define AT91_SDRAMC_CR		(AT91_SDRAMC + 0x08)	/* SDRAM Controller Configuration Register */
+#define AT91_SDRAMC_CR		0x08	/* SDRAM Controller Configuration Register */
 #define		AT91_SDRAMC_NC		(3 << 0)		/* Number of Column Bits */
 #define			AT91_SDRAMC_NC_8	(0 << 0)
 #define			AT91_SDRAMC_NC_9	(1 << 0)
@@ -57,7 +57,7 @@
 #define		AT91_SDRAMC_TRAS	(0xf << 24)		/* Active to Precharge Delay */
 #define		AT91_SDRAMC_TXSR	(0xf << 28)		/* Exit Self Refresh to Active Delay */
 
-#define AT91_SDRAMC_LPR		(AT91_SDRAMC + 0x10)	/* SDRAM Controller Low Power Register */
+#define AT91_SDRAMC_LPR		0x10	/* SDRAM Controller Low Power Register */
 #define		AT91_SDRAMC_LPCB		(3 << 0)	/* Low-power Configurations */
 #define			AT91_SDRAMC_LPCB_DISABLE		0
 #define			AT91_SDRAMC_LPCB_SELF_REFRESH		1
@@ -71,16 +71,21 @@
 #define			AT91_SDRAMC_TIMEOUT_64_CLK_CYCLES	(1 << 12)
 #define			AT91_SDRAMC_TIMEOUT_128_CLK_CYCLES	(2 << 12)
 
-#define AT91_SDRAMC_IER		(AT91_SDRAMC + 0x14)	/* SDRAM Controller Interrupt Enable Register */
-#define AT91_SDRAMC_IDR		(AT91_SDRAMC + 0x18)	/* SDRAM Controller Interrupt Disable Register */
-#define AT91_SDRAMC_IMR		(AT91_SDRAMC + 0x1C)	/* SDRAM Controller Interrupt Mask Register */
-#define AT91_SDRAMC_ISR		(AT91_SDRAMC + 0x20)	/* SDRAM Controller Interrupt Status Register */
+#define AT91_SDRAMC_IER		0x14	/* SDRAM Controller Interrupt Enable Register */
+#define AT91_SDRAMC_IDR		0x18	/* SDRAM Controller Interrupt Disable Register */
+#define AT91_SDRAMC_IMR		0x1C	/* SDRAM Controller Interrupt Mask Register */
+#define AT91_SDRAMC_ISR		0x20	/* SDRAM Controller Interrupt Status Register */
 #define		AT91_SDRAMC_RES		(1 << 0)		/* Refresh Error Status */
 
-#define AT91_SDRAMC_MDR		(AT91_SDRAMC + 0x24)	/* SDRAM Memory Device Register */
+#define AT91_SDRAMC_MDR		0x24	/* SDRAM Memory Device Register */
 #define		AT91_SDRAMC_MD		(3 << 0)		/* Memory Device Type */
 #define			AT91_SDRAMC_MD_SDRAM		0
 #define			AT91_SDRAMC_MD_LOW_POWER_SDRAM	1
 
+/* Register access macros */
+#define at91_ramc_read(num, reg) \
+	at91_sys_read(AT91_SDRAMC##num + reg)
+#define at91_ramc_write(num, reg, value) \
+	at91_sys_write(AT91_SDRAMC##num + reg, value)
 
 #endif
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/atmel_hlcdfb.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/atmel_hlcdfb.h	(revision 0)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/atmel_hlcdfb.h	(revision 150)
@@ -0,0 +1,865 @@
+/*
+ *  Header file for AT91 High end LCD Controller
+ *
+ *  Data structure and register user interface
+ *
+ *  Copyright (C) 2010 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PUROFFSETE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ATMEL_HLCD_H__
+#define __ATMEL_HLCD_H__
+
+/* Lcdc hardware registers */
+#define ATMEL_LCDC_LCDCFG0	0x0000
+#define LCDC_LCDCFG0_CLKPOL		(0x1 << 0)
+#define LCDC_LCDCFG0_CLKSEL		(0x1 << 2)
+#define LCDC_LCDCFG0_CLKPWMSEL		(0x1 << 3)
+#define LCDC_LCDCFG0_CGDISBASE		(0x1 << 8)
+#define LCDC_LCDCFG0_CGDISOVR1		(0x1 << 9)
+#define LCDC_LCDCFG0_CGDISHEO		(0x1 << 11)
+#define LCDC_LCDCFG0_CGDISHCR		(0x1 << 12)
+#define LCDC_LCDCFG0_CLKDIV_OFFSET	16
+#define LCDC_LCDCFG0_CLKDIV		(0xff << LCDC_LCDCFG0_CLKDIV_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG1	0x0004
+#define LCDC_LCDCFG1_HSPW_OFFSET	0
+#define LCDC_LCDCFG1_HSPW		(0x3f << LCDC_LCDCFG1_HSPW_OFFSET)
+#define LCDC_LCDCFG1_VSPW_OFFSET	16
+#define LCDC_LCDCFG1_VSPW		(0x3f << LCDC_LCDCFG1_VSPW_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG2	0x0008
+#define LCDC_LCDCFG2_VFPW_OFFSET	0
+#define LCDC_LCDCFG2_VFPW		(0x3f << LCDC_LCDCFG2_VFPW_OFFSET)
+#define LCDC_LCDCFG2_VBPW_OFFSET	16
+#define LCDC_LCDCFG2_VBPW		(0x3f << LCDC_LCDCFG2_VBPW_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG3	0x000C
+#define LCDC_LCDCFG3_HFPW_OFFSET	0
+#define LCDC_LCDCFG3_HFPW		(0xff << LCDC_LCDCFG3_HFPW_OFFSET)
+#define LCDC_LCDCFG3_HBPW_OFFSET	16
+#define LCDC_LCDCFG3_HBPW		(0xff << LCDC_LCDCFG3_HBPW_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG4	0x0010
+#define LCDC_LCDCFG4_PPL_OFFSET		0
+#define LCDC_LCDCFG4_PPL		(0x7ff << LCDC_LCDCFG4_PPL_OFFSET)
+#define LCDC_LCDCFG4_RPF_OFFSET		16
+#define LCDC_LCDCFG4_RPF		(0x7ff << LCDC_LCDCFG4_RPF_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG5	0x0014
+#define LCDC_LCDCFG5_HSPOL		(0x1 << 0)
+#define LCDC_LCDCFG5_VSPOL		(0x1 << 1)
+#define LCDC_LCDCFG5_VSPDLYS		(0x1 << 2)
+#define LCDC_LCDCFG5_VSPDLYE		(0x1 << 3)
+#define LCDC_LCDCFG5_DISPPOL		(0x1 << 4)
+#define LCDC_LCDCFG5_SERIAL		(0x1 << 5)
+#define LCDC_LCDCFG5_DITHER		(0x1 << 6)
+#define LCDC_LCDCFG5_DISPDLY		(0x1 << 7)
+#define LCDC_LCDCFG5_MODE_OFFSET	8
+#define LCDC_LCDCFG5_MODE		(0x3 << LCDC_LCDCFG5_MODE_OFFSET)
+#define		LCDC_LCDCFG5_MODE_OUTPUT_12BPP		(0x0 << 8)
+#define		LCDC_LCDCFG5_MODE_OUTPUT_16BPP		(0x1 << 8)
+#define		LCDC_LCDCFG5_MODE_OUTPUT_18BPP		(0x2 << 8)
+#define		LCDC_LCDCFG5_MODE_OUTPUT_24BPP		(0x3 << 8)
+#define LCDC_LCDCFG5_VSPSU		(0x1 << 12)
+#define LCDC_LCDCFG5_VSPHO		(0x1 << 13)
+#define LCDC_LCDCFG5_GUARDTIME_OFFSET	16
+#define LCDC_LCDCFG5_GUARDTIME		(0x1f << LCDC_LCDCFG5_GUARDTIME_OFFSET)
+
+#define ATMEL_LCDC_LCDCFG6	0x0018
+#define LCDC_LCDCFG6_PWMPS_OFFSET	0
+#define LCDC_LCDCFG6_PWMPS		(0x7 << LCDC_LCDCFG6_PWMPS_OFFSET)
+#define LCDC_LCDCFG6_PWMPOL		(0x1 << 4)
+#define LCDC_LCDCFG6_PWMCVAL_OFFSET	8
+#define LCDC_LCDCFG6_PWMCVAL		(0xff << LCDC_LCDCFG6_PWMCVAL_OFFSET)
+
+#define ATMEL_LCDC_LCDEN	0x0020
+#define LCDC_LCDEN_CLKEN		(0x1 << 0)
+#define LCDC_LCDEN_SYNCEN		(0x1 << 1)
+#define LCDC_LCDEN_DISPEN		(0x1 << 2)
+#define LCDC_LCDEN_PWMEN		(0x1 << 3)
+
+#define ATMEL_LCDC_LCDDIS	0x0024
+#define LCDC_LCDDIS_CLKDIS		(0x1 << 0)
+#define LCDC_LCDDIS_SYNCDIS		(0x1 << 1)
+#define LCDC_LCDDIS_DISPDIS		(0x1 << 2)
+#define LCDC_LCDDIS_PWMDIS		(0x1 << 3)
+#define LCDC_LCDDIS_CLKRST		(0x1 << 8)
+#define LCDC_LCDDIS_SYNCRST		(0x1 << 9)
+#define LCDC_LCDDIS_DISPRST		(0x1 << 10)
+#define LCDC_LCDDIS_PWMRST		(0x1 << 11)
+
+#define ATMEL_LCDC_LCDSR	0x0028
+#define LCDC_LCDSR_CLKSTS		(0x1 << 0)
+#define LCDC_LCDSR_LCDSTS		(0x1 << 1)
+#define LCDC_LCDSR_DISPSTS		(0x1 << 2)
+#define LCDC_LCDSR_PWMSTS		(0x1 << 3)
+#define LCDC_LCDSR_SIPSTS		(0x1 << 4)
+
+#define ATMEL_LCDC_LCDIER	0x002C
+#define LCDC_LCDIER_SOFIE		(0x1 << 0)
+#define LCDC_LCDIER_DISIE		(0x1 << 1)
+#define LCDC_LCDIER_DISPIE		(0x1 << 2)
+#define LCDC_LCDIER_FIFOERRIE		(0x1 << 4)
+#define LCDC_LCDIER_BASEIE		(0x1 << 8)
+#define LCDC_LCDIER_OVR1IE		(0x1 << 9)
+#define LCDC_LCDIER_HEOIE		(0x1 << 11)
+#define LCDC_LCDIER_HCRIE		(0x1 << 12)
+
+#define ATMEL_LCDC_LCDIDR	0x0030
+#define LCDC_LCDIDR_SOFID		(0x1 << 0)
+#define LCDC_LCDIDR_DISID		(0x1 << 1)
+#define LCDC_LCDIDR_DISPID		(0x1 << 2)
+#define LCDC_LCDIDR_FIFOERRID		(0x1 << 4)
+#define LCDC_LCDIDR_BASEID		(0x1 << 8)
+#define LCDC_LCDIDR_OVR1ID		(0x1 << 9)
+#define LCDC_LCDIDR_HEOID		(0x1 << 11)
+#define LCDC_LCDIDR_HCRID		(0x1 << 12)
+
+#define ATMEL_LCDC_LCDIMR	0x0034
+#define LCDC_LCDIMR_SOFIM		(0x1 << 0)
+#define LCDC_LCDIMR_DISIM		(0x1 << 1)
+#define LCDC_LCDIMR_DISPIM		(0x1 << 2)
+#define LCDC_LCDIMR_FIFOERRIM		(0x1 << 4)
+#define LCDC_LCDIMR_BASEIM		(0x1 << 8)
+#define LCDC_LCDIMR_OVR1IM		(0x1 << 9)
+#define LCDC_LCDIMR_HEOIM		(0x1 << 11)
+#define LCDC_LCDIMR_HCRIM		(0x1 << 12)
+
+#define ATMEL_LCDC_LCDISR	0x0038
+#define LCDC_LCDISR_SOF			(0x1 << 0)
+#define LCDC_LCDISR_DIS			(0x1 << 1)
+#define LCDC_LCDISR_DISP		(0x1 << 2)
+#define LCDC_LCDISR_FIFOERR		(0x1 << 4)
+#define LCDC_LCDISR_BASE		(0x1 << 8)
+#define LCDC_LCDISR_OVR1		(0x1 << 9)
+#define LCDC_LCDISR_HEO			(0x1 << 11)
+#define LCDC_LCDISR_HCR			(0x1 << 12)
+
+#define ATMEL_LCDC_BASECHER	0x0040
+#define LCDC_BASECHER_CHEN		(0x1 << 0)
+#define LCDC_BASECHER_UPDATEEN		(0x1 << 1)
+#define LCDC_BASECHER_A2QEN		(0x1 << 2)
+
+#define ATMEL_LCDC_BASECHDR	0x0044
+#define LCDC_BASECHDR_CHDIS		(0x1 << 0)
+#define LCDC_BASECHDR_CHRST		(0x1 << 8)
+
+#define ATMEL_LCDC_BASECHSR	0x0048
+#define LCDC_BASECHSR_CHSR		(0x1 << 0)
+#define LCDC_BASECHSR_UPDATESR		(0x1 << 1)
+#define LCDC_BASECHSR_A2QSR		(0x1 << 2)
+
+#define ATMEL_LCDC_BASEIER	0x004C
+#define LCDC_BASEIER_DMA		(0x1 << 2)
+#define LCDC_BASEIER_DSCR		(0x1 << 3)
+#define LCDC_BASEIER_ADD		(0x1 << 4)
+#define LCDC_BASEIER_DONE		(0x1 << 5)
+#define LCDC_BASEIER_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_BASEIDR	0x0050
+#define LCDC_BASEIDR_DMA		(0x1 << 2)
+#define LCDC_BASEIDR_DSCR		(0x1 << 3)
+#define LCDC_BASEIDR_ADD		(0x1 << 4)
+#define LCDC_BASEIDR_DONE		(0x1 << 5)
+#define LCDC_BASEIDR_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_BASEIMR	0x0054
+#define LCDC_BASEIMR_DMA		(0x1 << 2)
+#define LCDC_BASEIMR_DSCR		(0x1 << 3)
+#define LCDC_BASEIMR_ADD		(0x1 << 4)
+#define LCDC_BASEIMR_DONE		(0x1 << 5)
+#define LCDC_BASEIMR_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_BASEISR	0x0058
+#define LCDC_BASEISR_DMA		(0x1 << 2)
+#define LCDC_BASEISR_DSCR		(0x1 << 3)
+#define LCDC_BASEISR_ADD		(0x1 << 4)
+#define LCDC_BASEISR_DONE		(0x1 << 5)
+#define LCDC_BASEISR_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_BASEHEAD	0x005C
+
+#define ATMEL_LCDC_BASEADDR	0x0060
+
+#define ATMEL_LCDC_BASECTRL	0x0064
+#define LCDC_BASECTRL_DFETCH		(0x1 << 0)
+#define LCDC_BASECTRL_LFETCH		(0x1 << 1)
+#define LCDC_BASECTRL_DMAIEN		(0x1 << 2)
+#define LCDC_BASECTRL_DSCRIEN		(0x1 << 3)
+#define LCDC_BASECTRL_ADDIEN		(0x1 << 4)
+#define LCDC_BASECTRL_DONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_BASENEXT	0x0068
+
+#define ATMEL_LCDC_BASECFG0	0x006C
+#define LCDC_BASECFG0_BLEN_OFFSET 4
+#define LCDC_BASECFG0_BLEN		(0x3 << LCDC_BASECFG0_BLEN_OFFSET)
+#define		LCDC_BASECFG0_BLEN_AHB_SINGLE		(0x0 << 4)
+#define		LCDC_BASECFG0_BLEN_AHB_INCR4		(0x1 << 4)
+#define		LCDC_BASECFG0_BLEN_AHB_INCR8		(0x2 << 4)
+#define		LCDC_BASECFG0_BLEN_AHB_INCR16		(0x3 << 4)
+#define LCDC_BASECFG0_DLBO		(0x1 << 8)
+
+#define ATMEL_LCDC_BASECFG1	0x0070
+#define LCDC_BASECFG1_CLUTEN		(0x1 << 0)
+#define LCDC_BASECFG1_RGBMODE_OFFSET	4
+#define LCDC_BASECFG1_RGBMODE		(0xf << LCDC_BASECFG1_RGBMODE_OFFSET)
+#define		LCDC_BASECFG1_RGBMODE_12BPP_RGB_444	(0x0 << 4)
+#define		LCDC_BASECFG1_RGBMODE_16BPP_ARGB_4444	(0x1 << 4)
+#define		LCDC_BASECFG1_RGBMODE_16BPP_RGBA_4444	(0x2 << 4)
+#define		LCDC_BASECFG1_RGBMODE_16BPP_RGB_565	(0x3 << 4)
+#define		LCDC_BASECFG1_RGBMODE_16BPP_TRGB_1555	(0x4 << 4)
+#define		LCDC_BASECFG1_RGBMODE_18BPP_RGB_666	(0x5 << 4)
+#define		LCDC_BASECFG1_RGBMODE_18BPP_RGB_666_PACKED	(0x6 << 4)
+#define		LCDC_BASECFG1_RGBMODE_19BPP_TRGB_1666	(0x7 << 4)
+#define		LCDC_BASECFG1_RGBMODE_19BPP_TRGB_PACKED	(0x8 << 4)
+#define		LCDC_BASECFG1_RGBMODE_24BPP_RGB_888	(0x9 << 4)
+#define		LCDC_BASECFG1_RGBMODE_24BPP_RGB_888_PACKED	(0xA << 4)
+#define		LCDC_BASECFG1_RGBMODE_25BPP_TRGB_1888	(0xB << 4)
+#define		LCDC_BASECFG1_RGBMODE_32BPP_ARGB_8888	(0xC << 4)
+#define		LCDC_BASECFG1_RGBMODE_32BPP_RGBA_8888	(0xD << 4)
+#define LCDC_BASECFG1_CLUTMODE_OFFSET	8
+#define LCDC_BASECFG1_CLUTMODE		(0x3 << LCDC_BASECFG1_CLUTMODE_OFFSET)
+#define		LCDC_BASECFG1_CLUTMODE_1BPP		(0x0 << 8)
+#define		LCDC_BASECFG1_CLUTMODE_2BPP		(0x1 << 8)
+#define		LCDC_BASECFG1_CLUTMODE_4BPP		(0x2 << 8)
+#define		LCDC_BASECFG1_CLUTMODE_8BPP		(0x3 << 8)
+
+#define ATMEL_LCDC_BASECFG2	0x0074
+
+#define ATMEL_LCDC_BASECFG3	0x0078
+#define LCDC_BASECFG3_BDEF_OFFSET	0
+#define LCDC_BASECFG3_BDEF		(0xff << LCDC_BASECFG3_BDEF_OFFSET)
+#define LCDC_BASECFG3_GDEF_OFFSET	8
+#define LCDC_BASECFG3_GDEF		(0xff << LCDC_BASECFG3_GDEF_OFFSET)
+#define LCDC_BASECFG3_RDEF_OFFSET	16
+#define LCDC_BASECFG3_RDEF		(0xff << LCDC_BASECFG3_RDEF_OFFSET)
+
+#define ATMEL_LCDC_BASECFG4	0x007C
+#define LCDC_BASECFG4_DMA		(0x1 << 8)
+#define LCDC_BASECFG4_REP		(0x1 << 9)
+
+#define ATMEL_LCDC_OVRCHER1	0x0100
+#define LCDC_OVRCHER1_CHEN		(0x1 << 0)
+#define LCDC_OVRCHER1_UPDATEEN		(0x1 << 1)
+#define LCDC_OVRCHER1_A2QEN		(0x1 << 2)
+
+#define ATMEL_LCDC_OVRCHDR1	0x0104
+#define LCDC_OVRCHDR1_CHDIS		(0x1 << 0)
+#define LCDC_OVRCHDR1_CHRST		(0x1 << 8)
+
+#define ATMEL_LCDC_OVRCHSR1	0x0108
+#define LCDC_OVRCHSR1_CHSR		(0x1 << 0)
+#define LCDC_OVRCHSR1_UPDATESR		(0x1 << 1)
+#define LCDC_OVRCHSR1_A2QSR		(0x1 << 2)
+
+#define ATMEL_LCDC_OVRIER1	0x010C
+#define LCDC_OVRIER1_DMA		(0x1 << 2)
+#define LCDC_OVRIER1_DSCR		(0x1 << 3)
+#define LCDC_OVRIER1_ADD		(0x1 << 4)
+#define LCDC_OVRIER1_DONE		(0x1 << 5)
+#define LCDC_OVRIER1_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_OVRIDR1	0x0110
+#define LCDC_OVRIDR1_DMA		(0x1 << 2)
+#define LCDC_OVRIDR1_DSCR		(0x1 << 3)
+#define LCDC_OVRIDR1_ADD		(0x1 << 4)
+#define LCDC_OVRIDR1_DONE		(0x1 << 5)
+#define LCDC_OVRIDR1_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_OVRIMR1	0x0114
+#define LCDC_OVRIMR1_DMA		(0x1 << 2)
+#define LCDC_OVRIMR1_DSCR		(0x1 << 3)
+#define LCDC_OVRIMR1_ADD		(0x1 << 4)
+#define LCDC_OVRIMR1_DONE		(0x1 << 5)
+#define LCDC_OVRIMR1_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_OVRISR1	0x0118
+#define LCDC_OVRISR1_DMA		(0x1 << 2)
+#define LCDC_OVRISR1_DSCR		(0x1 << 3)
+#define LCDC_OVRISR1_ADD		(0x1 << 4)
+#define LCDC_OVRISR1_DONE		(0x1 << 5)
+#define LCDC_OVRISR1_OVR		(0x1 << 6)
+
+#define ATMEL_LCDC_OVRHEAD1	0x011C
+
+#define ATMEL_LCDC_OVRADDR1	0x0120
+
+#define ATMEL_LCDC_OVRCTRL1	0x0124
+#define LCDC_OVRCTRL1_DFETCH		(0x1 << 0)
+#define LCDC_OVRCTRL1_LFETCH		(0x1 << 1)
+#define LCDC_OVRCTRL1_DMAIEN		(0x1 << 2)
+#define LCDC_OVRCTRL1_DSCRIEN		(0x1 << 3)
+#define LCDC_OVRCTRL1_ADDIEN		(0x1 << 4)
+#define LCDC_OVRCTRL1_DONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_OVRNEXT1	0x0128
+
+#define ATMEL_LCDC_OVR1CFG0	0x012C
+#define LCDC_OVR1CFG0_BLEN_OFFSET	4
+#define LCDC_OVR1CFG0_BLEN		(0x3 << LCDC_OVR1CFG0_BLEN_OFFSET)
+#define		LCDC_OVR1CFG0_BLEN_AHB_SINGLE		(0x0 << 4)
+#define		LCDC_OVR1CFG0_BLEN_AHB_INCR4		(0x1 << 4)
+#define		LCDC_OVR1CFG0_BLEN_AHB_INCR8		(0x2 << 4)
+#define		LCDC_OVR1CFG0_BLEN_AHB_INCR16		(0x3 << 4)
+#define LCDC_OVR1CFG0_DLBO		(0x1 << 8)
+#define LCDC_OVR1CFG0_ROTDIS		(0x1 << 12)
+#define LCDC_OVR1CFG0_LOCKDIS		(0x1 << 13)
+
+#define ATMEL_LCDC_OVR1CFG1	0x0130
+#define LCDC_OVR1CFG1_CLUTEN		(0x1 << 0)
+#define LCDC_OVR1CFG1_RGBMODE_OFFSET	4
+#define LCDC_OVR1CFG1_RGBMODE		(0xf << LCDC_OVR1CFG1_RGBMODE_OFFSET)
+#define		LCDC_OVR1CFG1_RGBMODE_12BPP_RGB_444	(0x0 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_16BPP_ARGB_4444	(0x1 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_16BPP_RGBA_4444	(0x2 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_16BPP_RGB_565	(0x3 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_16BPP_TRGB_1555	(0x4 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_18BPP_RGB_666	(0x5 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_18BPP_RGB_666_PACKED	(0x6 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_19BPP_TRGB_1666	(0x7 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_19BPP_TRGB_PACKED	(0x8 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_24BPP_RGB_888	(0x9 << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_24BPP_RGB_888_PACKED	(0xA << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_25BPP_TRGB_1888	(0xB << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_32BPP_ARGB_8888	(0xC << 4)
+#define		LCDC_OVR1CFG1_RGBMODE_32BPP_RGBA_8888	(0xD << 4)
+#define LCDC_OVR1CFG1_CLUTMODE_OFFSET	8
+#define LCDC_OVR1CFG1_CLUTMODE		(0x3 << LCDC_OVR1CFG1_CLUTMODE_OFFSET)
+#define		LCDC_OVR1CFG1_CLUTMODE_1BPP		(0x0 << 8)
+#define		LCDC_OVR1CFG1_CLUTMODE_2BPP		(0x1 << 8)
+#define		LCDC_OVR1CFG1_CLUTMODE_4BPP		(0x2 << 8)
+#define		LCDC_OVR1CFG1_CLUTMODE_8BPP		(0x3 << 8)
+
+#define ATMEL_LCDC_OVR1CFG2	0x0134
+#define LCDC_OVR1CFG2_XOFFSET_OFFSET	0
+#define LCDC_OVR1CFG2_XOFFSET		(0x7ff << LCDC_OVR1CFG2_XOFFSET_OFFSET)
+#define LCDC_OVR1CFG2_YOFFSET_OFFSET	16
+#define LCDC_OVR1CFG2_YOFFSET		(0x7ff << LCDC_OVR1CFG2_YOFFSET_OFFSET)
+
+#define ATMEL_LCDC_OVR1CFG3	0x0138
+#define LCDC_OVR1CFG3_XSIZE_OFFSET	0
+#define LCDC_OVR1CFG3_XSIZE		(0x7ff << LCDC_OVR1CFG3_XSIZE_OFFSET)
+#define LCDC_OVR1CFG3_YSIZE_OFFSET	16
+#define LCDC_OVR1CFG3_YSIZE		(0x7ff << LCDC_OVR1CFG3_YSIZE_OFFSET)
+
+#define ATMEL_LCDC_OVR1CFG4	0x013C
+
+#define ATMEL_LCDC_OVR1CFG5	0x0140
+
+#define ATMEL_LCDC_OVR1CFG6	0x0144
+#define LCDC_OVR1CFG6_BDEF_OFFSET	0
+#define LCDC_OVR1CFG6_BDEF		(0xff << LCDC_OVR1CFG6_BDEF_OFFSET)
+#define LCDC_OVR1CFG6_GDEF_OFFSET	8
+#define LCDC_OVR1CFG6_GDEF		(0xff << LCDC_OVR1CFG6_GDEF_OFFSET)
+#define LCDC_OVR1CFG6_RDEF_OFFSET	16
+#define LCDC_OVR1CFG6_RDEF		(0xff << LCDC_OVR1CFG6_RDEF_OFFSET)
+
+#define ATMEL_LCDC_OVR1CFG7	0x0148
+#define LCDC_OVR1CFG7_BKEY_OFFSET	0
+#define LCDC_OVR1CFG7_BKEY		(0xff << LCDC_OVR1CFG7_BKEY_OFFSET)
+#define LCDC_OVR1CFG7_GKEY_OFFSET	8
+#define LCDC_OVR1CFG7_GKEY		(0xff << LCDC_OVR1CFG7_GKEY_OFFST)
+#define LCDC_OVR1CFG7_RKEY_OFFSET	16
+#define LCDC_OVR1CFG7_RKEY		(0xff << LCDC_OVR1CFG7_RKEY_OFFSET)
+
+#define ATMEL_LCDC_OVR1CFG8	0x014C
+#define LCDC_OVR1CFG8_BMASK_OFFSET	0
+#define LCDC_OVR1CFG8_BMASK		(0xff << LCDC_OVR1CFG8_BMASK_OFFSET)
+#define LCDC_OVR1CFG8_GMASK_OFFSET	8
+#define LCDC_OVR1CFG8_GMASK		(0xff << LCDC_OVR1CFG8_GMASK_OFFSET)
+#define LCDC_OVR1CFG8_RMASK_OFFSET	16
+#define LCDC_OVR1CFG8_RMASK		(0xff << LCDC_OVR1CFG8_RMASK_OFFSET)
+
+#define ATMEL_LCDC_OVR1CFG9	0x0150
+#define LCDC_OVR1CFG9_CRKEY		(0x1 << 0)
+#define LCDC_OVR1CFG9_INV		(0x1 << 1)
+#define LCDC_OVR1CFG9_ITER2BL		(0x1 << 2)
+#define LCDC_OVR1CFG9_ITER		(0x1 << 3)
+#define LCDC_OVR1CFG9_REVALPHA		(0x1 << 4)
+#define LCDC_OVR1CFG9_GAEN		(0x1 << 5)
+#define LCDC_OVR1CFG9_LAEN		(0x1 << 6)
+#define LCDC_OVR1CFG9_OVR		(0x1 << 7)
+#define LCDC_OVR1CFG9_DMA		(0x1 << 8)
+#define LCDC_OVR1CFG9_REP		(0x1 << 9)
+#define LCDC_OVR1CFG9_DSTKEY		(0x1 << 10)
+#define LCDC_OVR1CFG9_GA_OFFSET		16
+#define LCDC_OVR1CFG9_GA		(0xff << LCDC_OVR1CFG9_GA_OFFSET)
+
+#define ATMEL_LCDC_HEOCHER	0x0280
+#define LCDC_HEOCHER_CHEN		(0x1 << 0)
+#define LCDC_HEOCHER_UPDATEEN		(0x1 << 1)
+#define LCDC_HEOCHER_A2QEN		(0x1 << 2)
+
+#define ATMEL_LCDC_HEOCHDR	0x0284
+#define LCDC_HEOCHDR_CHDIS		(0x1 << 0)
+#define LCDC_HEOCHDR_CHRST		(0x1 << 8)
+
+#define ATMEL_LCDC_HEOCHSR	0x0288
+#define LCDC_HEOCHSR_CHSR		(0x1 << 0)
+#define LCDC_HEOCHSR_UPDATESR		(0x1 << 1)
+#define LCDC_HEOCHSR_A2QSR		(0x1 << 2)
+
+#define ATMEL_LCDC_HEOIER	0x028C
+#define LCDC_HEOIER_DMA			(0x1 << 2)
+#define LCDC_HEOIER_DSCR		(0x1 << 3)
+#define LCDC_HEOIER_ADD			(0x1 << 4)
+#define LCDC_HEOIER_DONE		(0x1 << 5)
+#define LCDC_HEOIER_OVR			(0x1 << 6)
+#define LCDC_HEOIER_UDMA		(0x1 << 10)
+#define LCDC_HEOIER_UDSCR		(0x1 << 11)
+#define LCDC_HEOIER_UADD		(0x1 << 12)
+#define LCDC_HEOIER_UDONE		(0x1 << 13)
+#define LCDC_HEOIER_UOVR		(0x1 << 14)
+#define LCDC_HEOIER_VDMA		(0x1 << 18)
+#define LCDC_HEOIER_VDSCR		(0x1 << 19)
+#define LCDC_HEOIER_VADD		(0x1 << 20)
+#define LCDC_HEOIER_VDONE		(0x1 << 21)
+#define LCDC_HEOIER_VOVR		(0x1 << 22)
+
+#define ATMEL_LCDC_HEOIDR	0x0290
+#define LCDC_HEOIDR_DMA			(0x1 << 2)
+#define LCDC_HEOIDR_DSCR		(0x1 << 3)
+#define LCDC_HEOIDR_ADD			(0x1 << 4)
+#define LCDC_HEOIDR_DONE		(0x1 << 5)
+#define LCDC_HEOIDR_OVR			(0x1 << 6)
+#define LCDC_HEOIDR_UDMA		(0x1 << 10)
+#define LCDC_HEOIDR_UDSCR		(0x1 << 11)
+#define LCDC_HEOIDR_UADD		(0x1 << 12)
+#define LCDC_HEOIDR_UDONE		(0x1 << 13)
+#define LCDC_HEOIDR_UOVR		(0x1 << 14)
+#define LCDC_HEOIDR_VDMA		(0x1 << 18)
+#define LCDC_HEOIDR_VDSCR		(0x1 << 19)
+#define LCDC_HEOIDR_VADD		(0x1 << 20)
+#define LCDC_HEOIDR_VDONE		(0x1 << 21)
+#define LCDC_HEOIDR_VOVR		(0x1 << 22)
+
+#define ATMEL_LCDC_HEOIMR	0x0294
+#define LCDC_HEOIMR_DMA			(0x1 << 2)
+#define LCDC_HEOIMR_DSCR		(0x1 << 3)
+#define LCDC_HEOIMR_ADD			(0x1 << 4)
+#define LCDC_HEOIMR_DONE		(0x1 << 5)
+#define LCDC_HEOIMR_OVR			(0x1 << 6)
+#define LCDC_HEOIMR_UDMA		(0x1 << 10)
+#define LCDC_HEOIMR_UDSCR		(0x1 << 11)
+#define LCDC_HEOIMR_UADD		(0x1 << 12)
+#define LCDC_HEOIMR_UDONE		(0x1 << 13)
+#define LCDC_HEOIMR_UOVR		(0x1 << 14)
+#define LCDC_HEOIMR_VDMA		(0x1 << 18)
+#define LCDC_HEOIMR_VDSCR		(0x1 << 19)
+#define LCDC_HEOIMR_VADD		(0x1 << 20)
+#define LCDC_HEOIMR_VDONE		(0x1 << 21)
+#define LCDC_HEOIMR_VOVR		(0x1 << 22)
+
+#define ATMEL_LCDC_HEOISR	0x0298
+#define LCDC_HEOISR_DMA			(0x1 << 2)
+#define LCDC_HEOISR_DSCR		(0x1 << 3)
+#define LCDC_HEOISR_ADD			(0x1 << 4)
+#define LCDC_HEOISR_DONE		(0x1 << 5)
+#define LCDC_HEOISR_OVR			(0x1 << 6)
+#define LCDC_HEOISR_UDMA		(0x1 << 10)
+#define LCDC_HEOISR_UDSCR		(0x1 << 11)
+#define LCDC_HEOISR_UADD		(0x1 << 12)
+#define LCDC_HEOISR_UDONE		(0x1 << 13)
+#define LCDC_HEOISR_UOVR		(0x1 << 14)
+#define LCDC_HEOISR_VDMA		(0x1 << 18)
+#define LCDC_HEOISR_VDSCR		(0x1 << 19)
+#define LCDC_HEOISR_VADD		(0x1 << 20)
+#define LCDC_HEOISR_VDONE		(0x1 << 21)
+#define LCDC_HEOISR_VOVR		(0x1 << 22)
+
+#define ATMEL_LCDC_HEOHEAD	0x029C
+
+#define ATMEL_LCDC_HEOADDR	0x02A0
+
+#define ATMEL_LCDC_HEOCTRL	0x02A4
+#define LCDC_HEOCTRL_DFETCH		(0x1 << 0)
+#define LCDC_HEOCTRL_LFETCH		(0x1 << 1)
+#define LCDC_HEOCTRL_DMAIEN		(0x1 << 2)
+#define LCDC_HEOCTRL_DSCRIEN		(0x1 << 3)
+#define LCDC_HEOCTRL_ADDIEN		(0x1 << 4)
+#define LCDC_HEOCTRL_DONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_HEONEXT	0x02A8
+
+#define ATMEL_LCDC_HEOUHEAD	0x02AC
+
+#define ATMEL_LCDC_HEOUADDR	0x02B0
+
+#define ATMEL_LCDC_HEOUCTRL	0x02B4
+#define LCDC_HEOUCTRL_UDFETCH		(0x1 << 0)
+#define LCDC_HEOUCTRL_UDMAIEN		(0x1 << 2)
+#define LCDC_HEOUCTRL_UDSCRIEN		(0x1 << 3)
+#define LCDC_HEOUCTRL_UADDIEN		(0x1 << 4)
+#define LCDC_HEOUCTRL_UDONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_HEOUNEXT	0x02B8
+
+#define ATMEL_LCDC_HEOVHEAD	0x02BC
+
+#define ATMEL_LCDC_HEOVADDR	0x02C0
+
+#define ATMEL_LCDC_HEOVCTRL	0x02C4
+#define LCDC_HEOVCTRL_VDFETCH		(0x1 << 0)
+#define LCDC_HEOVCTRL_VDMAIEN		(0x1 << 2)
+#define LCDC_HEOVCTRL_VDSCRIEN		(0x1 << 3)
+#define LCDC_HEOVCTRL_VADDIEN		(0x1 << 4)
+#define LCDC_HEOVCTRL_VDONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_HEOVNEXT	0x02C8
+
+#define ATMEL_LCDC_HEOCFG0	0x02CC
+#define LCDC_HEOCFG0_BLEN_OFFSET	4
+#define LCDC_HEOCFG0_BLEN		(0x3 << LCDC_HEOCFG0_BLEN_OFFSET)
+#define		LCDC_HEOCFG0_BLEN_AHB_SINGLE		(0x0 << 4)
+#define		LCDC_HEOCFG0_BLEN_AHB_INCR4		(0x1 << 4)
+#define		LCDC_HEOCFG0_BLEN_AHB_INCR8		(0x2 << 4)
+#define		LCDC_HEOCFG0_BLEN_AHB_INCR16		(0x3 << 4)
+#define LCDC_HEOCFG0_BLENUV_OFFSET	6
+#define LCDC_HEOCFG0_BLENUV		(0x3 << LCDC_HEOCFG0_BLENUV_OFFSET)
+#define		LCDC_HEOCFG0_BLENUV_AHB_SINGLE		(0x0 << 6)
+#define		LCDC_HEOCFG0_BLENUV_AHB_INCR4		(0x1 << 6)
+#define		LCDC_HEOCFG0_BLENUV_AHB_INCR8		(0x2 << 6)
+#define		LCDC_HEOCFG0_BLENUV_AHB_INCR16		(0x3 << 6)
+#define LCDC_HEOCFG0_DLBO		(0x1 << 8)
+#define LCDC_HEOCFG0_ROTDIS		(0x1 << 12)
+#define LCDC_HEOCFG0_LOCKDIS		(0x1 << 13)
+
+#define ATMEL_LCDC_HEOCFG1	0x02D0
+#define LCDC_HEOCFG1_CLUTEN		(0x1 << 0)
+#define LCDC_HEOCFG1_YUVEN		(0x1 << 1)
+#define LCDC_HEOCFG1_RGBMODE_OFFSET	4
+#define LCDC_HEOCFG1_RGBMODE		(0xf << LCDC_HEOCFG1_RGBMODE_OFFSET)
+#define		LCDC_HEOCFG1_RGBMODE_12BPP_RGB_444	(0x0 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_16BPP_ARGB_4444	(0x1 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_16BPP_RGBA_4444	(0x2 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_16BPP_RGB_565	(0x3 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_16BPP_TRGB_1555	(0x4 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_18BPP_RGB_666	(0x5 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_18BPP_RGB_666_PACKED	(0x6 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_19BPP_TRGB_1666	(0x7 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_19BPP_TRGB_PACKED	(0x8 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888	(0x9 << 4)
+#define		LCDC_HEOCFG1_RGBMODE_24BPP_RGB_888_PACKED	(0xA << 4)
+#define		LCDC_HEOCFG1_RGBMODE_25BPP_TRGB_1888	(0xB << 4)
+#define		LCDC_HEOCFG1_RGBMODE_32BPP_ARGB_8888	(0xC << 4)
+#define		LCDC_HEOCFG1_RGBMODE_32BPP_RGBA_8888	(0xD << 4)
+#define LCDC_HEOCFG1_CLUTMODE_OFFSET	8
+#define LCDC_HEOCFG1_CLUTMODE		(0x3 << LCDC_HEOCFG1_CLUTMODE_OFFSET)
+#define		LCDC_HEOCFG1_CLUTMODE_1BPP		(0x0 << 8)
+#define		LCDC_HEOCFG1_CLUTMODE_2BPP		(0x1 << 8)
+#define		LCDC_HEOCFG1_CLUTMODE_4BPP		(0x2 << 8)
+#define		LCDC_HEOCFG1_CLUTMODE_8BPP		(0x3 << 8)
+#define LCDC_HEOCFG1_YUVMODE_OFFSET	12
+#define LCDC_HEOCFG1_YUVMODE		(0xf << LCDC_HEOCFG1_YUVMODE_OFFSET)
+#define		LCDC_HEOCFG1_YUVMODE_32BPP_AYCBCR	(0x0 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE0	(0x1 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE1	(0x2 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE2	(0x3 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_MODE3	(0x4 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_SEMIPLANAR	(0x5 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_16BPP_YCBCR_PLANAR	(0x6 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_12BPP_YCBCR_SEMIPLANAR	(0x7 << 12)
+#define		LCDC_HEOCFG1_YUVMODE_12BPP_YCBCR_PLANAR	(0x8 << 12)
+#define LCDC_HEOCFG1_YUV422ROT		(0x1 << 16)
+#define LCDC_HEOCFG1_YUV422SWP		(0x1 << 17)
+
+#define ATMEL_LCDC_HEOCFG2	0x02D4
+#define LCDC_HEOCFG2_XOFFSET_OFFSET	0
+#define LCDC_HEOCFG2_XOFFSET		(0x7ff << LCDC_HEOCFG2_XOFFSET_OFFSET)
+#define LCDC_HEOCFG2_YOFFSET_OFFSET	16
+#define LCDC_HEOCFG2_YOFFSET		(0x7ff << LCDC_HEOCFG2_YOFFSET_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG3	0x02D8
+#define LCDC_HEOCFG3_XSIZE_OFFSET	0
+#define LCDC_HEOCFG3_XSIZE		(0x7ff << LCDC_HEOCFG3_XSIZE_OFFSET)
+#define LCDC_HEOCFG3_YSIZE_OFFSET	16
+#define LCDC_HEOCFG3_YSIZE		(0x7ff << LCDC_HEOCFG3_YSIZE_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG4	0x02DC
+#define LCDC_HEOCFG4_XMEM_SIZE_OFFSET	0
+#define LCDC_HEOCFG4_XMEM_SIZE		(0x7ff << LCDC_HEOCFG4_XMEM_SIZE_OFFSET)
+#define LCDC_HEOCFG4_YMEM_SIZE_OFFSET	16
+#define LCDC_HEOCFG4_YMEM_SIZE		(0x7ff << LCDC_HEOCFG4_YMEM_SIZE_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG5	0x02E0
+
+#define ATMEL_LCDC_HEOCFG6	0x02E4
+
+#define ATMEL_LCDC_HEOCFG7	0x02E8
+
+#define ATMEL_LCDC_HEOCFG8	0x02EC
+
+#define ATMEL_LCDC_HEOCFG9	0x02F0
+#define LCDC_HEOCFG9_BDEF_OFFSET	0
+#define LCDC_HEOCFG9_BDEF		(0xff << LCDC_HEOCFG9_BDEF_OFFSET)
+#define LCDC_HEOCFG9_GDEF_OFFSET	8
+#define LCDC_HEOCFG9_GDEF		(0xff << LCDC_HEOCFG9_GDEF_OFFSET)
+#define LCDC_HEOCFG9_RDEF_OFFSET	16
+#define LCDC_HEOCFG9_RDEF		(0xff << LCDC_HEOCFG9_RDEF_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG10	0x02F4
+#define LCDC_HEOCFG10_BKEY_OFFSET	0
+#define LCDC_HEOCFG10_BKEY		(0xff << LCDC_HEOCFG10_BKEY_OFFSET)
+#define LCDC_HEOCFG10_GKEY_OFFSET	8
+#define LCDC_HEOCFG10_GKEY		(0xff << LCDC_HEOCFG10_GKEY_OFFSET)
+#define LCDC_HEOCFG10_RKEY_OFFSET	16
+#define LCDC_HEOCFG10_RKEY		(0xff << LCDC_HEOCFG10_RKEY_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG11	0x02F8
+#define LCDC_HEOCFG11_BMASK_OFFSET	0
+#define LCDC_HEOCFG11_BMASK		(0xff << LCDC_HEOCFG11_BMASK_OFFSET)
+#define LCDC_HEOCFG11_GMASK_OFFSET	8
+#define LCDC_HEOCFG11_GMASK		(0xff << LCDC_HEOCFG11_GMASK_OFFSET)
+#define LCDC_HEOCFG11_RMASK_OFFSET	16
+#define LCDC_HEOCFG11_RMASK		(0xff << LCDC_HEOCFG11_RMASK_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG12	0x02FC
+#define LCDC_HEOCFG12_CRKEY		(0x1 << 0)
+#define LCDC_HEOCFG12_INV		(0x1 << 1)
+#define LCDC_HEOCFG12_ITER2BL		(0x1 << 2)
+#define LCDC_HEOCFG12_ITER		(0x1 << 3)
+#define LCDC_HEOCFG12_REVALPHA		(0x1 << 4)
+#define LCDC_HEOCFG12_GAEN		(0x1 << 5)
+#define LCDC_HEOCFG12_LAEN		(0x1 << 6)
+#define LCDC_HEOCFG12_OVR		(0x1 << 7)
+#define LCDC_HEOCFG12_DMA		(0x1 << 8)
+#define LCDC_HEOCFG12_REP		(0x1 << 9)
+#define LCDC_HEOCFG12_DSTKEY		(0x1 << 10)
+#define LCDC_HEOCFG12_VIDPRI		(0x1 << 12)
+#define LCDC_HEOCFG12_GA_OFFSET		16
+#define LCDC_HEOCFG12_GA		(0xff << LCDC_HEOCFG12_GA_OFFSET)
+
+#define ATMEL_LCDC_HEOCFG13	0x0300
+#define LCDC_HEOCFG13_XFACTOR_OFFSET	0
+#define LCDC_HEOCFG13_XFACTOR		(0x1fff << LCDC_HEOCFG13_XFACTOR_OFFSET)
+#define LCDC_HEOCFG13_YFACTOR_OFFSET	16
+#define LCDC_HEOCFG13_YFACTOR		(0x1fff << LCDC_HEOCFG13_YFACTOR_OFFSET)
+#define LCDC_HEOCFG13_SCALEN		(0x1 << 31)
+
+#define ATMEL_LCDC_HEOCFG14	0x0304
+#define LCDC_HEOCFG14_CSCRY_OFFSET	0
+#define LCDC_HEOCFG14_CSCRY		(0x3ff << LCDC_HEOCFG14_CSCRY_OFFSET)
+#define LCDC_HEOCFG14_CSCRU_OFFSET	10
+#define LCDC_HEOCFG14_CSCRU		(0x3ff << LCDC_HEOCFG14_CSCRU_OFFSET)
+#define LCDC_HEOCFG14_CSCRV_OFFSET	20
+#define LCDC_HEOCFG14_CSCRV		(0x3ff << LCDC_HEOCFG14_CSCRV_OFFSET)
+#define LCDC_HEOCFG14_CSCYOFF		(0x1 << 30)
+
+#define ATMEL_LCDC_HEOCFG15	0x0308
+#define LCDC_HEOCFG15_CSCGY_OFFSET	0
+#define LCDC_HEOCFG15_CSCGY		(0x3ff << LCDC_HEOCFG15_CSCGY_OFFSET)
+#define LCDC_HEOCFG15_CSCGU_OFFSET	10
+#define LCDC_HEOCFG15_CSCGU		(0x3ff << LCDC_HEOCFG15_CSCGU_OFFSET)
+#define LCDC_HEOCFG15_CSCGV_OFFSET	20
+#define LCDC_HEOCFG15_CSCGV		(0x3ff << LCDC_HEOCFG15_CSCGV_OFFSET)
+#define LCDC_HEOCFG15_CSCUOFF		(0x1 << 30)
+
+#define ATMEL_LCDC_HEOCFG16	0x030C
+#define LCDC_HEOCFG16_CSCBY_OFFSET	0
+#define LCDC_HEOCFG16_CSCBY		(0x3ff << LCDC_HEOCFG16_CSCBY_OFFSET)
+#define LCDC_HEOCFG16_CSCBU_OFFSET	10
+#define LCDC_HEOCFG16_CSCBU		(0x3ff << LCDC_HEOCFG16_CSCBU_OFFSET)
+#define LCDC_HEOCFG16_CSCBV_OFFSET	20
+#define LCDC_HEOCFG16_CSCBV		(0x3ff << LCDC_HEOCFG16_CSCBV_OFFSET)
+#define LCDC_HEOCFG16_CSCVOFF		(0x1 << 30)
+
+#define ATMEL_LCDC_HCRCHER	0x0340
+#define LCDC_HCRCHER_CHEN		(0x1 << 0)
+#define LCDC_HCRCHER_UPDATEEN		(0x1 << 1)
+#define LCDC_HCRCHER_A2QEN		(0x1 << 2)
+
+#define ATMEL_LCDC_HCRCHDR	0x0344
+#define LCDC_HCRCHDR_CHDIS		(0x1 << 0)
+#define LCDC_HCRCHDR_CHRST		(0x1 << 8)
+
+#define ATMEL_LCDC_HCRCHSR	0x0348
+#define LCDC_HCRCHSR_CHSR		(0x1 << 0)
+#define LCDC_HCRCHSR_UPDATESR		(0x1 << 1)
+#define LCDC_HCRCHSR_A2QSR		(0x1 << 2)
+
+#define ATMEL_LCDC_HCRIER	0x034C
+#define LCDC_HCRIER_DMA			(0x1 << 2)
+#define LCDC_HCRIER_DSCR		(0x1 << 3)
+#define LCDC_HCRIER_ADD			(0x1 << 4)
+#define LCDC_HCRIER_DONE		(0x1 << 5)
+#define LCDC_HCRIER_OVR			(0x1 << 6)
+
+#define ATMEL_LCDC_HCRIDR	0x0350
+#define LCDC_HCRIDR_DMA			(0x1 << 2)
+#define LCDC_HCRIDR_DSCR		(0x1 << 3)
+#define LCDC_HCRIDR_ADD			(0x1 << 4)
+#define LCDC_HCRIDR_DONE		(0x1 << 5)
+#define LCDC_HCRIDR_OVR			(0x1 << 6)
+
+#define ATMEL_LCDC_HCRIMR	0x0354
+#define LCDC_HCRIMR_DMA			(0x1 << 2)
+#define LCDC_HCRIMR_DSCR		(0x1 << 3)
+#define LCDC_HCRIMR_ADD			(0x1 << 4)
+#define LCDC_HCRIMR_DONE		(0x1 << 5)
+#define LCDC_HCRIMR_OVR			(0x1 << 6)
+
+#define ATMEL_LCDC_HCRISR	0x0358
+#define LCDC_HCRISR_DMA			(0x1 << 2)
+#define LCDC_HCRISR_DSCR		(0x1 << 3)
+#define LCDC_HCRISR_ADD			(0x1 << 4)
+#define LCDC_HCRISR_DONE		(0x1 << 5)
+#define LCDC_HCRISR_OVR			(0x1 << 6)
+
+#define ATMEL_LCDC_HCRHEAD	0x035C
+
+#define ATMEL_LCDC_HCRADDR	0x0360
+
+#define ATMEL_LCDC_HCRCTRL	0x0364
+#define LCDC_HCRCTRL_DFETCH		(0x1 << 0)
+#define LCDC_HCRCTRL_LFETCH		(0x1 << 1)
+#define LCDC_HCRCTRL_DMAIEN		(0x1 << 2)
+#define LCDC_HCRCTRL_DSCRIEN		(0x1 << 3)
+#define LCDC_HCRCTRL_ADDIEN		(0x1 << 4)
+#define LCDC_HCRCTRL_DONEIEN		(0x1 << 5)
+
+#define ATMEL_LCDC_HCRNEXT	0x0368
+
+#define ATMEL_LCDC_HCRCFG0	0x036C
+#define LCDC_HCRCFG0_BLEN_OFFSET	4
+#define LCDC_HCRCFG0_BLEN		(0x3 << LCDC_HCRCFG0_BLEN_OFFSET)
+#define		LCDC_HCRCFG0_BLEN_AHB_SINGLE		(0x0 << 4)
+#define		LCDC_HCRCFG0_BLEN_AHB_INCR4		(0x1 << 4)
+#define		LCDC_HCRCFG0_BLEN_AHB_INCR8		(0x2 << 4)
+#define		LCDC_HCRCFG0_BLEN_AHB_INCR16		(0x3 << 4)
+#define LCDC_HCRCFG0_DLBO		(0x1 << 8)
+
+#define ATMEL_LCDC_HCRCFG1	0x0370
+#define LCDC_HCRCFG1_CLUTEN		(0x1 << 0)
+#define LCDC_HCRCFG1_RGBMODE_OFFSET	4
+#define LCDC_HCRCFG1_RGBMODE		(0xf << LCDC_HCRCFG1_RGBMODE_OFFSET)
+#define		LCDC_HCRCFG1_RGBMODE_12BPP_RGB_444	(0x0 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_16BPP_ARGB_4444	(0x1 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_16BPP_RGBA_4444	(0x2 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_16BPP_RGB_565	(0x3 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_16BPP_TRGB_1555	(0x4 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_18BPP_RGB_666	(0x5 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_18BPP_RGB_666_PACKED	(0x6 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_19BPP_TRGB_1666	(0x7 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_19BPP_TRGB_PACKED	(0x8 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_24BPP_RGB_888	(0x9 << 4)
+#define		LCDC_HCRCFG1_RGBMODE_24BPP_RGB_888_PACKED	(0xA << 4)
+#define		LCDC_HCRCFG1_RGBMODE_25BPP_TRGB_1888	(0xB << 4)
+#define		LCDC_HCRCFG1_RGBMODE_32BPP_ARGB_8888	(0xC << 4)
+#define		LCDC_HCRCFG1_RGBMODE_32BPP_RGBA_8888	(0xD << 4)
+#define LCDC_HCRCFG1_CLUTMODE_OFFSET	8
+#define LCDC_HCRCFG1_CLUTMODE		(0x3 << LCDC_HCRCFG1_CLUTMODE_OFFSET)
+#define		LCDC_HCRCFG1_CLUTMODE_1BPP		(0x0 << 8)
+#define		LCDC_HCRCFG1_CLUTMODE_2BPP		(0x1 << 8)
+#define		LCDC_HCRCFG1_CLUTMODE_4BPP		(0x2 << 8)
+#define		LCDC_HCRCFG1_CLUTMODE_8BPP		(0x3 << 8)
+
+#define ATMEL_LCDC_HCRCFG2	0x0374
+#define LCDC_HCRCFG2_XOFFSET_OFFSET	0
+#define LCDC_HCRCFG2_XOFFSET		(0x7ff << LCDC_HCRCFG2_XOFFSET_OFFSET)
+#define LCDC_HCRCFG2_YOFFSET_OFFSET	16
+#define LCDC_HCRCFG2_YOFFSET		(0x7ff << LCDC_HCRCFG2_YOFFSET_OFFSET)
+
+#define ATMEL_LCDC_HCRCFG3	0x0378
+#define LCDC_HCRCFG3_XSIZE_OFFSET	0
+#define LCDC_HCRCFG3_XSIZE		(0x7f << LCDC_HCRCFG3_XSIZE_OFFSET)
+#define LCDC_HCRCFG3_YSIZE_OFFSET	16
+#define LCDC_HCRCFG3_YSIZE		(0x7f << LCDC_HCRCFG3_YSIZE_OFFSET)
+
+#define ATMEL_LCDC_HCRCFG4	0x037C
+
+#define ATMEL_LCDC_HCRCFG6	0x0384
+#define LCDC_HCRCFG6_BDEF_OFFSET	0
+#define LCDC_HCRCFG6_BDEF		(0xff << LCDC_HCRCFG6_BDEF_OFFSET)
+#define LCDC_HCRCFG6_GDEF_OFFSET	8
+#define LCDC_HCRCFG6_GDEF		(0xff << LCDC_HCRCFG6_GDEF_OFFSET)
+#define LCDC_HCRCFG6_RDEF_OFFSET	16
+#define LCDC_HCRCFG6_RDEF		(0xff << LCDC_HCRCFG6_RDEF_OFFSET)
+
+#define ATMEL_LCDC_HCRCFG7	0x0388
+#define LCDC_HCRCFG7_BKEY_OFFSET	0
+#define LCDC_HCRCFG7_BKEY		(0xff << LCDC_HCRCFG7_BKEY_OFFSET)
+#define LCDC_HCRCFG7_GKEY_OFFSET	8
+#define LCDC_HCRCFG7_GKEY		(0xff << LCDC_HCRCFG7_GKEY_OFFSET)
+#define LCDC_HCRCFG7_RKEY_OFFSET	16
+#define LCDC_HCRCFG7_RKEY		(0xff << LCDC_HCRCFG7_RKEY_OFFSET)
+
+#define ATMEL_LCDC_HCRCFG8	0x038C
+#define LCDC_HCRCFG8_BMASK_OFFSET	0
+#define LCDC_HCRCFG8_BMASK		(0xff << LCDC_HCRCFG8_BMASK_OFFSET)
+#define LCDC_HCRCFG8_GMASK_OFFSET	8
+#define LCDC_HCRCFG8_GMASK		(0xff << LCDC_HCRCFG8_GMASK_OFFSET)
+#define LCDC_HCRCFG8_RMASK_OFFSET	16
+#define LCDC_HCRCFG8_RMASK		(0xff << LCDC_HCRCFG8_RMASK_OFFSET)
+
+#define ATMEL_LCDC_HCRCFG9	0x0390
+#define LCDC_HCRCFG9_CRKEY		(0x1 << 0)
+#define LCDC_HCRCFG9_INV		(0x1 << 1)
+#define LCDC_HCRCFG9_ITER2BL		(0x1 << 2)
+#define LCDC_HCRCFG9_ITER		(0x1 << 3)
+#define LCDC_HCRCFG9_REVALPHA		(0x1 << 4)
+#define LCDC_HCRCFG9_GAEN		(0x1 << 5)
+#define LCDC_HCRCFG9_LAEN		(0x1 << 6)
+#define LCDC_HCRCFG9_OVR		(0x1 << 7)
+#define LCDC_HCRCFG9_DMA		(0x1 << 8)
+#define LCDC_HCRCFG9_REP		(0x1 << 9)
+#define LCDC_HCRCFG9_DSTKEY		(0x1 << 10)
+#define LCDC_HCRCFG9_GA_OFFSET		16
+#define LCDC_HCRCFG9_GA_Msk		(0xff << LCDC_HCRCFG9_GA_OFFSET)
+
+#define ATMEL_LCDC_BASECLUT	0x400
+#define LCDC_BASECLUT_BCLUT_OFFSET	0
+#define LCDC_BASECLUT_BCLUT		(0xff << LCDC_BASECLUT_BCLUT_OFFSET)
+#define LCDC_BASECLUT_GCLUT_OFFSET	8
+#define LCDC_BASECLUT_GCLUT		(0xff << LCDC_BASECLUT_GCLUT_OFFSET)
+#define LCDC_BASECLUT_RCLUT_OFFSET	16
+#define LCDC_BASECLUT_RCLUT		(0xff << LCDC_BASECLUT_RCLUT_OFFSET)
+
+#define ATMEL_LCDC_OVR1CLUT	0x800
+#define LCDC_OVR1CLUT_BCLUT_OFFSET	0
+#define LCDC_OVR1CLUT_BCLUT		(0xff << LCDC_OVR1CLUT_BCLUT_OFFSET)
+#define LCDC_OVR1CLUT_GCLUT_OFFSET	8
+#define LCDC_OVR1CLUT_GCLUT		(0xff << LCDC_OVR1CLUT_GCLUT_OFFSET)
+#define LCDC_OVR1CLUT_RCLUT_OFFSET	16
+#define LCDC_OVR1CLUT_RCLUT		(0xff << LCDC_OVR1CLUT_RCLUT_OFFSET)
+#define LCDC_OVR1CLUT_ACLUT_OFFSET	24
+#define LCDC_OVR1CLUT_ACLUT		(0xff << LCDC_OVR1CLUT_ACLUT_OFFSET)
+
+#define ATMEL_LCDC_HEOCLUT	0x1000
+#define LCDC_HEOCLUT_BCLUT_OFFSET	0
+#define LCDC_HEOCLUT_BCLUT		(0xff << LCDC_HEOCLUT_BCLUT_OFFSET)
+#define LCDC_HEOCLUT_GCLUT_OFFSET	8
+#define LCDC_HEOCLUT_GCLUT		(0xff << LCDC_HEOCLUT_GCLUT_OFFSET)
+#define LCDC_HEOCLUT_RCLUT_OFFSET	16
+#define LCDC_HEOCLUT_RCLUT		(0xff << LCDC_HEOCLUT_RCLUT_OFFSET)
+#define LCDC_HEOCLUT_ACLUT_OFFSET	24
+#define LCDC_HEOCLUT_ACLUT		(0xff << LCDC_HEOCLUT_ACLUT_OFFSET)
+
+#define ATMEL_LCDC_HCRCLUT	0x1400
+#define LCDC_HCRCLUT_BCLUT_OFFSET	0
+#define LCDC_HCRCLUT_BCLUT		(0xff << LCDC_HCRCLUT_BCLUT_OFFSET)
+#define LCDC_HCRCLUT_GCLUT_OFFSET	8
+#define LCDC_HCRCLUT_GCLUT		(0xff << LCDC_HCRCLUT_GCLUT_OFFSET)
+#define LCDC_HCRCLUT_RCLUT_OFFSET	16
+#define LCDC_HCRCLUT_RCLUT		(0xff << LCDC_HCRCLUT_RCLUT_OFFSET)
+#define LCDC_HCRCLUT_ACLUT_OFFSET	24
+#define LCDC_HCRCLUT_ACLUT		(0xff << LCDC_HCRCLUT_ACLUT_OFFSET)
+
+/* Base layer CLUT */
+#define ATMEL_LCDC_LUT(n)	(0x0400 + ((n)*4))
+
+
+#endif /* __ATMEL_HLCDC4_H__ */
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9x5_rtc_workaround.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9x5_rtc_workaround.h	(revision 0)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9x5_rtc_workaround.h	(revision 150)
@@ -0,0 +1,31 @@
+/*
+ * Real Time Clock workaround header file
+ * 	apply to at91sam9x5 family Engineering Samples
+ *
+ * Copyright (C) 2010 Atmel, Nicolas Ferre <nicolas.ferre@atmel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ */
+
+static u32 sam9x5es_rtc_imr = 0;
+
+#define at91_sys_read(x)	(		\
+		(x) == AT91_RTC_IMR? 		\
+			sam9x5es_rtc_imr:	\
+			at91_sys_read(x)	\
+	)
+
+#define at91_sys_write(y, x)	do {			\
+	if ((y) == AT91_RTC_IDR) {			\
+		at91_sys_write(AT91_RTC_IDR, (x));	\
+		sam9x5es_rtc_imr &= ~(x);		\
+	} else if ((y) == AT91_RTC_IER) {		\
+		sam9x5es_rtc_imr |= (x);		\
+		at91_sys_write(AT91_RTC_IER, (x));	\
+	} else {					\
+		at91_sys_write((y), (x));		\
+	}						\
+	} while (0)
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9_ddrsdr.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9_ddrsdr.h	(revision 0)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9_ddrsdr.h	(revision 150)
@@ -0,0 +1,130 @@
+/*
+ * Header file for the Atmel DDR/SDR SDRAM Controller
+ *
+ * Copyright (C) 2010 Atmel Corporation
+ *	Nicolas Ferre <nicolas.ferre@atmel.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+#ifndef AT91SAM9_DDRSDR_H
+#define AT91SAM9_DDRSDR_H
+
+#define AT91_DDRSDRC_MR		0x00	/* Mode Register */
+#define		AT91_DDRSDRC_MODE	(0x7 << 0)		/* Command Mode */
+#define			AT91_DDRSDRC_MODE_NORMAL	0
+#define			AT91_DDRSDRC_MODE_NOP		1
+#define			AT91_DDRSDRC_MODE_PRECHARGE	2
+#define			AT91_DDRSDRC_MODE_LMR		3
+#define			AT91_DDRSDRC_MODE_REFRESH	4
+#define			AT91_DDRSDRC_MODE_EXT_LMR	5
+#define			AT91_DDRSDRC_MODE_DEEP		6
+
+#define AT91_DDRSDRC_RTR	0x04	/* Refresh Timer Register */
+#define		AT91_DDRSDRC_COUNT	(0xfff << 0)		/* Refresh Timer Counter */
+
+#define AT91_DDRSDRC_CR		0x08	/* Configuration Register */
+#define		AT91_DDRSDRC_NC		(3 << 0)		/* Number of Column Bits */
+#define			AT91_DDRSDRC_NC_SDR8	(0 << 0)
+#define			AT91_DDRSDRC_NC_SDR9	(1 << 0)
+#define			AT91_DDRSDRC_NC_SDR10	(2 << 0)
+#define			AT91_DDRSDRC_NC_SDR11	(3 << 0)
+#define			AT91_DDRSDRC_NC_DDR9	(0 << 0)
+#define			AT91_DDRSDRC_NC_DDR10	(1 << 0)
+#define			AT91_DDRSDRC_NC_DDR11	(2 << 0)
+#define			AT91_DDRSDRC_NC_DDR12	(3 << 0)
+#define		AT91_DDRSDRC_NR		(3 << 2)		/* Number of Row Bits */
+#define			AT91_DDRSDRC_NR_11	(0 << 2)
+#define			AT91_DDRSDRC_NR_12	(1 << 2)
+#define			AT91_DDRSDRC_NR_13	(2 << 2)
+#define			AT91_DDRSDRC_NR_14	(3 << 2)
+#define		AT91_DDRSDRC_CAS	(7 << 4)		/* CAS Latency */
+#define			AT91_DDRSDRC_CAS_2	(2 << 4)
+#define			AT91_DDRSDRC_CAS_3	(3 << 4)
+#define			AT91_DDRSDRC_CAS_25	(6 << 4)
+#define		AT91_DDRSDRC_RST_DLL	(1 << 7)		/* Reset DLL */
+#define		AT91_DDRSDRC_DICDS	(1 << 8)		/* Output impedance control */
+#define		AT91_DDRSDRC_DIS_DLL	(1 << 9)		/* Disable DLL */
+#define		AT91_DDRSDRC_OCD	(1 << 12)		/* Off-Chip Driver */
+#define		AT91_DDRSDRC_DQMS	(1 << 16)		/* Mask Data is Shared */
+#define		AT91_DDRSDRC_ACTBST	(1 << 18)		/* Active Bank X to Burst Stop Read Access Bank Y */
+
+#define AT91_DDRSDRC_T0PR	0x0C	/* Timing 0 Register */
+#define		AT91_DDRSDRC_TRAS	(0xf <<  0)		/* Active to Precharge delay */
+#define		AT91_DDRSDRC_TRCD	(0xf <<  4)		/* Row to Column delay */
+#define		AT91_DDRSDRC_TWR	(0xf <<  8)		/* Write recovery delay */
+#define		AT91_DDRSDRC_TRC	(0xf << 12)		/* Row cycle delay */
+#define		AT91_DDRSDRC_TRP	(0xf << 16)		/* Row precharge delay */
+#define		AT91_DDRSDRC_TRRD	(0xf << 20)		/* Active BankA to BankB */
+#define		AT91_DDRSDRC_TWTR	(0x7 << 24)		/* Internal Write to Read delay */
+#define		AT91_DDRSDRC_RED_WRRD	(0x1 << 27)		/* Reduce Write to Read Delay */
+#define		AT91_DDRSDRC_TMRD	(0xf << 28)		/* Load mode to active/refresh delay */
+
+#define AT91_DDRSDRC_T1PR	0x10	/* Timing 1 Register */
+#define		AT91_DDRSDRC_TRFC	(0x1f << 0)		/* Row Cycle Delay */
+#define		AT91_DDRSDRC_TXSNR	(0xff << 8)		/* Exit self-refresh to non-read */
+#define		AT91_DDRSDRC_TXSRD	(0xff << 16)		/* Exit self-refresh to read */
+#define		AT91_DDRSDRC_TXP	(0xf  << 24)		/* Exit power-down delay */
+
+#define AT91_DDRSDRC_T2PR	0x14	/* Timing 2 Register */
+#define		AT91_DDRSDRC_TXARD	(0xf  << 0)		/* Exit active power down delay to read command in mode "Fast Exit" */
+#define		AT91_DDRSDRC_TXARDS	(0xf  << 4)		/* Exit active power down delay to read command in mode "Slow Exit" */
+#define		AT91_DDRSDRC_TRPA	(0xf  << 8)		/* Row Precharge All delay */
+#define		AT91_DDRSDRC_TRTP	(0x7  << 12)		/* Read to Precharge delay */
+
+#define AT91_DDRSDRC_LPR	0x1C	/* Low Power Register */
+#define		AT91_DDRSDRC_LPCB	(3 << 0)		/* Low-power Configurations */
+#define			AT91_DDRSDRC_LPCB_DISABLE		0
+#define			AT91_DDRSDRC_LPCB_SELF_REFRESH		1
+#define			AT91_DDRSDRC_LPCB_POWER_DOWN		2
+#define			AT91_DDRSDRC_LPCB_DEEP_POWER_DOWN	3
+#define		AT91_DDRSDRC_CLKFR	(1 << 2)	/* Clock Frozen */
+#define		AT91_DDRSDRC_PASR	(7 << 4)	/* Partial Array Self Refresh */
+#define		AT91_DDRSDRC_TCSR	(3 << 8)	/* Temperature Compensated Self Refresh */
+#define		AT91_DDRSDRC_DS		(3 << 10)	/* Drive Strength */
+#define		AT91_DDRSDRC_TIMEOUT	(3 << 12)	/* Time to define when Low Power Mode is enabled */
+#define			AT91_DDRSDRC_TIMEOUT_0_CLK_CYCLES	(0 << 12)
+#define			AT91_DDRSDRC_TIMEOUT_64_CLK_CYCLES	(1 << 12)
+#define			AT91_DDRSDRC_TIMEOUT_128_CLK_CYCLES	(2 << 12)
+#define		AT91_DDRSDRC_APDE	(1 << 16)	 /* Active power down exit time */
+#define		AT91_DDRSDRC_UPD_MR	(3 << 20)	 /* Update load mode register and extended mode register */
+
+#define AT91_DDRSDRC_MDR	0x20	/* Memory Device Register */
+#define		AT91_DDRSDRC_MD		(3 << 0)		/* Memory Device Type */
+#define			AT91_DDRSDRC_MD_SDR		0
+#define			AT91_DDRSDRC_MD_LOW_POWER_SDR	1
+#define			AT91_DDRSDRC_MD_LOW_POWER_DDR	3
+#define			AT91_DDRSDRC_MD_DDR2		6
+#define		AT91_DDRSDRC_DBW	(1 << 4)		/* Data Bus Width */
+#define			AT91_DDRSDRC_DBW_32BITS		(0 <<  4)
+#define			AT91_DDRSDRC_DBW_16BITS		(1 <<  4)
+
+#define AT91_DDRSDRC_DLL	0x24	/* DLL Information Register */
+#define		AT91_DDRSDRC_MDINC	(1 << 0)		/* Master Delay increment */
+#define		AT91_DDRSDRC_MDDEC	(1 << 1)		/* Master Delay decrement */
+#define		AT91_DDRSDRC_MDOVF	(1 << 2)		/* Master Delay Overflow */
+#define		AT91_DDRSDRC_MDVAL	(0xff <<  8)		/* Master Delay value */
+
+#define AT91_DDRSDRC_HS		0x2C	/* High Speed Register */
+#define		AT91_DDRSDRC_DIS_ATCP_RD	(1 << 2)	/* Anticip read access is disabled */
+
+#define AT91_DDRSDRC_DELAY(n)	(0x30 + (0x4 * (n)))	/* Delay I/O Register n */
+
+#define AT91_DDRSDRC_WPMR	0xE4	/* Write Protect Mode Register */
+#define		AT91_DDRSDRC_WP		(1 << 0)		/* Write protect enable */
+#define		AT91_DDRSDRC_WPKEY	(0xffffff << 8)		/* Write protect key */
+#define		AT91_DDRSDRC_KEY	(0x444452 << 8)		/* Write protect key = "DDR" */
+
+#define AT91_DDRSDRC_WPSR	0xE8	/* Write Protect Status Register */
+#define		AT91_DDRSDRC_WPVS	(1 << 0)		/* Write protect violation status */
+#define		AT91_DDRSDRC_WPVSRC	(0xffff << 8)		/* Write protect violation source */
+
+/* Register access macros */
+#define at91_ramc_read(num, reg) \
+	at91_sys_read(AT91_DDRSDRC##num + reg)
+#define at91_ramc_write(num, reg, value) \
+	at91_sys_write(AT91_DDRSDRC##num + reg, value)
+
+#endif
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/board-sam9x5.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/board-sam9x5.h	(revision 0)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/board-sam9x5.h	(revision 150)
@@ -0,0 +1,63 @@
+/*
+ *  Board-specific header file for the AT91SAM9x5 Evaluation Kit family
+ *
+ *  Copyright (C) 2010 Atmel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+/*
+ * board revision encoding
+ * TODO
+ * bit 0:
+ * 	0 =>
+ * 	1 =>
+ *
+ * OWI sands for One Wire Information
+ * The information comes form the 1-wire component on each board
+ * and is encoded in ATAGs: both system_serial_low and system_rev
+ */
+
+#define CM_REV_OFFSET	0
+#define CM_REV_SIZE	5
+#define DM_REV_OFFSET	5
+#define DM_REV_SIZE	5
+#define EK_REV_OFFSET	10
+#define EK_REV_SIZE	5
+
+/* Bit manipulation macros */
+#define OWI_BIT(name) \
+        (1 << name##_OFFSET)
+#define OWI_BF(name,value) \
+        (((value) & ((1 << name##_SIZE) - 1)) << name##_OFFSET)
+#define OWI_BFEXT(name,value) \
+        (((value) >> name##_OFFSET) & ((1 << name##_SIZE) - 1))
+#define OWI_BFINS(name,value,old) \
+        ( ((old) & ~(((1 << name##_SIZE) - 1) << name##_OFFSET)) \
+          | SPI_BF(name,value))
+
+#define cm_rev()	OWI_BFEXT(CM_REV, system_rev)
+#define dm_rev()	OWI_BFEXT(DM_REV, system_rev)
+#define ek_rev()	OWI_BFEXT(EK_REV, system_rev)
+
+#define cm_is_revA()	(cm_rev() == 0)
+#define cm_is_revB()	(cm_rev() == ('B' - 'A'))
+
+#define ek_is_revA()	(ek_rev() == 0)
+#define ek_is_revB()	(ek_rev() == ('B' - 'A'))
+
+/* Configuration of CPU Module useful for mother board */
+#define CM_CONFIG_SPI0_ENABLE	(1 <<  0)
+#define CM_CONFIG_SPI1_ENABLE	(1 <<  1)
+#define CM_CONFIG_I2C0_ENABLE	(1 <<  2)
+#define CM_CONFIG_I2C1_ENABLE	(1 <<  3)
+
+
+/* CPU Module prototypes */
+void __init cm_map_io(void);
+void __init cm_init_irq(void);
+void __init cm_board_init(u32 *cm_config);
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/system.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/system.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/system.h	(revision 150)
@@ -28,17 +28,16 @@
 
 static inline void arch_idle(void)
 {
-#ifndef CONFIG_DEBUG_KERNEL
 	/*
 	 * Disable the processor clock.  The processor will be automatically
 	 * re-enabled by an interrupt or by a reset.
 	 */
 	at91_sys_write(AT91_PMC_SCDR, AT91_PMC_PCK);
-#else
+#ifndef CONFIG_CPU_ARM920T
 	/*
 	 * Set the processor (CP15) into 'Wait for Interrupt' mode.
-	 * Unlike disabling the processor clock via the PMC (above)
-	 *  this allows the processor to be woken via JTAG.
+	 * Post-RM9200 processors need this in conjunction with the above
+	 * to save power when idle.
 	 */
 	cpu_do_idle();
 #endif
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/cpu.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/cpu.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/cpu.h	(revision 150)
@@ -27,6 +27,7 @@
 #define ARCH_ID_AT91SAM9G45	0x819b05a0
 #define ARCH_ID_AT91SAM9G45MRL	0x819b05a2	/* aka 9G45-ES2 & non ES lots */
 #define ARCH_ID_AT91SAM9G45ES	0x819b05a1	/* 9G45-ES (Engineering Sample) */
+#define ARCH_ID_AT91SAM9X5	0x819a05a0
 #define ARCH_ID_AT91CAP9	0x039A03A0
 
 #define ARCH_ID_AT91SAM9XE128	0x329973a0
@@ -52,8 +53,15 @@
 
 #define ARCH_EXID_AT91SAM9M11	0x00000001
 #define ARCH_EXID_AT91SAM9M10	0x00000002
+#define ARCH_EXID_AT91SAM9G46	0x00000003
 #define ARCH_EXID_AT91SAM9G45	0x00000004
 
+#define ARCH_EXID_AT91SAM9G15	0x00000000
+#define ARCH_EXID_AT91SAM9G35	0x00000001
+#define ARCH_EXID_AT91SAM9X35	0x00000002
+#define ARCH_EXID_AT91SAM9G25	0x00000003
+#define ARCH_EXID_AT91SAM9X25	0x00000004
+
 static inline unsigned long at91_exid_identify(void)
 {
 	return at91_sys_read(AT91_DBGU_EXID);
@@ -128,11 +136,41 @@
 #ifdef CONFIG_ARCH_AT91SAM9G45
 #define cpu_is_at91sam9g45()	(at91_cpu_identify() == ARCH_ID_AT91SAM9G45)
 #define cpu_is_at91sam9g45es()	(at91_cpu_fully_identify() == ARCH_ID_AT91SAM9G45ES)
+#define cpu_is_at91sam9m10()    (cpu_is_at91sam9g45() && \
+                                (at91_exid_identify() == ARCH_EXID_AT91SAM9M10))
+#define cpu_is_at91sam9m46()    (cpu_is_at91sam9g45() && \
+                                (at91_exid_identify() == ARCH_EXID_AT91SAM9G46))
+#define cpu_is_at91sam9m11()    (cpu_is_at91sam9g45() && \
+                                (at91_exid_identify() == ARCH_EXID_AT91SAM9M11))
 #else
 #define cpu_is_at91sam9g45()	(0)
 #define cpu_is_at91sam9g45es()	(0)
+#define cpu_is_at91sam9m10()	(0)
+#define cpu_is_at91sam9g46()	(0)
+#define cpu_is_at91sam9m11()	(0)
 #endif
 
+#ifdef CONFIG_ARCH_AT91SAM9X5
+#define cpu_is_at91sam9x5()	(at91_cpu_identify() == ARCH_ID_AT91SAM9X5)
+#define cpu_is_at91sam9g15()	(cpu_is_at91sam9x5() && \
+				(at91_exid_identify() == ARCH_EXID_AT91SAM9G15))
+#define cpu_is_at91sam9g35()	(cpu_is_at91sam9x5() && \
+				(at91_exid_identify() == ARCH_EXID_AT91SAM9G35))
+#define cpu_is_at91sam9x35()	(cpu_is_at91sam9x5() && \
+				(at91_exid_identify() == ARCH_EXID_AT91SAM9X35))
+#define cpu_is_at91sam9g25()	(cpu_is_at91sam9x5() && \
+				(at91_exid_identify() == ARCH_EXID_AT91SAM9G25))
+#define cpu_is_at91sam9x25()	(cpu_is_at91sam9x5() && \
+				(at91_exid_identify() == ARCH_EXID_AT91SAM9X25))
+#else
+#define cpu_is_at91sam9x5()	(0)
+#define cpu_is_at91sam9g15()	(0)
+#define cpu_is_at91sam9g35()	(0)
+#define cpu_is_at91sam9x35()	(0)
+#define cpu_is_at91sam9g25()	(0)
+#define cpu_is_at91sam9x25()	(0)
+#endif
+
 #ifdef CONFIG_ARCH_AT91CAP9
 #define cpu_is_at91cap9()	(at91_cpu_identify() == ARCH_ID_AT91CAP9)
 #define cpu_is_at91cap9_revB()	(at91cap9_rev_identify() == ARCH_REVISION_CAP9_B)
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91cap9.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91cap9.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91cap9.h	(revision 150)
@@ -84,7 +84,7 @@
  */
 #define AT91_ECC	(0xffffe200 - AT91_BASE_SYS)
 #define AT91_BCRAMC	(0xffffe400 - AT91_BASE_SYS)
-#define AT91_DDRSDRC	(0xffffe600 - AT91_BASE_SYS)
+#define AT91_DDRSDRC0	(0xffffe600 - AT91_BASE_SYS)
 #define AT91_SMC	(0xffffe800 - AT91_BASE_SYS)
 #define AT91_MATRIX	(0xffffea00 - AT91_BASE_SYS)
 #define AT91_CCFG	(0xffffeb10 - AT91_BASE_SYS)
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9rl.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9rl.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9rl.h	(revision 150)
@@ -74,7 +74,7 @@
  */
 #define AT91_DMA	(0xffffe600 - AT91_BASE_SYS)
 #define AT91_ECC	(0xffffe800 - AT91_BASE_SYS)
-#define AT91_SDRAMC	(0xffffea00 - AT91_BASE_SYS)
+#define AT91_SDRAMC0	(0xffffea00 - AT91_BASE_SYS)
 #define AT91_SMC	(0xffffec00 - AT91_BASE_SYS)
 #define AT91_MATRIX	(0xffffee00 - AT91_BASE_SYS)
 #define AT91_CCFG	(0xffffef10 - AT91_BASE_SYS)
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9x5_matrix.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9x5_matrix.h	(revision 0)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9x5_matrix.h	(revision 150)
@@ -0,0 +1,136 @@
+/*
+ * Matrix-centric header file for the AT91SAM9x5 family
+ *
+ *  Copyright (C) 2009-2010 Atmel Corporation.
+ *
+ * Memory Controllers (MATRIX, EBI) - System peripherals registers.
+ * Based on AT91SAM9x5 preliminary datasheet.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91SAM9X5_MATRIX_H
+#define AT91SAM9X5_MATRIX_H
+
+#define AT91_MATRIX_MCFG0	(AT91_MATRIX + 0x00)	/* Master Configuration Register 0 */
+#define AT91_MATRIX_MCFG1	(AT91_MATRIX + 0x04)	/* Master Configuration Register 1 */
+#define AT91_MATRIX_MCFG2	(AT91_MATRIX + 0x08)	/* Master Configuration Register 2 */
+#define AT91_MATRIX_MCFG3	(AT91_MATRIX + 0x0C)	/* Master Configuration Register 3 */
+#define AT91_MATRIX_MCFG4	(AT91_MATRIX + 0x10)	/* Master Configuration Register 4 */
+#define AT91_MATRIX_MCFG5	(AT91_MATRIX + 0x14)	/* Master Configuration Register 5 */
+#define AT91_MATRIX_MCFG6	(AT91_MATRIX + 0x18)	/* Master Configuration Register 6 */
+#define AT91_MATRIX_MCFG7	(AT91_MATRIX + 0x1C)	/* Master Configuration Register 7 */
+#define AT91_MATRIX_MCFG8	(AT91_MATRIX + 0x20)	/* Master Configuration Register 8 */
+#define AT91_MATRIX_MCFG9	(AT91_MATRIX + 0x24)	/* Master Configuration Register 9 */
+#define AT91_MATRIX_MCFG10	(AT91_MATRIX + 0x28)	/* Master Configuration Register 10 */
+#define AT91_MATRIX_MCFG11	(AT91_MATRIX + 0x2C)	/* Master Configuration Register 11 */
+#define		AT91_MATRIX_ULBT	(7 << 0)	/* Undefined Length Burst Type */
+#define			AT91_MATRIX_ULBT_INFINITE	(0 << 0)
+#define			AT91_MATRIX_ULBT_SINGLE		(1 << 0)
+#define			AT91_MATRIX_ULBT_FOUR		(2 << 0)
+#define			AT91_MATRIX_ULBT_EIGHT		(3 << 0)
+#define			AT91_MATRIX_ULBT_SIXTEEN	(4 << 0)
+#define			AT91_MATRIX_ULBT_THIRTYTWO	(5 << 0)
+#define			AT91_MATRIX_ULBT_SIXTYFOUR	(6 << 0)
+#define			AT91_MATRIX_ULBT_128		(7 << 0)
+
+#define AT91_MATRIX_SCFG0	(AT91_MATRIX + 0x40)	/* Slave Configuration Register 0 */
+#define AT91_MATRIX_SCFG1	(AT91_MATRIX + 0x44)	/* Slave Configuration Register 1 */
+#define AT91_MATRIX_SCFG2	(AT91_MATRIX + 0x48)	/* Slave Configuration Register 2 */
+#define AT91_MATRIX_SCFG3	(AT91_MATRIX + 0x4C)	/* Slave Configuration Register 3 */
+#define AT91_MATRIX_SCFG4	(AT91_MATRIX + 0x50)	/* Slave Configuration Register 4 */
+#define AT91_MATRIX_SCFG5	(AT91_MATRIX + 0x54)	/* Slave Configuration Register 5 */
+#define AT91_MATRIX_SCFG6	(AT91_MATRIX + 0x58)	/* Slave Configuration Register 6 */
+#define AT91_MATRIX_SCFG7	(AT91_MATRIX + 0x5C)	/* Slave Configuration Register 7 */
+#define AT91_MATRIX_SCFG8	(AT91_MATRIX + 0x60)	/* Slave Configuration Register 8 */
+#define		AT91_MATRIX_SLOT_CYCLE		(0x1ff << 0)	/* Maximum Number of Allowed Cycles for a Burst */
+#define		AT91_MATRIX_DEFMSTR_TYPE	(3    << 16)	/* Default Master Type */
+#define			AT91_MATRIX_DEFMSTR_TYPE_NONE	(0 << 16)
+#define			AT91_MATRIX_DEFMSTR_TYPE_LAST	(1 << 16)
+#define			AT91_MATRIX_DEFMSTR_TYPE_FIXED	(2 << 16)
+#define		AT91_MATRIX_FIXED_DEFMSTR	(0xf  << 18)	/* Fixed Index of Default Master */
+
+#define AT91_MATRIX_PRAS0	(AT91_MATRIX + 0x80)	/* Priority Register A for Slave 0 */
+#define AT91_MATRIX_PRBS0	(AT91_MATRIX + 0x84)	/* Priority Register B for Slave 0 */
+#define AT91_MATRIX_PRAS1	(AT91_MATRIX + 0x88)	/* Priority Register A for Slave 1 */
+#define AT91_MATRIX_PRBS1	(AT91_MATRIX + 0x8C)	/* Priority Register B for Slave 1 */
+#define AT91_MATRIX_PRAS2	(AT91_MATRIX + 0x90)	/* Priority Register A for Slave 2 */
+#define AT91_MATRIX_PRBS2	(AT91_MATRIX + 0x94)	/* Priority Register B for Slave 2 */
+#define AT91_MATRIX_PRAS3	(AT91_MATRIX + 0x98)	/* Priority Register A for Slave 3 */
+#define AT91_MATRIX_PRBS3	(AT91_MATRIX + 0x9C)	/* Priority Register B for Slave 3 */
+#define AT91_MATRIX_PRAS4	(AT91_MATRIX + 0xA0)	/* Priority Register A for Slave 4 */
+#define AT91_MATRIX_PRBS4	(AT91_MATRIX + 0xA4)	/* Priority Register B for Slave 4 */
+#define AT91_MATRIX_PRAS5	(AT91_MATRIX + 0xA8)	/* Priority Register A for Slave 5 */
+#define AT91_MATRIX_PRBS5	(AT91_MATRIX + 0xAC)	/* Priority Register B for Slave 5 */
+#define AT91_MATRIX_PRAS6	(AT91_MATRIX + 0xB0)	/* Priority Register A for Slave 6 */
+#define AT91_MATRIX_PRBS6	(AT91_MATRIX + 0xB4)	/* Priority Register B for Slave 6 */
+#define AT91_MATRIX_PRAS7	(AT91_MATRIX + 0xB8)	/* Priority Register A for Slave 7 */
+#define AT91_MATRIX_PRBS7	(AT91_MATRIX + 0xBC)	/* Priority Register B for Slave 7 */
+#define AT91_MATRIX_PRAS8	(AT91_MATRIX + 0xC0)	/* Priority Register A for Slave 8 */
+#define AT91_MATRIX_PRBS8	(AT91_MATRIX + 0xC4)	/* Priority Register B for Slave 8 */
+#define		AT91_MATRIX_M0PR		(3 << 0)	/* Master 0 Priority */
+#define		AT91_MATRIX_M1PR		(3 << 4)	/* Master 1 Priority */
+#define		AT91_MATRIX_M2PR		(3 << 8)	/* Master 2 Priority */
+#define		AT91_MATRIX_M3PR		(3 << 12)	/* Master 3 Priority */
+#define		AT91_MATRIX_M4PR		(3 << 16)	/* Master 4 Priority */
+#define		AT91_MATRIX_M5PR		(3 << 20)	/* Master 5 Priority */
+#define		AT91_MATRIX_M6PR		(3 << 24)	/* Master 6 Priority */
+#define		AT91_MATRIX_M7PR		(3 << 28)	/* Master 7 Priority */
+#define		AT91_MATRIX_M8PR		(3 << 0)	/* Master 8 Priority (in Register B) */
+#define		AT91_MATRIX_M9PR		(3 << 4)	/* Master 9 Priority (in Register B) */
+#define		AT91_MATRIX_M10PR		(3 << 8)	/* Master 10 Priority (in Register B) */
+#define		AT91_MATRIX_M11PR		(3 << 12)	/* Master 11 Priority (in Register B) */
+
+#define AT91_MATRIX_MRCR	(AT91_MATRIX + 0x100)	/* Master Remap Control Register */
+#define		AT91_MATRIX_RCB0		(1 << 0)	/* Remap Command for AHB Master 0 (ARM926EJ-S Instruction Master) */
+#define		AT91_MATRIX_RCB1		(1 << 1)	/* Remap Command for AHB Master 1 (ARM926EJ-S Data Master) */
+#define		AT91_MATRIX_RCB2		(1 << 2)
+#define		AT91_MATRIX_RCB3		(1 << 3)
+#define		AT91_MATRIX_RCB4		(1 << 4)
+#define		AT91_MATRIX_RCB5		(1 << 5)
+#define		AT91_MATRIX_RCB6		(1 << 6)
+#define		AT91_MATRIX_RCB7		(1 << 7)
+#define		AT91_MATRIX_RCB8		(1 << 8)
+#define		AT91_MATRIX_RCB9		(1 << 9)
+#define		AT91_MATRIX_RCB10		(1 << 10)
+#define		AT91_MATRIX_RCB11		(1 << 11)
+
+#define AT91_MATRIX_EBICSA	(AT91_MATRIX + 0x120)	/* EBI Chip Select Assignment Register */
+#define		AT91_MATRIX_EBI_CS1A		(1 << 1)	/* Chip Select 1 Assignment */
+#define			AT91_MATRIX_EBI_CS1A_SMC		(0 << 1)
+#define			AT91_MATRIX_EBI_CS1A_SDRAMC		(1 << 1)
+#define		AT91_MATRIX_EBI_CS3A		(1 << 3)	/* Chip Select 3 Assignment */
+#define			AT91_MATRIX_EBI_CS3A_SMC		(0 << 3)
+#define			AT91_MATRIX_EBI_CS3A_SMC_NANDFLASH	(1 << 3)
+#define		AT91_MATRIX_EBI_DBPUC		(1 << 8)	/* Data Bus Pull-up Configuration */
+#define			AT91_MATRIX_EBI_DBPU_ON			(0 << 8)
+#define			AT91_MATRIX_EBI_DBPU_OFF		(1 << 8)
+#define		AT91_MATRIX_EBI_DBPDC		(1 << 9)	/* Data Bus Pull-up Configuration */
+#define			AT91_MATRIX_EBI_DBPD_ON			(0 << 9)
+#define			AT91_MATRIX_EBI_DBPD_OFF		(1 << 9)
+#define		AT91_MATRIX_EBI_EBI_IOSR	(1 << 17)	/* EBI I/O slew rate selection */
+#define			AT91_MATRIX_EBI_EBI_IOSR_REDUCED	(0 << 17)
+#define			AT91_MATRIX_EBI_EBI_IOSR_NORMAL		(1 << 17)
+#define		AT91_MATRIX_NFD0_SELECT		(1 << 24)	/* NAND Flash Data Bus Selection */
+#define			AT91_MATRIX_NFD0_ON_D0			(0 << 24)
+#define			AT91_MATRIX_NFD0_ON_D16			(1 << 24)
+#define		AT91_MATRIX_DDR_MP_EN		(1 << 25)	/* DDR Multi-port Enable */
+#define			AT91_MATRIX_MP_OFF			(0 << 25)
+#define			AT91_MATRIX_MP_ON			(1 << 25)
+
+#define AT91_MATRIX_WPMR	(AT91_MATRIX + 0x1E4)	/* Write Protect Mode Register */
+#define		AT91_MATRIX_WPMR_WPEN		(1 << 0)	/* Write Protect ENable */
+#define			AT91_MATRIX_WPMR_WP_WPDIS		(0 << 0)
+#define			AT91_MATRIX_WPMR_WP_WPEN		(1 << 0)
+#define		AT91_MATRIX_WPMR_WPKEY		(0xFFFFFF << 8)	/* Write Protect KEY */
+
+#define AT91_MATRIX_WPSR	(AT91_MATRIX + 0x1E8)	/* Write Protect Status Register */
+#define		AT91_MATRIX_WPSR_WPVS		(1 << 0)	/* Write Protect Violation Status */
+#define			AT91_MATRIX_WPSR_NO_WPV		(0 << 0)
+#define			AT91_MATRIX_WPSR_WPV		(1 << 0)
+#define		AT91_MATRIX_WPSR_WPVSRC		(0xFFFF << 8)	/* Write Protect Violation Source */
+
+#endif
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91_pmc.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91_pmc.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91_pmc.h	(revision 150)
@@ -47,9 +47,13 @@
 #define		AT91_PMC_BIASCOUNT	(0xf << 28)		/* UTMI BIAS Start-up Time */
 
 #define	AT91_CKGR_MOR		(AT91_PMC + 0x20)	/* Main Oscillator Register [not on SAM9RL] */
-#define		AT91_PMC_MOSCEN		(1    << 0)		/* Main Oscillator Enable */
-#define		AT91_PMC_OSCBYPASS	(1    << 1)		/* Oscillator Bypass [SAM9x, CAP9] */
-#define		AT91_PMC_OSCOUNT	(0xff << 8)		/* Main Oscillator Start-up Time */
+#define		AT91_PMC_MOSCEN		(1    <<  0)		/* Main Oscillator Enable */
+#define		AT91_PMC_OSCBYPASS	(1    <<  1)		/* Oscillator Bypass [SAM9x, CAP9] */
+#define		AT91_PMC_MOSCRCEN	(1    <<  3)		/* Main On-Chip RC Oscillator Enable [some SAM9] */
+#define		AT91_PMC_OSCOUNT	(0xff <<  8)		/* Main Oscillator Start-up Time */
+#define		AT91_PMC_KEY		(0x37 << 16)		/* MOR Writing Key */
+#define		AT91_PMC_MOSCSEL	(1    << 24)		/* Main Oscillator Selection [some SAM9] */
+#define		AT91_PMC_CFDEN		(1    << 25)		/* Clock Failure Detector Enable [some SAM9] */
 
 #define	AT91_CKGR_MCFR		(AT91_PMC + 0x24)	/* Main Clock Frequency Register */
 #define		AT91_PMC_MAINF		(0xffff <<  0)		/* Main Clock Frequency */
@@ -74,14 +78,24 @@
 #define			AT91_PMC_CSS_PLLA		(2 << 0)
 #define			AT91_PMC_CSS_PLLB		(3 << 0)
 #define			AT91_PMC_CSS_UPLL		(3 << 0)	/* [some SAM9 only] */
-#define		AT91_PMC_PRES		(7 <<  2)		/* Master Clock Prescaler */
-#define			AT91_PMC_PRES_1			(0 << 2)
-#define			AT91_PMC_PRES_2			(1 << 2)
-#define			AT91_PMC_PRES_4			(2 << 2)
-#define			AT91_PMC_PRES_8			(3 << 2)
-#define			AT91_PMC_PRES_16		(4 << 2)
-#define			AT91_PMC_PRES_32		(5 << 2)
-#define			AT91_PMC_PRES_64		(6 << 2)
+#define		PMC_PRES_OFFSET		2
+#define		AT91_PMC_PRES		(7 <<  PMC_PRES_OFFSET)		/* Master Clock Prescaler */
+#define			AT91_PMC_PRES_1			(0 << PMC_PRES_OFFSET)
+#define			AT91_PMC_PRES_2			(1 << PMC_PRES_OFFSET)
+#define			AT91_PMC_PRES_4			(2 << PMC_PRES_OFFSET)
+#define			AT91_PMC_PRES_8			(3 << PMC_PRES_OFFSET)
+#define			AT91_PMC_PRES_16		(4 << PMC_PRES_OFFSET)
+#define			AT91_PMC_PRES_32		(5 << PMC_PRES_OFFSET)
+#define			AT91_PMC_PRES_64		(6 << PMC_PRES_OFFSET)
+#define		PMC_ALT_PRES_OFFSET	4
+#define		AT91_PMC_ALT_PRES	(7 <<  PMC_ALT_PRES_OFFSET)		/* Master Clock Prescaler [alternate location] */
+#define			AT91_PMC_ALT_PRES_1		(0 << PMC_ALT_PRES_OFFSET)
+#define			AT91_PMC_ALT_PRES_2		(1 << PMC_ALT_PRES_OFFSET)
+#define			AT91_PMC_ALT_PRES_4		(2 << PMC_ALT_PRES_OFFSET)
+#define			AT91_PMC_ALT_PRES_8		(3 << PMC_ALT_PRES_OFFSET)
+#define			AT91_PMC_ALT_PRES_16		(4 << PMC_ALT_PRES_OFFSET)
+#define			AT91_PMC_ALT_PRES_32		(5 << PMC_ALT_PRES_OFFSET)
+#define			AT91_PMC_ALT_PRES_64		(6 << PMC_ALT_PRES_OFFSET)
 #define		AT91_PMC_MDIV		(3 <<  8)		/* Master Clock Division */
 #define			AT91RM9200_PMC_MDIV_1		(0 << 8)	/* [AT91RM9200 only] */
 #define			AT91RM9200_PMC_MDIV_2		(1 << 8)
@@ -105,7 +119,14 @@
 #define			AT91_PMC_USBS_UPLL		(1 << 0)
 #define		AT91_PMC_OHCIUSBDIV	(0xF <<  8)		/* Divider for USB OHCI Clock */
 
+#define	AT91_PMC_SMD		(AT91_PMC + 0x3c)	/* Soft Modem Clock Register [some SAM9 only] */
+#define		AT91_PMC_SMDS		(0x1  <<  0)		/* SMD input clock selection */
+#define		AT91_PMC_SMD_DIV	(0x1f <<  8)		/* SMD input clock divider */
+#define		AT91_PMC_SMDDIV(n)	(((n) <<  8) & AT91_PMC_SMD_DIV)
+
 #define	AT91_PMC_PCKR(n)	(AT91_PMC + 0x40 + ((n) * 4))	/* Programmable Clock 0-N Registers */
+#define		AT91_PMC_ALT_PCKR_CSS	(0x7 <<  0)		/* Programmable Clock Source Selection [alternate length] */
+#define			AT91_PMC_CSS_MASTER		(4 << 0)	/* [some SAM9 only] */
 #define		AT91_PMC_CSSMCK		(0x1 <<  8)		/* CSS or Master Clock Selection */
 #define			AT91_PMC_CSSMCK_CSS		(0 << 8)
 #define			AT91_PMC_CSSMCK_MCK		(1 << 8)
@@ -123,11 +144,27 @@
 #define		AT91_PMC_PCK1RDY	(1 <<  9)		/* Programmable Clock 1 */
 #define		AT91_PMC_PCK2RDY	(1 << 10)		/* Programmable Clock 2 */
 #define		AT91_PMC_PCK3RDY	(1 << 11)		/* Programmable Clock 3 */
+#define		AT91_PMC_MOSCSELS	(1 << 16)		/* Main Oscillator Selection [some SAM9] */
+#define		AT91_PMC_MOSCRCS	(1 << 17)		/* Main On-Chip RC [some SAM9] */
+#define		AT91_PMC_CFDEV		(1 << 18)		/* Clock Failure Detector Event [some SAM9] */
 #define	AT91_PMC_IMR		(AT91_PMC + 0x6c)	/* Interrupt Mask Register */
 
-#define AT91_PMC_PROT		(AT91_PMC + 0xe4)	/* Protect Register [AT91CAP9 revC only] */
-#define		AT91_PMC_PROTKEY	0x504d4301	/* Activation Code */
+#define AT91_PMC_PROT		(AT91_PMC + 0xe4)	/* Write Protect Mode Register [some SAM9, AT91CAP9 revC only] */
+#define		AT91_PMC_WPEN		(0x1  <<  0)		/* Write Protect Enable */
+#define		AT91_PMC_WPKEY		(0xffffff << 8)		/* Write Protect Key */
+#define		AT91_PMC_PROTKEY	(0x504d43 << 8)		/* Activation Code */
 
+#define AT91_PMC_WPSR		(AT91_PMC + 0xe8)	/* Write Protect Status Register [some SAM9] */
+#define		AT91_PMC_WPVS		(0x1  <<  0)		/* Write Protect Violation Status */
+#define		AT91_PMC_WPVSRC		(0xffff  <<  8)		/* Write Protect Violation Source */
+
 #define AT91_PMC_VER		(AT91_PMC + 0xfc)	/* PMC Module Version [AT91CAP9 only] */
 
+#define AT91_PMC_PCR		(AT91_PMC + 0x10c)	/* Peripheral Control Register [some SAM9] */
+#define		AT91_PMC_PCR_PID	(0x3f  <<  0)		/* Peripheral ID */
+#define		AT91_PMC_PCR_CMD	(0x1  <<  12)		/* Command */
+#define		AT91_PMC_PCR_DIV	(0x3  <<  16)		/* Divisor Value */
+#define		AT91_PMC_PCRDIV(n)	(((n) <<  16) & AT91_PMC_PCR_DIV)
+#define		AT91_PMC_PCR_EN		(0x1  <<  28)		/* Enable */
+
 #endif
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91_pio.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91_pio.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91_pio.h	(revision 150)
@@ -40,10 +40,35 @@
 #define PIO_PUER	0x64	/* Pull-up Enable Register */
 #define PIO_PUSR	0x68	/* Pull-up Status Register */
 #define PIO_ASR		0x70	/* Peripheral A Select Register */
+#define PIO_ABCDSR1	0x70	/* Peripheral ABCD Select Register 1 [some sam9 only] */
 #define PIO_BSR		0x74	/* Peripheral B Select Register */
+#define PIO_ABCDSR2	0x74	/* Peripheral ABCD Select Register 2 [some sam9 only] */
 #define PIO_ABSR	0x78	/* AB Status Register */
+#define PIO_IFSCDR	0x80	/* Input Filter Slow Clock Disable Register */
+#define PIO_IFSCER	0x84	/* Input Filter Slow Clock Enable Register */
+#define PIO_IFSCSR	0x88	/* Input Filter Slow Clock Status Register */
+#define PIO_SCDR	0x8c	/* Slow Clock Divider Debouncing Register */
+#define		PIO_SCDR_DIV	(0x3fff <<  0)		/* Slow Clock Divider Mask */
+#define PIO_PPDDR	0x90	/* Pad Pull-down Disable Register */
+#define PIO_PPDER	0x94	/* Pad Pull-down Enable Register */
+#define PIO_PPDSR	0x98	/* Pad Pull-down Status Register */
 #define PIO_OWER	0xa0	/* Output Write Enable Register */
 #define PIO_OWDR	0xa4	/* Output Write Disable Register */
 #define PIO_OWSR	0xa8	/* Output Write Status Register */
+#define PIO_AIMER	0xb0	/* Additional Interrupt Modes Enable Register */
+#define PIO_AIMDR	0xb4	/* Additional Interrupt Modes Disable Register */
+#define PIO_AIMMR	0xb8	/* Additional Interrupt Modes Mask Register */
+#define PIO_ESR		0xc0	/* Edge Select Register */
+#define PIO_LSR		0xc4	/* Level Select Register */
+#define PIO_ELSR	0xc8	/* Edge/Level Status Register */
+#define PIO_FELLSR	0xd0	/* Falling Edge/Low Level Select Register */
+#define PIO_REHLSR	0xd4	/* Rising Edge/ High Level Select Register */
+#define PIO_FRLHSR	0xd8	/* Fall/Rise - Low/High Status Register */
+#define PIO_SCHMITT	0x100	/* Schmitt Trigger Register */
 
+#define ABCDSR_PERIPH_A	0x0
+#define ABCDSR_PERIPH_B	0x1
+#define ABCDSR_PERIPH_C	0x2
+#define ABCDSR_PERIPH_D	0x3
+
 #endif
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9x5.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9x5.h	(revision 0)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/at91sam9x5.h	(revision 150)
@@ -0,0 +1,179 @@
+/*
+ * Chip-specific header file for the AT91SAM9x5 family
+ *
+ *  Copyright (C) 2009-2010 Atmel Corporation.
+ *
+ * Common definitions.
+ * Based on AT91SAM9x5 preliminary datasheet.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#ifndef AT91SAM9X5_H
+#define AT91SAM9X5_H
+
+/*
+ * Peripheral identifiers/interrupts.
+ */
+#define AT91_ID_FIQ		0	/* Advanced Interrupt Controller (FIQ) */
+#define AT91_ID_SYS		1	/* System Controller Interrupt */
+#define AT91SAM9X5_ID_PIOAB	2	/* Parallel I/O Controller A and B */
+#define AT91SAM9X5_ID_PIOCD	3	/* Parallel I/O Controller C and D */
+#define AT91SAM9X5_ID_SMD	4	/* SMD Soft Modem (SMD) */
+#define AT91SAM9X5_ID_USART0	5	/* USART 0 */
+#define AT91SAM9X5_ID_USART1	6	/* USART 1 */
+#define AT91SAM9X5_ID_USART2	7	/* USART 2 */
+#define AT91SAM9X5_ID_USART3	8	/* USART 3 */
+#define AT91SAM9X5_ID_TWI0	9	/* Two-Wire Interface 0 */
+#define AT91SAM9X5_ID_TWI1	10	/* Two-Wire Interface 1 */
+#define AT91SAM9X5_ID_TWI2	11	/* Two-Wire Interface 2 */
+#define AT91SAM9X5_ID_MCI0	12	/* High Speed Multimedia Card Interface 0 */
+#define AT91SAM9X5_ID_SPI0	13	/* Serial Peripheral Interface 0 */
+#define AT91SAM9X5_ID_SPI1	14	/* Serial Peripheral Interface 1 */
+#define AT91SAM9X5_ID_UART0	15	/* UART 0 */
+#define AT91SAM9X5_ID_UART1	16	/* UART 1 */
+#define AT91SAM9X5_ID_TCB	17	/* Timer Counter 0, 1, 2, 3, 4 and 5 */
+#define AT91SAM9X5_ID_PWM	18	/* Pulse Width Modulation Controller */
+#define AT91SAM9X5_ID_ADC	19	/* ADC Controller */
+#define AT91SAM9X5_ID_DMA0	20	/* DMA Controller 0 */
+#define AT91SAM9X5_ID_DMA1	21	/* DMA Controller 1 */
+#define AT91SAM9X5_ID_UHPHS	22	/* USB Host High Speed */
+#define AT91SAM9X5_ID_UDPHS	23	/* USB Device High Speed */
+#define AT91SAM9X5_ID_EMAC0	24	/* Ethernet MAC0 */
+#define AT91SAM9X5_ID_LCDC	25	/* LCD Controller */
+#define AT91SAM9X5_ID_ISI	25	/* Image Sensor Interface */
+#define AT91SAM9X5_ID_MCI1	26	/* High Speed Multimedia Card Interface 1 */
+#define AT91SAM9X5_ID_EMAC1	27	/* Ethernet MAC1 */
+#define AT91SAM9X5_ID_SSC	28	/* Synchronous Serial Controller */
+#define AT91SAM9X5_ID_CAN0	29	/* CAN Controller 0 */
+#define AT91SAM9X5_ID_CAN1	30	/* CAN Controller 1 */
+#define AT91SAM9X5_ID_IRQ0	31	/* Advanced Interrupt Controller */
+
+/*
+ * User Peripheral physical base addresses.
+ */
+#define AT91SAM9X5_BASE_SPI0		0xf0000000
+#define AT91SAM9X5_BASE_SPI1		0xf0004000
+#define AT91SAM9X5_BASE_MCI0		0xf0008000
+#define AT91SAM9X5_BASE_MCI1		0xf000c000
+#define AT91SAM9X5_BASE_SSC		0xf0010000
+#define AT91SAM9X5_BASE_CAN0		0xf8000000
+#define AT91SAM9X5_BASE_CAN1		0xf8004000
+#define AT91SAM9X5_BASE_TCB0		0xf8008000
+#define AT91SAM9X5_BASE_TC0		0xf8008000
+#define AT91SAM9X5_BASE_TC1		0xf8008040
+#define AT91SAM9X5_BASE_TC2		0xf8008080
+#define AT91SAM9X5_BASE_TCB1		0xf800c000
+#define AT91SAM9X5_BASE_TC3		0xf800c000
+#define AT91SAM9X5_BASE_TC4		0xf800c040
+#define AT91SAM9X5_BASE_TC5		0xf800c080
+#define AT91SAM9X5_BASE_TWI0		0xf8010000
+#define AT91SAM9X5_BASE_TWI1		0xf8014000
+#define AT91SAM9X5_BASE_TWI2		0xf8018000
+#define AT91SAM9X5_BASE_USART0		0xf801c000
+#define AT91SAM9X5_BASE_USART1		0xf8020000
+#define AT91SAM9X5_BASE_USART2		0xf8024000
+#define AT91SAM9X5_BASE_USART3		0xf8028000
+#define AT91SAM9X5_BASE_EMAC0		0xf802c000
+#define AT91SAM9X5_BASE_EMAC1		0xf8030000
+#define AT91SAM9X5_BASE_PWMC		0xf8034000
+#define AT91SAM9X5_BASE_LCDC		0xf8038000
+#define AT91SAM9X5_BASE_UDPHS		0xf803c000
+#define AT91SAM9X5_BASE_UART0		0xf8040000
+#define AT91SAM9X5_BASE_UART1		0xf8044000
+#define AT91SAM9X5_BASE_ISI		0xf8048000
+#define AT91SAM9X5_BASE_ADC		0xf804c000
+#define AT91_BASE_SYS			0xffffc000
+
+/*
+ * System Peripherals (offset from AT91_BASE_SYS)
+ */
+#define AT91_MATRIX	(0xffffde00 - AT91_BASE_SYS)
+#define AT91_PMECC	(0xffffe000 - AT91_BASE_SYS)
+#define AT91_PMERRLOC	(0xffffe600 - AT91_BASE_SYS)
+#define AT91_DDRSDRC0	(0xffffe800 - AT91_BASE_SYS)
+#define AT91_SMC	(0xffffea00 - AT91_BASE_SYS)
+#define AT91_DMA0	(0xffffec00 - AT91_BASE_SYS)
+#define AT91_DMA1	(0xffffee00 - AT91_BASE_SYS)
+#define AT91_AIC	(0xfffff000 - AT91_BASE_SYS)
+#define AT91_DBGU	(0xfffff200 - AT91_BASE_SYS)
+#define AT91_PIOA	(0xfffff400 - AT91_BASE_SYS)
+#define AT91_PIOB	(0xfffff600 - AT91_BASE_SYS)
+#define AT91_PIOC	(0xfffff800 - AT91_BASE_SYS)
+#define AT91_PIOD	(0xfffffa00 - AT91_BASE_SYS)
+#define AT91_PMC	(0xfffffc00 - AT91_BASE_SYS)
+#define AT91_RSTC	(0xfffffe00 - AT91_BASE_SYS)
+#define AT91_SHDWC	(0xfffffe10 - AT91_BASE_SYS)
+#define AT91_PIT	(0xfffffe30 - AT91_BASE_SYS)
+#define AT91_WDT	(0xfffffe40 - AT91_BASE_SYS)
+#define AT91_GPBR	(0xfffffe60 - AT91_BASE_SYS)
+#define AT91_RTC	(0xfffffeb0 - AT91_BASE_SYS)
+
+#define AT91_USART0	AT91SAM9X5_BASE_US0
+#define AT91_USART1	AT91SAM9X5_BASE_US1
+#define AT91_USART2	AT91SAM9X5_BASE_US2
+#define AT91_USART3	AT91SAM9X5_BASE_US3
+
+/*
+ * Internal Memory.
+ */
+#define AT91SAM9X5_SRAM_BASE	0x00300000	/* Internal SRAM base address */
+#define AT91SAM9X5_SRAM_SIZE	SZ_32K		/* Internal SRAM size (32Kb) */
+
+#define AT91SAM9X5_ROM_BASE	0x00100000	/* Internal ROM base address */
+#define AT91SAM9X5_ROM_SIZE	SZ_1M		/* Internal ROM size (1Mb) */
+
+#define AT91SAM9X5_SMD_BASE	0x00400000	/* SMD Controller */
+#define AT91SAM9X5_UDPHS_FIFO	0x00500000	/* USB Device HS controller */
+#define AT91SAM9X5_OHCI_BASE	0x00600000	/* USB Host controller (OHCI) */
+#define AT91SAM9X5_EHCI_BASE	0x00700000	/* USB Host controller (EHCI) */
+
+#define CONFIG_DRAM_BASE	AT91_CHIPSELECT_1
+
+#define CONSISTENT_DMA_SIZE	SZ_8M
+
+/*
+ * DMA0 peripheral identifiers
+ * for hardware handshaking interface
+ */
+#define AT_DMA_ID_MCI0		 0
+#define AT_DMA_ID_SPI0_TX	 1
+#define AT_DMA_ID_SPI0_RX	 2
+#define AT_DMA_ID_USART0_TX	 3
+#define AT_DMA_ID_USART0_RX	 4
+#define AT_DMA_ID_USART1_TX	 5
+#define AT_DMA_ID_USART1_RX	 6
+#define AT_DMA_ID_TWI0_TX	 7
+#define AT_DMA_ID_TWI0_RX	 8
+#define AT_DMA_ID_TWI2_TX	 9
+#define AT_DMA_ID_TWI2_RX	10
+#define AT_DMA_ID_UART0_TX	11
+#define AT_DMA_ID_UART0_RX	12
+#define AT_DMA_ID_SSC_TX	13
+#define AT_DMA_ID_SSC_RX	14
+
+/*
+ * DMA1 peripheral identifiers
+ * for hardware handshaking interface
+ */
+#define AT_DMA_ID_MCI1		 0
+#define AT_DMA_ID_SPI1_TX	 1
+#define AT_DMA_ID_SPI1_RX	 2
+#define AT_DMA_ID_SMD_TX	 3
+#define AT_DMA_ID_SMD_RX	 4
+#define AT_DMA_ID_TWI1_TX	 5
+#define AT_DMA_ID_TWI1_RX	 6
+#define AT_DMA_ID_ADC_RX	 7
+#define AT_DMA_ID_DBGU_TX	 8
+#define AT_DMA_ID_DBGU_RX	 9
+#define AT_DMA_ID_UART1_TX	10
+#define AT_DMA_ID_UART1_RX	11
+#define AT_DMA_ID_USART2_TX	12
+#define AT_DMA_ID_USART2_RX	13
+#define AT_DMA_ID_USART3_TX	14
+#define AT_DMA_ID_USART3_RX	15
+
+#endif
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/timex.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/timex.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/timex.h	(revision 150)
@@ -72,6 +72,11 @@
 #define AT91SAM9_MASTER_CLOCK	133333333
 #define CLOCK_TICK_RATE		(AT91SAM9_MASTER_CLOCK/16)
 
+#elif defined(CONFIG_ARCH_AT91SAM9X5)
+
+#define AT91SAM9_MASTER_CLOCK	133333333
+#define CLOCK_TICK_RATE		(AT91SAM9_MASTER_CLOCK/16)
+
 #elif defined(CONFIG_ARCH_AT91CAP9)
 
 #define AT91CAP9_MASTER_CLOCK	100000000
Index: linux-2.6.35/arch/arm/mach-at91/include/mach/board.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/include/mach/board.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/include/mach/board.h	(revision 150)
@@ -85,17 +85,21 @@
 	u8		phy_irq_pin;	/* PHY IRQ */
 	u8		is_rmii;	/* using RMII interface? */
 };
+#if defined(CONFIG_ARCH_AT91SAM9X5)
+extern void __init at91_add_device_eth(short eth_id, struct at91_eth_data *data);
+#else
 extern void __init at91_add_device_eth(struct at91_eth_data *data);
+#endif
 
 #if defined(CONFIG_ARCH_AT91SAM9260) || defined(CONFIG_ARCH_AT91SAM9263) || defined(CONFIG_ARCH_AT91SAM9G20) || defined(CONFIG_ARCH_AT91CAP9) \
-	|| defined(CONFIG_ARCH_AT91SAM9G45) || defined(CONFIG_ARCH_AT572D940HF)
+	|| defined(CONFIG_ARCH_AT91SAM9G45) || defined(CONFIG_ARCH_AT91SAM9X5) || defined(CONFIG_ARCH_AT572D940HF)
 #define eth_platform_data	at91_eth_data
 #endif
 
  /* USB Host */
 struct at91_usbh_data {
 	u8		ports;		/* number of ports on root hub */
-	u8		vbus_pin[2];	/* port power-control pin */
+	u8		vbus_pin[3];	/* port power-control pin */
 };
 extern void __init at91_add_device_usbh(struct at91_usbh_data *data);
 extern void __init at91_add_device_usbh_ohci(struct at91_usbh_data *data);
@@ -110,12 +114,13 @@
 	u8		ale;		/* address line number connected to ALE */
 	u8		cle;		/* address line number connected to CLE */
 	u8		bus_width_16;	/* buswidth is 16 bit */
+	u8		bus_on_d0;	/* pins of data bus are connected to D0~D15 */
 	struct mtd_partition* (*partition_info)(int, int*);
 };
 extern void __init at91_add_device_nand(struct atmel_nand_data *data);
 
  /* I2C*/
-#if defined(CONFIG_ARCH_AT91SAM9G45)
+#if defined(CONFIG_ARCH_AT91SAM9G45) || defined(CONFIG_ARCH_AT91SAM9X5)
 extern void __init at91_add_device_i2c(short i2c_id, struct i2c_board_info *devices, int nr_devices);
 #else
 extern void __init at91_add_device_i2c(struct i2c_board_info *devices, int nr_devices);
@@ -147,6 +152,7 @@
 	short			use_dma_tx;	/* use transmit DMA? */
 	short			use_dma_rx;	/* use receive DMA? */
 	void __iomem		*regs;		/* virt. base address, if any */
+	struct at_dma_slave	*dma_tx_slave;
 	struct serial_rs485	rs485;		/* rs485 settings */
 };
 extern void __init at91_add_device_serial(void);
@@ -186,11 +192,13 @@
 extern void __init at91_add_device_ac97(struct ac97c_platform_data *data);
 
  /* ISI */
-extern void __init at91_add_device_isi(void);
+struct isi_platform_data;
+extern void __init at91_add_device_isi(struct isi_platform_data *data);
 
  /* Touchscreen Controller */
 struct at91_tsadcc_data {
 	unsigned int    adc_clock;
+	u8		filtering_average;
 	u8		pendet_debounce;
 	u8		ts_sample_hold_time;
 };
Index: linux-2.6.35/arch/arm/mach-at91/at91sam9x5_devices.c
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/at91sam9x5_devices.c	(revision 0)
+++ linux-2.6.35/arch/arm/mach-at91/at91sam9x5_devices.c	(revision 150)
@@ -0,0 +1,1781 @@
+/*
+ *  On-Chip devices setup code for the AT91SAM9x5 family
+ *
+ *  Copyright (C) 2010 Atmel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/i2c-gpio.h>
+#include <linux/atmel-mci.h>
+
+#include <linux/fb.h>
+#include <video/atmel_lcdc.h>
+#include <mach/atmel_hlcdfb.h>
+#include <media/atmel-isi.h>
+
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/cpu.h>
+#include <mach/at91sam9x5.h>
+#include <mach/at91sam9x5_matrix.h>
+#include <mach/at91sam9_smc.h>
+#include <mach/at_hdmac.h>
+#include <mach/atmel-mci.h>
+
+#include "generic.h"
+
+/* --------------------------------------------------------------------
+ *  HDMAC - AHB DMA Controller
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_AT_HDMAC) || defined(CONFIG_AT_HDMAC_MODULE)
+static u64 hdmac_dmamask = DMA_BIT_MASK(32);
+
+/* a single platform data for both DMA controllers as they share
+ * the same characteristics */
+static struct at_dma_platform_data atdma_pdata = {
+	.nr_channels	= 8,
+};
+
+static struct resource hdmac0_resources[] = {
+	[0] = {
+		.start	= AT91_BASE_SYS + AT91_DMA0,
+		.end	= AT91_BASE_SYS + AT91_DMA0 + SZ_512 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_DMA0,
+		.end	= AT91SAM9X5_ID_DMA0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at_hdmac0_device = {
+	.name		= "at_hdmac",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &hdmac_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &atdma_pdata,
+	},
+	.resource	= hdmac0_resources,
+	.num_resources	= ARRAY_SIZE(hdmac0_resources),
+};
+
+static struct resource hdmac1_resources[] = {
+	[0] = {
+		.start	= AT91_BASE_SYS + AT91_DMA1,
+		.end	= AT91_BASE_SYS + AT91_DMA1 + SZ_512 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_DMA1,
+		.end	= AT91SAM9X5_ID_DMA1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at_hdmac1_device = {
+	.name	= "at_hdmac",
+	.id	= 1,
+	.dev	= {
+			.dma_mask			= &hdmac_dmamask,
+			.coherent_dma_mask		= DMA_BIT_MASK(32),
+			.platform_data			= &atdma_pdata,
+	},
+	.resource	= hdmac1_resources,
+	.num_resources	= ARRAY_SIZE(hdmac1_resources),
+};
+
+void __init at91_add_device_hdmac(void)
+{
+	dma_cap_set(DMA_MEMCPY, atdma_pdata.cap_mask);
+	dma_cap_set(DMA_SLAVE, atdma_pdata.cap_mask);
+	dma_cap_set(DMA_CYCLIC, atdma_pdata.cap_mask);
+	at91_clock_associate("dma0_clk", &at_hdmac0_device.dev, "dma_clk");
+	platform_device_register(&at_hdmac0_device);
+	at91_clock_associate("dma1_clk", &at_hdmac1_device.dev, "dma_clk");
+	platform_device_register(&at_hdmac1_device);
+}
+#else
+void __init at91_add_device_hdmac(void) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  USB Host (OHCI)
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_USB_OHCI_HCD) || defined(CONFIG_USB_OHCI_HCD_MODULE)
+static u64 ohci_dmamask = DMA_BIT_MASK(32);
+static struct at91_usbh_data usbh_ohci_data;
+
+static struct resource usbh_ohci_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_OHCI_BASE,
+		.end	= AT91SAM9X5_OHCI_BASE + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_UHPHS,
+		.end	= AT91SAM9X5_ID_UHPHS,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91_usbh_ohci_device = {
+	.name		= "at91_ohci",
+	.id		= -1,
+	.dev		= {
+				.dma_mask		= &ohci_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &usbh_ohci_data,
+	},
+	.resource	= usbh_ohci_resources,
+	.num_resources	= ARRAY_SIZE(usbh_ohci_resources),
+};
+
+void __init at91_add_device_usbh_ohci(struct at91_usbh_data *data)
+{
+	int i;
+
+	if (!data)
+		return;
+
+	/* Enable VBus control for UHP ports */
+	for (i = 0; i < data->ports; i++) {
+		if (data->vbus_pin[i])
+			at91_set_gpio_output(data->vbus_pin[i], 0);
+	}
+
+	usbh_ohci_data = *data;
+	platform_device_register(&at91_usbh_ohci_device);
+}
+#else
+void __init at91_add_device_usbh_ohci(struct at91_usbh_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  USB Host HS (EHCI)
+ *  Needs an OHCI host for low and full speed management
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_USB_EHCI_HCD) || defined(CONFIG_USB_EHCI_HCD_MODULE)
+static u64 ehci_dmamask = DMA_BIT_MASK(32);
+static struct at91_usbh_data usbh_ehci_data;
+
+static struct resource usbh_ehci_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_EHCI_BASE,
+		.end	= AT91SAM9X5_EHCI_BASE + SZ_1M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_UHPHS,
+		.end	= AT91SAM9X5_ID_UHPHS,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91_usbh_ehci_device = {
+	.name		= "atmel-ehci",
+	.id		= -1,
+	.dev		= {
+				.dma_mask		= &ehci_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &usbh_ehci_data,
+	},
+	.resource	= usbh_ehci_resources,
+	.num_resources	= ARRAY_SIZE(usbh_ehci_resources),
+};
+
+void __init at91_add_device_usbh_ehci(struct at91_usbh_data *data)
+{
+	int i;
+
+	if (!data)
+		return;
+
+	/* Enable VBus control for UHP ports */
+	for (i = 0; i < data->ports; i++) {
+		if (data->vbus_pin[i])
+			at91_set_gpio_output(data->vbus_pin[i], 0);
+	}
+
+	usbh_ehci_data = *data;
+	at91_clock_associate("uhphs_clk", &at91_usbh_ehci_device.dev, "ehci_clk");
+	platform_device_register(&at91_usbh_ehci_device);
+}
+#else
+void __init at91_add_device_usbh_ehci(struct at91_usbh_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  USB HS Device (Gadget)
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_USB_GADGET_ATMEL_USBA) || defined(CONFIG_USB_GADGET_ATMEL_USBA_MODULE)
+static struct resource usba_udc_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_UDPHS_FIFO,
+		.end	= AT91SAM9X5_UDPHS_FIFO + SZ_512K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_BASE_UDPHS,
+		.end	= AT91SAM9X5_BASE_UDPHS + SZ_1K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= AT91SAM9X5_ID_UDPHS,
+		.end	= AT91SAM9X5_ID_UDPHS,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+#define EP(nam, idx, maxpkt, maxbk, dma, isoc)			\
+	[idx] = {						\
+		.name		= nam,				\
+		.index		= idx,				\
+		.fifo_size	= maxpkt,			\
+		.nr_banks	= maxbk,			\
+		.can_dma	= dma,				\
+		.can_isoc	= isoc,				\
+	}
+
+static struct usba_ep_data usba_udc_ep[] __initdata = {
+	EP("ep0", 0, 64, 1, 0, 0),
+	EP("ep1", 1, 1024, 2, 1, 1),
+	EP("ep2", 2, 1024, 2, 1, 1),
+	EP("ep3", 3, 1024, 3, 1, 0),
+	EP("ep4", 4, 1024, 3, 1, 0),
+	EP("ep5", 5, 1024, 3, 1, 1),
+	EP("ep6", 6, 1024, 3, 1, 1),
+};
+
+#undef EP
+
+/*
+ * pdata doesn't have room for any endpoints, so we need to
+ * append room for the ones we need right after it.
+ */
+static struct {
+	struct usba_platform_data pdata;
+	struct usba_ep_data ep[7];
+} usba_udc_data;
+
+static struct platform_device at91_usba_udc_device = {
+	.name		= "atmel_usba_udc",
+	.id		= -1,
+	.dev		= {
+				.platform_data	= &usba_udc_data.pdata,
+	},
+	.resource	= usba_udc_resources,
+	.num_resources	= ARRAY_SIZE(usba_udc_resources),
+};
+
+void __init at91_add_device_usba(struct usba_platform_data *data)
+{
+	usba_udc_data.pdata.vbus_pin = -EINVAL;
+	usba_udc_data.pdata.num_ep = ARRAY_SIZE(usba_udc_ep);
+	memcpy(usba_udc_data.ep, usba_udc_ep, sizeof(usba_udc_ep));
+
+	if (data && data->vbus_pin > 0) {
+		at91_set_gpio_input(data->vbus_pin, 0);
+		at91_set_deglitch(data->vbus_pin, 1);
+		usba_udc_data.pdata.vbus_pin = data->vbus_pin;
+	}
+
+	/* Pullup pin is handled internally by USB device peripheral */
+
+	/* Clocks */
+	at91_clock_associate("utmi_clk", &at91_usba_udc_device.dev, "hclk");
+	at91_clock_associate("udphs_clk", &at91_usba_udc_device.dev, "pclk");
+
+	platform_device_register(&at91_usba_udc_device);
+}
+#else
+void __init at91_add_device_usba(struct usba_platform_data *data) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  Ethernet
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_MACB) || defined(CONFIG_MACB_MODULE)
+static u64 eth0_dmamask = DMA_BIT_MASK(32);
+static struct at91_eth_data eth0_data;
+
+static struct resource eth0_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_EMAC0,
+		.end	= AT91SAM9X5_BASE_EMAC0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_EMAC0,
+		.end	= AT91SAM9X5_ID_EMAC0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_eth0_device = {
+	.name		= "macb",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &eth0_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &eth0_data,
+	},
+	.resource	= eth0_resources,
+	.num_resources	= ARRAY_SIZE(eth0_resources),
+};
+
+static u64 eth1_dmamask = DMA_BIT_MASK(32);
+static struct at91_eth_data eth1_data;
+
+static struct resource eth1_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_EMAC1,
+		.end	= AT91SAM9X5_BASE_EMAC1 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_EMAC1,
+		.end	= AT91SAM9X5_ID_EMAC1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_eth1_device = {
+	.name		= "macb",
+	.id		= 1,
+	.dev		= {
+				.dma_mask		= &eth1_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &eth1_data,
+	},
+	.resource	= eth1_resources,
+	.num_resources	= ARRAY_SIZE(eth1_resources),
+};
+
+void __init at91_add_device_eth(short eth_id, struct at91_eth_data *data)
+{
+	if (!data)
+		return;
+
+	if (cpu_is_at91sam9g15())
+		return;
+
+	if (eth_id && !cpu_is_at91sam9x25())
+		return;
+
+	if (data->phy_irq_pin) {
+		at91_set_gpio_input(data->phy_irq_pin, 0);
+		at91_set_deglitch(data->phy_irq_pin, 1);
+	}
+
+	if (eth_id == 0) {
+		/* Pins used for MII and RMII */
+		at91_set_A_periph(AT91_PIN_PB4,  0);	/* ETXCK_EREFCK */
+		at91_set_A_periph(AT91_PIN_PB3,  0);	/* ERXDV */
+		at91_set_A_periph(AT91_PIN_PB0,  0);	/* ERX0 */
+		at91_set_A_periph(AT91_PIN_PB1,  0);	/* ERX1 */
+		at91_set_A_periph(AT91_PIN_PB2,  0);	/* ERXER */
+		at91_set_A_periph(AT91_PIN_PB7,  0);	/* ETXEN */
+		at91_set_A_periph(AT91_PIN_PB9,  0);	/* ETX0 */
+		at91_set_A_periph(AT91_PIN_PB10, 0);	/* ETX1 */
+		at91_set_A_periph(AT91_PIN_PB5,  0);	/* EMDIO */
+		at91_set_A_periph(AT91_PIN_PB6,  0);	/* EMDC */
+
+		if (!data->is_rmii) {
+			at91_set_A_periph(AT91_PIN_PB16, 0);	/* ECRS */
+			at91_set_A_periph(AT91_PIN_PB17, 0);	/* ECOL */
+			at91_set_A_periph(AT91_PIN_PB13, 0);	/* ERX2 */
+			at91_set_A_periph(AT91_PIN_PB14, 0);	/* ERX3 */
+			at91_set_A_periph(AT91_PIN_PB15, 0);	/* ERXCK */
+			at91_set_A_periph(AT91_PIN_PB11, 0);	/* ETX2 */
+			at91_set_A_periph(AT91_PIN_PB12, 0);	/* ETX3 */
+			at91_set_A_periph(AT91_PIN_PB8,  0);	/* ETXER */
+		}
+
+		/* Clock */
+		at91_clock_associate("macb0_clk", &at91sam9x5_eth0_device.dev, "macb_clk");
+
+		eth0_data = *data;
+		platform_device_register(&at91sam9x5_eth0_device);
+	} else {
+		if (!data->is_rmii)
+			pr_warn("AT91: Only RMII available on interface %s %d.\n",
+				at91sam9x5_eth0_device.name, eth_id);
+
+		/* Pins used for RMII */
+		at91_set_B_periph(AT91_PIN_PC29,  0);	/* ETXCK_EREFCK */
+		at91_set_B_periph(AT91_PIN_PC28,  0);	/* ECRSDV */
+		at91_set_B_periph(AT91_PIN_PC20,  0);	/* ERX0 */
+		at91_set_B_periph(AT91_PIN_PC21,  0);	/* ERX1 */
+		at91_set_B_periph(AT91_PIN_PC16,  0);	/* ERXER */
+		at91_set_B_periph(AT91_PIN_PC27,  0);	/* ETXEN */
+		at91_set_B_periph(AT91_PIN_PC18,  0);	/* ETX0 */
+		at91_set_B_periph(AT91_PIN_PC19,  0);	/* ETX1 */
+		at91_set_B_periph(AT91_PIN_PC31,  0);	/* EMDIO */
+		at91_set_B_periph(AT91_PIN_PC30,  0);	/* EMDC */
+
+		/* Clock */
+		at91_clock_associate("macb1_clk", &at91sam9x5_eth1_device.dev, "macb_clk");
+
+		eth1_data = *data;
+		platform_device_register(&at91sam9x5_eth1_device);
+	}
+}
+#else
+void __init at91_add_device_eth(struct at91_eth_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  MMC / SD
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_MMC_ATMELMCI) || defined(CONFIG_MMC_ATMELMCI_MODULE)
+static u64 mmc_dmamask = DMA_BIT_MASK(32);
+static struct mci_platform_data mmc0_data, mmc1_data;
+
+static struct resource mmc0_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_MCI0,
+		.end	= AT91SAM9X5_BASE_MCI0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_MCI0,
+		.end	= AT91SAM9X5_ID_MCI0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_mmc0_device = {
+	.name		= "atmel_mci",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &mmc_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &mmc0_data,
+	},
+	.resource	= mmc0_resources,
+	.num_resources	= ARRAY_SIZE(mmc0_resources),
+};
+
+static struct resource mmc1_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_MCI1,
+		.end	= AT91SAM9X5_BASE_MCI1 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_MCI1,
+		.end	= AT91SAM9X5_ID_MCI1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_mmc1_device = {
+	.name		= "atmel_mci",
+	.id		= 1,
+	.dev		= {
+				.dma_mask		= &mmc_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &mmc1_data,
+	},
+	.resource	= mmc1_resources,
+	.num_resources	= ARRAY_SIZE(mmc1_resources),
+};
+
+/* Consider only one slot : slot 0 */
+void __init at91_add_device_mci(short mmc_id, struct mci_platform_data *data)
+{
+
+	if (!data)
+		return;
+
+	/* Must have at least one usable slot */
+	if (!data->slot[0].bus_width)
+		return;
+
+#if defined(CONFIG_AT_HDMAC) || defined(CONFIG_AT_HDMAC_MODULE)
+	{
+	struct at_dma_slave	*atslave;
+	struct mci_dma_data	*alt_atslave;
+
+	alt_atslave = kzalloc(sizeof(struct mci_dma_data), GFP_KERNEL);
+	atslave = &alt_atslave->sdata;
+
+	/* DMA slave channel configuration */
+	atslave->reg_width = AT_DMA_SLAVE_WIDTH_32BIT;
+	atslave->cfg = ATC_FIFOCFG_HALFFIFO
+			| ATC_SRC_H2SEL_HW | ATC_DST_H2SEL_HW;
+	atslave->ctrla = ATC_SCSIZE_16 | ATC_DCSIZE_16;
+	if (mmc_id == 0) {	/* MCI0 */
+		atslave->cfg |= ATC_SRC_PER(AT_DMA_ID_MCI0)
+			      | ATC_DST_PER(AT_DMA_ID_MCI0);
+		atslave->dma_dev = &at_hdmac0_device.dev;
+
+	} else {		/* MCI1 */
+		atslave->cfg |= ATC_SRC_PER(AT_DMA_ID_MCI1)
+			      | ATC_DST_PER(AT_DMA_ID_MCI1);
+		atslave->dma_dev = &at_hdmac1_device.dev;
+	}
+
+	data->dma_slave = alt_atslave;
+	}
+#endif
+
+	/* input/irq */
+	if (data->slot[0].detect_pin) {
+		at91_set_gpio_input(data->slot[0].detect_pin, 1);
+		at91_set_deglitch(data->slot[0].detect_pin, 1);
+	}
+	if (data->slot[0].wp_pin)
+		at91_set_gpio_input(data->slot[0].wp_pin, 1);
+
+	if (mmc_id == 0) {		/* MCI0 */
+
+		/* CLK */
+		at91_set_A_periph(AT91_PIN_PA17, 0);
+
+		/* CMD */
+		at91_set_A_periph(AT91_PIN_PA16, 1);
+
+		/* DAT0, maybe DAT1..DAT3 */
+		at91_set_A_periph(AT91_PIN_PA15, 1);
+		if (data->slot[0].bus_width == 4) {
+			at91_set_A_periph(AT91_PIN_PA18, 1);
+			at91_set_A_periph(AT91_PIN_PA19, 1);
+			at91_set_A_periph(AT91_PIN_PA20, 1);
+		}
+
+		mmc0_data = *data;
+		at91_clock_associate("mci0_clk", &at91sam9x5_mmc0_device.dev, "mci_clk");
+		platform_device_register(&at91sam9x5_mmc0_device);
+
+	} else {			/* MCI1 */
+
+		/* CLK */
+		at91_set_B_periph(AT91_PIN_PA13, 0);
+
+		/* CMD */
+		at91_set_B_periph(AT91_PIN_PA12, 1);
+
+		/* DAT0, maybe DAT1..DAT3 */
+		at91_set_B_periph(AT91_PIN_PA11, 1);
+		if (data->slot[0].bus_width == 4) {
+			at91_set_B_periph(AT91_PIN_PA2, 1);
+			at91_set_B_periph(AT91_PIN_PA3, 1);
+			at91_set_B_periph(AT91_PIN_PA4, 1);
+		}
+
+		mmc1_data = *data;
+		at91_clock_associate("mci1_clk", &at91sam9x5_mmc1_device.dev, "mci_clk");
+		platform_device_register(&at91sam9x5_mmc1_device);
+
+	}
+}
+#else
+void __init at91_add_device_mci(short mmc_id, struct mci_platform_data *data) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  NAND / SmartMedia
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_MTD_NAND_ATMEL) || defined(CONFIG_MTD_NAND_ATMEL_MODULE)
+static struct atmel_nand_data nand_data;
+
+#define NAND_BASE	AT91_CHIPSELECT_3
+
+static struct resource nand_resources[] = {
+	[0] = {
+		.start	= NAND_BASE,
+		.end	= NAND_BASE + SZ_256M - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91_BASE_SYS + AT91_PMECC,
+		.end	= AT91_BASE_SYS + AT91_PMECC + SZ_512 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[2] = {
+		.start	= AT91_BASE_SYS + AT91_PMERRLOC,
+		.end	= AT91_BASE_SYS + AT91_PMERRLOC + SZ_512 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[3] = {
+		.start	= AT91SAM9X5_ROM_BASE,
+		.end	= AT91SAM9X5_ROM_BASE + AT91SAM9X5_ROM_SIZE,
+		.flags	= IORESOURCE_MEM,
+	}
+};
+
+static struct platform_device at91sam9x5_nand_device = {
+	.name		= "atmel_nand",
+	.id		= -1,
+	.dev		= {
+				.platform_data	= &nand_data,
+	},
+	.resource	= nand_resources,
+	.num_resources	= ARRAY_SIZE(nand_resources),
+};
+
+void __init at91_add_device_nand(struct atmel_nand_data *data)
+{
+	unsigned long csa;
+
+	if (!data)
+		return;
+
+	csa = at91_sys_read(AT91_MATRIX_EBICSA);
+	csa |= AT91_MATRIX_EBI_CS3A_SMC_NANDFLASH;
+
+	if (!data->bus_on_d0) {
+		csa |= AT91_MATRIX_NFD0_ON_D16;
+	       if (!data->bus_width_16)
+			csa |= AT91_MATRIX_MP_ON;
+	} else
+		csa &= ~(AT91_MATRIX_NFD0_ON_D16 | AT91_MATRIX_MP_ON);
+
+	at91_sys_write(AT91_MATRIX_EBICSA, csa);
+
+	/* enable pin */
+	if (data->enable_pin)
+		at91_set_gpio_output(data->enable_pin, 1);
+
+	/* ready/busy pin */
+	if (data->rdy_pin)
+		at91_set_gpio_input(data->rdy_pin, 1);
+
+	/* card detect pin */
+	if (data->det_pin)
+		at91_set_gpio_input(data->det_pin, 1);
+
+	/* configure NANDOE */
+	at91_set_A_periph(AT91_PIN_PD0, 1);
+	/* configure NANDWE */
+	at91_set_A_periph(AT91_PIN_PD1, 1);
+	/* configure ALE */
+	at91_set_A_periph(AT91_PIN_PD2, 1);
+	/* configure CLE */
+	at91_set_A_periph(AT91_PIN_PD3, 1);
+
+	/* configure multiplexed pins for D16~D31 */
+	if (!data->bus_on_d0) {
+		at91_set_A_periph(AT91_PIN_PD6, 1);
+		at91_set_A_periph(AT91_PIN_PD7, 1);
+		at91_set_A_periph(AT91_PIN_PD8, 1);
+		at91_set_A_periph(AT91_PIN_PD9, 1);
+		at91_set_A_periph(AT91_PIN_PD10, 1);
+		at91_set_A_periph(AT91_PIN_PD11, 1);
+		at91_set_A_periph(AT91_PIN_PD12, 1);
+		at91_set_A_periph(AT91_PIN_PD13, 1);
+
+		if (data->bus_width_16) {
+			at91_set_A_periph(AT91_PIN_PD14, 1);
+			at91_set_A_periph(AT91_PIN_PD15, 1);
+			at91_set_A_periph(AT91_PIN_PD16, 1);
+			at91_set_A_periph(AT91_PIN_PD17, 1);
+			at91_set_A_periph(AT91_PIN_PD18, 1);
+			at91_set_A_periph(AT91_PIN_PD19, 1);
+			at91_set_A_periph(AT91_PIN_PD20, 1);
+			at91_set_A_periph(AT91_PIN_PD21, 1);
+		}
+
+	}
+
+	nand_data = *data;
+	platform_device_register(&at91sam9x5_nand_device);
+}
+#else
+void __init at91_add_device_nand(struct atmel_nand_data *data) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  TWI (i2c)
+ * -------------------------------------------------------------------- */
+
+/*
+ * Prefer the GPIO code since the TWI controller isn't robust
+ * (gets overruns and underruns under load) and can only issue
+ * repeated STARTs in one scenario (the driver doesn't yet handle them).
+ */
+#if defined(CONFIG_I2C_GPIO) || defined(CONFIG_I2C_GPIO_MODULE)
+static struct i2c_gpio_platform_data pdata_i2c0 = {
+	.sda_pin		= AT91_PIN_PA30,
+	.sda_is_open_drain	= 1,
+	.scl_pin		= AT91_PIN_PA31,
+	.scl_is_open_drain	= 1,
+	.udelay			= 2,		/* ~100 kHz */
+};
+
+static struct platform_device at91sam9x5_twi0_device = {
+	.name			= "i2c-gpio",
+	.id			= 0,
+	.dev.platform_data	= &pdata_i2c0,
+};
+
+void __init at91_add_device_i2c(short i2c_id, struct i2c_board_info *devices, int nr_devices)
+{
+	i2c_register_board_info(i2c_id, devices, nr_devices);
+
+	if (i2c_id == 0) {
+		at91_set_GPIO_periph(AT91_PIN_PA30, 1);		/* TWD (SDA) */
+		at91_set_multi_drive(AT91_PIN_PA30, 1);
+
+		at91_set_GPIO_periph(AT91_PIN_PA31, 1);		/* TWCK (SCL) */
+		at91_set_multi_drive(AT91_PIN_PA31, 1);
+
+		platform_device_register(&at91sam9x5_twi0_device);
+	}
+}
+
+#elif defined(CONFIG_I2C_AT91) || defined(CONFIG_I2C_AT91_MODULE)
+static struct resource twi0_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_TWI0,
+		.end	= AT91SAM9X5_BASE_TWI0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_TWI0,
+		.end	= AT91SAM9X5_ID_TWI0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_twi0_device = {
+	.name		= "at91_i2c",
+	.id		= 0,
+	.resource	= twi0_resources,
+	.num_resources	= ARRAY_SIZE(twi0_resources),
+};
+
+void __init at91_add_device_i2c(short i2c_id, struct i2c_board_info *devices, int nr_devices)
+{
+	i2c_register_board_info(i2c_id, devices, nr_devices);
+
+	/* pins used for TWI interface */
+	if (i2c_id == 0) {
+		at91_set_A_periph(AT91_PIN_PA30, 0);		/* TWD */
+		at91_set_multi_drive(AT91_PIN_PA30, 1);
+
+		at91_set_A_periph(AT91_PIN_PA31, 0);		/* TWCK */
+		at91_set_multi_drive(AT91_PIN_PA31, 1);
+
+		platform_device_register(&at91sam9x5_twi0_device);
+	}
+}
+#else
+void __init at91_add_device_i2c(short i2c_id, struct i2c_board_info *devices, int nr_devices) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  SPI
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_SPI_ATMEL) || defined(CONFIG_SPI_ATMEL_MODULE)
+static u64 spi_dmamask = DMA_BIT_MASK(32);
+static struct at_dma_slave spi0_sdata, spi1_sdata;
+
+static struct resource spi0_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_SPI0,
+		.end	= AT91SAM9X5_BASE_SPI0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_SPI0,
+		.end	= AT91SAM9X5_ID_SPI0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_spi0_device = {
+	.name		= "atmel_spi",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &spi_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &spi0_sdata,
+	},
+	.resource	= spi0_resources,
+	.num_resources	= ARRAY_SIZE(spi0_resources),
+};
+
+static const unsigned spi0_standard_cs[4] = { AT91_PIN_PA14, AT91_PIN_PA7, AT91_PIN_PA1, AT91_PIN_PB3 };
+
+static struct resource spi1_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_SPI1,
+		.end	= AT91SAM9X5_BASE_SPI1 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_SPI1,
+		.end	= AT91SAM9X5_ID_SPI1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_spi1_device = {
+	.name		= "atmel_spi",
+	.id		= 1,
+	.dev		= {
+				.dma_mask		= &spi_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &spi1_sdata,
+	},
+	.resource	= spi1_resources,
+	.num_resources	= ARRAY_SIZE(spi1_resources),
+};
+
+static const unsigned spi1_standard_cs[4] = { AT91_PIN_PA8, AT91_PIN_PA0, AT91_PIN_PA31, AT91_PIN_PA30 };
+
+void __init at91_add_device_spi(struct spi_board_info *devices, int nr_devices)
+{
+	int i;
+	unsigned long cs_pin;
+	short enable_spi0 = 0;
+	short enable_spi1 = 0;
+#if defined(CONFIG_AT_HDMAC) || defined(CONFIG_AT_HDMAC_MODULE)
+	struct at_dma_slave *atslave;
+#endif
+
+	/* Choose SPI chip-selects */
+	for (i = 0; i < nr_devices; i++) {
+		if (devices[i].controller_data)
+			cs_pin = (unsigned long) devices[i].controller_data;
+		else if (devices[i].bus_num == 0)
+			cs_pin = spi0_standard_cs[devices[i].chip_select];
+		else
+			cs_pin = spi1_standard_cs[devices[i].chip_select];
+
+		if (devices[i].bus_num == 0)
+			enable_spi0 = 1;
+		else
+			enable_spi1 = 1;
+
+		/* enable chip-select pin */
+		at91_set_gpio_output(cs_pin, 1);
+
+		/* pass chip-select pin to driver */
+		devices[i].controller_data = (void *) cs_pin;
+	}
+
+	spi_register_board_info(devices, nr_devices);
+
+
+	/* Configure SPI bus(es) */
+	if (enable_spi0) {
+		at91_set_A_periph(AT91_PIN_PA11, 0);	/* SPI0_MISO */
+		at91_set_A_periph(AT91_PIN_PA12, 0);	/* SPI0_MOSI */
+		at91_set_A_periph(AT91_PIN_PA13, 0);	/* SPI0_SPCK */
+
+#if defined(CONFIG_AT_HDMAC) || defined(CONFIG_AT_HDMAC_MODULE)
+		atslave = at91sam9x5_spi0_device.dev.platform_data;
+
+		/* DMA slave channel configuration */
+		atslave->dma_dev = &at_hdmac0_device.dev;
+		atslave->reg_width = AT_DMA_SLAVE_WIDTH_8BIT; /* or 16bits??????? */
+		atslave->cfg = ATC_FIFOCFG_HALFFIFO
+				| ATC_SRC_H2SEL_HW | ATC_DST_H2SEL_HW
+				| ATC_SRC_PER(AT_DMA_ID_SPI0_RX)
+				| ATC_DST_PER(AT_DMA_ID_SPI0_TX);
+		/*atslave->ctrla = ATC_SCSIZE_16 | ATC_DCSIZE_16;*/ /* Chunk size to 0????? */
+#endif
+
+		at91_clock_associate("spi0_clk", &at91sam9x5_spi0_device.dev, "spi_clk");
+		platform_device_register(&at91sam9x5_spi0_device);
+	}
+	if (enable_spi1) {
+		at91_set_B_periph(AT91_PIN_PA21, 0);	/* SPI1_MISO */
+		at91_set_B_periph(AT91_PIN_PA22, 0);	/* SPI1_MOSI */
+		at91_set_B_periph(AT91_PIN_PA23, 0);	/* SPI1_SPCK */
+
+#if defined(CONFIG_AT_HDMAC) || defined(CONFIG_AT_HDMAC_MODULE)
+		atslave = at91sam9x5_spi1_device.dev.platform_data;
+
+		/* DMA slave channel configuration */
+		atslave->dma_dev = &at_hdmac1_device.dev;
+		atslave->reg_width = AT_DMA_SLAVE_WIDTH_8BIT; /* or 16bits??????? */
+		atslave->cfg = ATC_FIFOCFG_HALFFIFO
+				| ATC_SRC_H2SEL_HW | ATC_DST_H2SEL_HW
+				| ATC_SRC_PER(AT_DMA_ID_SPI1_RX)
+				| ATC_DST_PER(AT_DMA_ID_SPI1_TX);
+		/*atslave->ctrla = ATC_SCSIZE_16 | ATC_DCSIZE_16;*/ /* Chunk size to 0????? */
+#endif
+
+		at91_clock_associate("spi1_clk", &at91sam9x5_spi1_device.dev, "spi_clk");
+		platform_device_register(&at91sam9x5_spi1_device);
+	}
+}
+#else
+void __init at91_add_device_spi(struct spi_board_info *devices, int nr_devices) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  Image Sensor Interface
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_VIDEO_ATMEL_ISI) || defined(CONFIG_VIDEO_ATMEL_ISI_MODULE)
+static u64 isi_dmamask = DMA_BIT_MASK(32);
+static struct isi_platform_data isi_data;
+
+struct resource isi_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_ISI,
+		.end	= AT91SAM9X5_BASE_ISI + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_ISI,
+		.end	= AT91SAM9X5_ID_ISI,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_isi_device = {
+	.name		= "atmel_isi",
+	.id		= -1,
+	.dev		= {
+			.dma_mask		= &isi_dmamask,
+			.coherent_dma_mask	= DMA_BIT_MASK(32),
+			.platform_data		= &isi_data,
+	},
+	.resource	= isi_resources,
+	.num_resources	= ARRAY_SIZE(isi_resources),
+};
+
+void __init at91_add_device_isi(struct isi_platform_data *data)
+{
+	struct platform_device *pdev;
+
+	if (!data)
+		return;
+
+	at91_set_B_periph(AT91_PIN_PC0, 0);	/* ISI_D0 */
+	at91_set_B_periph(AT91_PIN_PC1, 0);	/* ISI_D1 */
+	at91_set_B_periph(AT91_PIN_PC2, 0);	/* ISI_D2 */
+	at91_set_B_periph(AT91_PIN_PC3, 0);	/* ISI_D3 */
+	at91_set_B_periph(AT91_PIN_PC4, 0);	/* ISI_D4 */
+	at91_set_B_periph(AT91_PIN_PC5, 0);	/* ISI_D5 */
+	at91_set_B_periph(AT91_PIN_PC6, 0);	/* ISI_D6 */
+	at91_set_B_periph(AT91_PIN_PC7, 0);	/* ISI_D7 */
+	at91_set_B_periph(AT91_PIN_PC12, 0);	/* ISI_PCK */
+	at91_set_B_periph(AT91_PIN_PC14, 0);	/* ISI_HSYNC */
+	at91_set_B_periph(AT91_PIN_PC13, 0);	/* ISI_VSYNC */
+	at91_set_C_periph(AT91_PIN_PC15, 0);	/* ISI_MCK (using PCK0 as clock) */
+	at91_set_B_periph(AT91_PIN_PC8, 0);	/* ISI_PD8 */
+	at91_set_B_periph(AT91_PIN_PC9, 0);	/* ISI_PD9 */
+	at91_set_B_periph(AT91_PIN_PC10, 0);	/* ISI_PD10 */
+	at91_set_B_periph(AT91_PIN_PC11, 0);	/* ISI_PD11 */
+
+	pdev = &at91sam9x5_isi_device;
+
+	isi_data = *data;
+	platform_device_register(pdev);
+}
+#else
+void __init at91_add_device_isi(struct isi_platform_data *data) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  LCD Controller
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static u64 lcdc_dmamask = DMA_BIT_MASK(32);
+static struct atmel_lcdfb_info lcdc_data;
+
+static struct resource lcdc_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_LCDC,
+		.end	= AT91SAM9X5_BASE_LCDC + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_LCDC,
+		.end	= AT91SAM9X5_ID_LCDC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91_lcdc_device = {
+	.name		= "atmel_lcdfb",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &lcdc_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &lcdc_data,
+	},
+	.resource	= lcdc_resources,
+	.num_resources	= ARRAY_SIZE(lcdc_resources),
+};
+
+void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data)
+{
+	if (!data)
+		return;
+
+	at91_set_A_periph(AT91_PIN_PC26, 0);	/* LCDPWM */
+
+	at91_set_A_periph(AT91_PIN_PC27, 0);	/* LCDVSYNC */
+	at91_set_A_periph(AT91_PIN_PC28, 0);	/* LCDHSYNC */
+
+	at91_set_A_periph(AT91_PIN_PC24, 0);	/* LCDDISP */
+	at91_set_A_periph(AT91_PIN_PC29, 0);	/* LCDDEN */
+	at91_set_A_periph(AT91_PIN_PC30, 0);	/* LCDPCK */
+
+	at91_set_A_periph(AT91_PIN_PC0, 0);	/* LCDD0 */
+	at91_set_A_periph(AT91_PIN_PC1, 0);	/* LCDD1 */
+	at91_set_A_periph(AT91_PIN_PC2, 0);	/* LCDD2 */
+	at91_set_A_periph(AT91_PIN_PC3, 0);	/* LCDD3 */
+	at91_set_A_periph(AT91_PIN_PC4, 0);	/* LCDD4 */
+	at91_set_A_periph(AT91_PIN_PC5, 0);	/* LCDD5 */
+	at91_set_A_periph(AT91_PIN_PC6, 0);	/* LCDD6 */
+	at91_set_A_periph(AT91_PIN_PC7, 0);	/* LCDD7 */
+	at91_set_A_periph(AT91_PIN_PC8, 0);	/* LCDD8 */
+	at91_set_A_periph(AT91_PIN_PC9, 0);	/* LCDD9 */
+	at91_set_A_periph(AT91_PIN_PC10, 0);	/* LCDD10 */
+	at91_set_A_periph(AT91_PIN_PC11, 0);	/* LCDD11 */
+	at91_set_A_periph(AT91_PIN_PC12, 0);	/* LCDD12 */
+	at91_set_A_periph(AT91_PIN_PC13, 0);	/* LCDD13 */
+	at91_set_A_periph(AT91_PIN_PC14, 0);	/* LCDD14 */
+	at91_set_A_periph(AT91_PIN_PC15, 0);	/* LCDD15 */
+	at91_set_A_periph(AT91_PIN_PC16, 0);	/* LCDD16 */
+	at91_set_A_periph(AT91_PIN_PC17, 0);	/* LCDD17 */
+	at91_set_A_periph(AT91_PIN_PC18, 0);	/* LCDD18 */
+	at91_set_A_periph(AT91_PIN_PC19, 0);	/* LCDD19 */
+	at91_set_A_periph(AT91_PIN_PC20, 0);	/* LCDD20 */
+	at91_set_A_periph(AT91_PIN_PC21, 0);	/* LCDD21 */
+	at91_set_A_periph(AT91_PIN_PC22, 0);	/* LCDD22 */
+	at91_set_A_periph(AT91_PIN_PC23, 0);	/* LCDD23 */
+
+	lcdc_data = *data;
+	platform_device_register(&at91_lcdc_device);
+}
+#else
+void __init at91_add_device_lcdc(struct atmel_lcdfb_info *data) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  Timer/Counter block
+ * -------------------------------------------------------------------- */
+
+#ifdef CONFIG_ATMEL_TCLIB
+static struct resource tcb0_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_TCB0,
+		.end	= AT91SAM9X5_BASE_TCB0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_TCB,
+		.end	= AT91SAM9X5_ID_TCB,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_tcb0_device = {
+	.name		= "atmel_tcb",
+	.id		= 0,
+	.resource	= tcb0_resources,
+	.num_resources	= ARRAY_SIZE(tcb0_resources),
+};
+
+/* TCB1 begins with TC3 */
+static struct resource tcb1_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_TCB1,
+		.end	= AT91SAM9X5_BASE_TCB1 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_TCB,
+		.end	= AT91SAM9X5_ID_TCB,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_tcb1_device = {
+	.name		= "atmel_tcb",
+	.id		= 1,
+	.resource	= tcb1_resources,
+	.num_resources	= ARRAY_SIZE(tcb1_resources),
+};
+
+static void __init at91_add_device_tc(void)
+{
+	/* this chip has one clock and irq for all six TC channels */
+	at91_clock_associate("tcb0_clk", &at91sam9x5_tcb0_device.dev, "t0_clk");
+	platform_device_register(&at91sam9x5_tcb0_device);
+	at91_clock_associate("tcb1_clk", &at91sam9x5_tcb1_device.dev, "t0_clk");
+	platform_device_register(&at91sam9x5_tcb1_device);
+}
+#else
+static void __init at91_add_device_tc(void) { }
+#endif
+
+/* --------------------------------------------------------------------
+ *  RTC
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_RTC_DRV_AT91RM9200) || defined(CONFIG_RTC_DRV_AT91RM9200_MODULE)
+static struct platform_device at91sam9x5_rtc_device = {
+	.name		= "at91_rtc",
+	.id		= -1,
+	.num_resources	= 0,
+};
+
+static void __init at91_add_device_rtc(void)
+{
+	platform_device_register(&at91sam9x5_rtc_device);
+}
+#else
+static void __init at91_add_device_rtc(void) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  Touchscreen
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_TOUCHSCREEN_ATMEL_TSADCC) || defined(CONFIG_TOUCHSCREEN_ATMEL_TSADCC_MODULE)
+static u64 tsadcc_dmamask = DMA_BIT_MASK(32);
+static struct at91_tsadcc_data tsadcc_data;
+
+static struct resource tsadcc_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_ADC,
+		.end	= AT91SAM9X5_BASE_ADC + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_ADC,
+		.end	= AT91SAM9X5_ID_ADC,
+		.flags	= IORESOURCE_IRQ,
+	}
+};
+
+static struct platform_device at91sam9x5_tsadcc_device = {
+	.name		= "atmel_tsadcc",
+	.id		= -1,
+	.dev		= {
+				.dma_mask		= &tsadcc_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &tsadcc_data,
+	},
+	.resource	= tsadcc_resources,
+	.num_resources	= ARRAY_SIZE(tsadcc_resources),
+};
+
+void __init at91_add_device_tsadcc(struct at91_tsadcc_data *data)
+{
+	if (!data)
+		return;
+
+	/* In 9x5ek, using default pins for touch screen. */
+
+	tsadcc_data = *data;
+	at91_clock_associate("adc_clk", &at91sam9x5_tsadcc_device.dev, "tsc_clk");
+	platform_device_register(&at91sam9x5_tsadcc_device);
+}
+#else
+void __init at91_add_device_tsadcc(struct at91_tsadcc_data *data) {}
+#endif
+
+/* --------------------------------------------------------------------
+ *  Watchdog
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_AT91SAM9X_WATCHDOG) || defined(CONFIG_AT91SAM9X_WATCHDOG_MODULE)
+static struct platform_device at91sam9x5_wdt_device = {
+	.name		= "at91_wdt",
+	.id		= -1,
+	.num_resources	= 0,
+};
+
+static void __init at91_add_device_watchdog(void)
+{
+	platform_device_register(&at91sam9x5_wdt_device);
+}
+#else
+static void __init at91_add_device_watchdog(void) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  PWM
+ * --------------------------------------------------------------------*/
+
+#if defined(CONFIG_ATMEL_PWM) || defined(CONFIG_ATMEL_PWM_MODULE)
+static u32 pwm_mask;
+
+static struct resource pwm_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_PWMC,
+		.end	= AT91SAM9X5_BASE_PWMC + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_PWMC,
+		.end	= AT91SAM9X5_ID_PWMC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_pwm_device = {
+	.name	= "atmel_pwm",
+	.id	= -1,
+	.dev	= {
+		.platform_data		= &pwm_mask,
+	},
+	.resource	= pwm_resources,
+	.num_resources	= ARRAY_SIZE(pwm_resources),
+};
+
+void __init at91_add_device_pwm(u32 mask)
+{
+	if (mask & (1 << AT91_PWM0))
+		at91_set_B_periph(AT91_PIN_PB11, 1);	/* enable PWM0 */
+
+	if (mask & (1 << AT91_PWM1))
+		at91_set_B_periph(AT91_PIN_PB12, 1);	/* enable PWM1 */
+
+	if (mask & (1 << AT91_PWM2))
+		at91_set_B_periph(AT91_PIN_PB13, 1);	/* enable PWM2 */
+
+	if (mask & (1 << AT91_PWM3))
+		at91_set_B_periph(AT91_PIN_PB14, 1);	/* enable PWM3 */
+
+	pwm_mask = mask;
+
+	platform_device_register(&at91sam9x5_pwm_device);
+}
+#else
+void __init at91_add_device_pwm(u32 mask) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  SSC -- Synchronous Serial Controller
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_ATMEL_SSC) || defined(CONFIG_ATMEL_SSC_MODULE)
+static u64 ssc_dmamask = DMA_BIT_MASK(32);
+static struct at_dma_slave ssc_sdata;
+
+static struct resource ssc_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_SSC,
+		.end	= AT91SAM9X5_BASE_SSC + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_SSC,
+		.end	= AT91SAM9X5_ID_SSC,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct platform_device at91sam9x5_ssc_device = {
+	.name	= "ssc",
+	.id	= 0,
+	.dev	= {
+		.dma_mask		= &ssc_dmamask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &ssc_sdata,
+	},
+	.resource	= ssc_resources,
+	.num_resources	= ARRAY_SIZE(ssc_resources),
+};
+
+static inline void configure_ssc_pins(unsigned pins)
+{
+	if (pins & ATMEL_SSC_TF)
+		at91_set_B_periph(AT91_PIN_PA25, 1);
+	if (pins & ATMEL_SSC_TK)
+		at91_set_B_periph(AT91_PIN_PA24, 1);
+	if (pins & ATMEL_SSC_TD)
+		at91_set_B_periph(AT91_PIN_PA26, 1);
+	if (pins & ATMEL_SSC_RD)
+		at91_set_B_periph(AT91_PIN_PA27, 1);
+	if (pins & ATMEL_SSC_RK)
+		at91_set_B_periph(AT91_PIN_PA28, 1);
+	if (pins & ATMEL_SSC_RF)
+		at91_set_B_periph(AT91_PIN_PA29, 1);
+}
+
+/*
+ * SSC controllers are accessed through library code, instead of any
+ * kind of all-singing/all-dancing driver.  For example one could be
+ * used by a particular I2S audio codec's driver, while another one
+ * on the same system might be used by a custom data capture driver.
+ */
+void __init at91_add_device_ssc(unsigned id, unsigned pins)
+{
+	struct platform_device *pdev;
+
+	/*
+	 * NOTE: caller is responsible for passing information matching
+	 * "pins" to whatever will be using each particular controller.
+	 */
+	if (id == AT91SAM9X5_ID_SSC) {
+#if defined(CONFIG_AT_HDMAC) || defined(CONFIG_AT_HDMAC_MODULE)
+		struct at_dma_slave *atslave;
+
+		atslave = at91sam9x5_ssc_device.dev.platform_data;
+
+		/* DMA slave channel configuration */
+		atslave->dma_dev = &at_hdmac0_device.dev;
+		atslave->reg_width = AT_DMA_SLAVE_WIDTH_16BIT;
+		atslave->cfg = ATC_FIFOCFG_HALFFIFO
+				| ATC_SRC_H2SEL_HW | ATC_DST_H2SEL_HW
+				| ATC_SRC_PER(AT_DMA_ID_SSC_RX)
+				| ATC_DST_PER(AT_DMA_ID_SSC_TX);
+#endif
+
+		pdev = &at91sam9x5_ssc_device;
+		configure_ssc_pins(pins);
+		at91_clock_associate("ssc_clk", &pdev->dev, "pclk");
+	}
+	else
+		return;
+
+	platform_device_register(pdev);
+}
+
+#else
+void __init at91_add_device_ssc(unsigned id, unsigned pins) {}
+#endif
+
+
+/* --------------------------------------------------------------------
+ *  UART
+ * -------------------------------------------------------------------- */
+
+#if defined(CONFIG_SERIAL_ATMEL)
+static struct resource dbgu_resources[] = {
+	[0] = {
+		.start	= AT91_VA_BASE_SYS + AT91_DBGU,
+		.end	= AT91_VA_BASE_SYS + AT91_DBGU + SZ_512 - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91_ID_SYS,
+		.end	= AT91_ID_SYS,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data dbgu_data = {
+	.use_dma_tx	= 0,
+	.use_dma_rx	= 0,
+	.regs		= (void __iomem *)(AT91_VA_BASE_SYS + AT91_DBGU),
+};
+
+static u64 dbgu_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device at91sam9x5_dbgu_device = {
+	.name		= "atmel_usart",
+	.id		= 0,
+	.dev		= {
+				.dma_mask		= &dbgu_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &dbgu_data,
+	},
+	.resource	= dbgu_resources,
+	.num_resources	= ARRAY_SIZE(dbgu_resources),
+};
+
+static inline void configure_dbgu_pins(void)
+{
+	at91_set_A_periph(AT91_PIN_PA9, 0);		/* DRXD */
+	at91_set_A_periph(AT91_PIN_PA10, 1);		/* DTXD */
+}
+
+static struct resource usart0_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_USART0,
+		.end	= AT91SAM9X5_BASE_USART0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_USART0,
+		.end	= AT91SAM9X5_ID_USART0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data usart0_data = {
+	.use_dma_tx	= 1,
+	.use_dma_rx	= 0,				/* doesn't support */
+};
+
+static u64 usart0_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device at91sam9x5_usart0_device = {
+	.name		= "atmel_usart",
+	.id		= 1,
+	.dev		= {
+				.dma_mask		= &usart0_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &usart0_data,
+	},
+	.resource	= usart0_resources,
+	.num_resources	= ARRAY_SIZE(usart0_resources),
+};
+
+static inline void configure_usart0_pins(unsigned pins)
+{
+	at91_set_A_periph(AT91_PIN_PA0, 1);		/* TXD0 */
+	at91_set_A_periph(AT91_PIN_PA1, 0);		/* RXD0 */
+
+	if (pins & ATMEL_UART_RTS)
+		at91_set_A_periph(AT91_PIN_PA2, 0);	/* RTS0 */
+	if (pins & ATMEL_UART_CTS)
+		at91_set_A_periph(AT91_PIN_PA3, 0);	/* CTS0 */
+}
+
+
+static struct resource usart1_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_USART1,
+		.end	= AT91SAM9X5_BASE_USART1 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_USART1,
+		.end	= AT91SAM9X5_ID_USART1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data usart1_data = {
+	.use_dma_tx	= 1,
+	.use_dma_rx	= 1,
+};
+
+static u64 usart1_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device at91sam9x5_usart1_device = {
+	.name		= "atmel_usart",
+	.id		= 2,
+	.dev		= {
+				.dma_mask		= &usart1_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &usart1_data,
+	},
+	.resource	= usart1_resources,
+	.num_resources	= ARRAY_SIZE(usart1_resources),
+};
+
+static inline void configure_usart1_pins(unsigned pins)
+{
+	at91_set_A_periph(AT91_PIN_PA5, 1);		/* TXD1 */
+	at91_set_A_periph(AT91_PIN_PA6, 0);		/* RXD1 */
+
+	if (pins & ATMEL_UART_RTS)
+		at91_set_C_periph(AT91_PIN_PC27, 0);	/* RTS1 */
+	if (pins & ATMEL_UART_CTS)
+		at91_set_C_periph(AT91_PIN_PC28, 0);	/* CTS1 */
+}
+
+static struct resource usart2_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_USART2,
+		.end	= AT91SAM9X5_BASE_USART2 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_USART2,
+		.end	= AT91SAM9X5_ID_USART2,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data usart2_data = {
+	.use_dma_tx	= 1,
+	.use_dma_rx	= 1,
+};
+
+static u64 usart2_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device at91sam9x5_usart2_device = {
+	.name		= "atmel_usart",
+	.id		= 3,
+	.dev		= {
+				.dma_mask		= &usart2_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &usart2_data,
+	},
+	.resource	= usart2_resources,
+	.num_resources	= ARRAY_SIZE(usart2_resources),
+};
+
+static inline void configure_usart2_pins(unsigned pins)
+{
+	at91_set_A_periph(AT91_PIN_PA7, 1);		/* TXD2 */
+	at91_set_A_periph(AT91_PIN_PA8, 0);		/* RXD2 */
+
+	if (pins & ATMEL_UART_RTS)
+		at91_set_B_periph(AT91_PIN_PB0, 0);	/* RTS2 */
+	if (pins & ATMEL_UART_CTS)
+		at91_set_B_periph(AT91_PIN_PB1, 0);	/* CTS2 */
+}
+
+static struct resource usart3_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_USART3,
+		.end	= AT91SAM9X5_BASE_USART3 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_USART3,
+		.end	= AT91SAM9X5_ID_USART3,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data usart3_data = {
+	.use_dma_tx	= 1,
+	.use_dma_rx	= 1,
+};
+
+static u64 usart3_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device at91sam9x5_usart3_device = {
+	.name		= "atmel_usart",
+	.id		= 4,
+	.dev		= {
+				.dma_mask		= &usart3_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &usart3_data,
+	},
+	.resource	= usart3_resources,
+	.num_resources	= ARRAY_SIZE(usart3_resources),
+};
+
+static inline void configure_usart3_pins(unsigned pins)
+{
+	at91_set_B_periph(AT91_PIN_PC22, 1);		/* TXD3 */
+	at91_set_B_periph(AT91_PIN_PC23, 0);		/* RXD3 */
+
+	if (pins & ATMEL_UART_RTS)
+		at91_set_B_periph(AT91_PIN_PC24, 0);	/* RTS3 */
+	if (pins & ATMEL_UART_CTS)
+		at91_set_B_periph(AT91_PIN_PC25, 0);	/* CTS3 */
+}
+
+static struct resource uart0_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_UART0,
+		.end	= AT91SAM9X5_BASE_UART0 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_UART0,
+		.end	= AT91SAM9X5_ID_UART0,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data uart0_data = {
+	.use_dma_tx	= 1,
+	.use_dma_rx	= 1,
+};
+
+static u64 uart0_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device at91sam9x5_uart0_device = {
+	.name		= "atmel_usart",
+	.id		= 5,
+	.dev		= {
+				.dma_mask		= &uart0_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &uart0_data,
+	},
+	.resource	= uart0_resources,
+	.num_resources	= ARRAY_SIZE(uart0_resources),
+};
+
+static inline void configure_uart0_pins(unsigned pins)
+{
+	at91_set_C_periph(AT91_PIN_PC8, 1);		/* UTXD0 */
+	at91_set_C_periph(AT91_PIN_PC9, 0);		/* URXD0 */
+}
+
+static struct resource uart1_resources[] = {
+	[0] = {
+		.start	= AT91SAM9X5_BASE_UART1,
+		.end	= AT91SAM9X5_BASE_UART1 + SZ_16K - 1,
+		.flags	= IORESOURCE_MEM,
+	},
+	[1] = {
+		.start	= AT91SAM9X5_ID_UART1,
+		.end	= AT91SAM9X5_ID_UART1,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct atmel_uart_data uart1_data = {
+	.use_dma_tx	= 1,
+	.use_dma_rx	= 1,
+};
+
+static u64 uart1_dmamask = DMA_BIT_MASK(32);
+
+static struct platform_device at91sam9x5_uart1_device = {
+	.name		= "atmel_usart",
+	.id		= 6,
+	.dev		= {
+				.dma_mask		= &uart1_dmamask,
+				.coherent_dma_mask	= DMA_BIT_MASK(32),
+				.platform_data		= &uart1_data,
+	},
+	.resource	= uart1_resources,
+	.num_resources	= ARRAY_SIZE(uart1_resources),
+};
+
+static inline void configure_uart1_pins(unsigned pins)
+{
+	at91_set_C_periph(AT91_PIN_PC16, 1);		/* UTXD1 */
+	at91_set_C_periph(AT91_PIN_PC17, 0);		/* URXD1 */
+}
+
+static struct platform_device *__initdata at91_usarts[ATMEL_MAX_UART];	/* the USARTs to use */
+struct platform_device *atmel_default_console_device;	/* the serial console device */
+
+void __init at91_register_uart(unsigned id, unsigned portnr, unsigned pins)
+{
+	struct platform_device *pdev;
+
+	switch (id) {
+		case 0:		/* DBGU */
+			pdev = &at91sam9x5_dbgu_device;
+			configure_dbgu_pins();
+			at91_clock_associate("mck", &pdev->dev, "usart");
+			break;
+		case AT91SAM9X5_ID_USART0:
+			pdev = &at91sam9x5_usart0_device;
+			configure_usart0_pins(pins);
+			at91_clock_associate("usart0_clk", &pdev->dev, "usart");
+			break;
+		case AT91SAM9X5_ID_USART1:
+			pdev = &at91sam9x5_usart1_device;
+			configure_usart1_pins(pins);
+			at91_clock_associate("usart1_clk", &pdev->dev, "usart");
+			break;
+		case AT91SAM9X5_ID_USART2:
+			pdev = &at91sam9x5_usart2_device;
+			configure_usart2_pins(pins);
+			at91_clock_associate("usart2_clk", &pdev->dev, "usart");
+			break;
+		case AT91SAM9X5_ID_USART3:
+			pdev = &at91sam9x5_usart3_device;
+			configure_usart3_pins(pins);
+			at91_clock_associate("usart3_clk", &pdev->dev, "usart");
+			break;
+		case AT91SAM9X5_ID_UART0:
+			pdev = &at91sam9x5_uart0_device;
+			configure_uart0_pins(pins);
+			at91_clock_associate("uart0_clk", &pdev->dev, "usart");
+			break;
+		case AT91SAM9X5_ID_UART1:
+			pdev = &at91sam9x5_uart1_device;
+			configure_uart1_pins(pins);
+			at91_clock_associate("uart1_clk", &pdev->dev, "usart");
+			break;
+		default:
+			return;
+	}
+	pdev->id = portnr;		/* update to mapped ID */
+
+	if (portnr < ATMEL_MAX_UART)
+		at91_usarts[portnr] = pdev;
+}
+
+void __init at91_set_serial_console(unsigned portnr)
+{
+	if (portnr < ATMEL_MAX_UART)
+		atmel_default_console_device = at91_usarts[portnr];
+}
+
+void __init at91_add_device_serial(void)
+{
+	int i;
+
+	for (i = 0; i < ATMEL_MAX_UART; i++) {
+		if (at91_usarts[i]) {
+#if defined(CONFIG_AT_HDMAC) || defined(CONFIG_AT_HDMAC_MODULE)
+			int peripheral_id		= platform_get_irq(at91_usarts[i], 0);
+			struct atmel_uart_data *pdata	= at91_usarts[i]->dev.platform_data;
+
+			if (pdata->use_dma_tx) {
+				struct at_dma_slave	*atslave;
+
+				atslave = kzalloc(sizeof(struct at_dma_slave), GFP_KERNEL);
+
+				/* DMA slave channel configuration */
+				if (peripheral_id == AT91SAM9X5_ID_USART0
+				    || peripheral_id == AT91SAM9X5_ID_USART1
+				    || peripheral_id == AT91SAM9X5_ID_UART0)
+					atslave->dma_dev = &at_hdmac0_device.dev;
+				else
+					atslave->dma_dev = &at_hdmac1_device.dev;
+
+				atslave->reg_width = DW_DMA_SLAVE_WIDTH_8BIT;
+				atslave->cfg = ATC_FIFOCFG_HALFFIFO
+						| ATC_SRC_H2SEL_SW | ATC_DST_H2SEL_HW
+						| (AT_DMA_ID_USART0_TX << 4); /*ATC_DST_PER(peripheral_id);*/
+
+				pdata->dma_tx_slave = atslave;
+			}
+#endif
+			platform_device_register(at91_usarts[i]);
+		}
+	}
+
+	if (!atmel_default_console_device)
+		printk(KERN_INFO "AT91: No default serial console defined.\n");
+}
+#else
+void __init at91_register_uart(unsigned id, unsigned portnr, unsigned pins) {}
+void __init at91_set_serial_console(unsigned portnr) {}
+void __init at91_add_device_serial(void) {}
+#endif
+
+
+/* -------------------------------------------------------------------- */
+/*
+ * These devices are always present and don't need any board-specific
+ * setup.
+ */
+static int __init at91_add_standard_devices(void)
+{
+	at91_add_device_hdmac();
+	at91_add_device_rtc();
+	at91_add_device_watchdog();
+	at91_add_device_tc();
+	return 0;
+}
+
+arch_initcall(at91_add_standard_devices);
Index: linux-2.6.35/arch/arm/mach-at91/at91sam9g45.c
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/at91sam9g45.c	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/at91sam9g45.c	(revision 150)
@@ -20,6 +20,7 @@
 #include <mach/at91_pmc.h>
 #include <mach/at91_rstc.h>
 #include <mach/at91_shdwc.h>
+#include <mach/cpu.h>
 
 #include "generic.h"
 #include "clock.h"
@@ -120,8 +121,8 @@
 	.pmc_mask	= 1 << AT91SAM9G45_ID_SSC1,
 	.type		= CLK_TYPE_PERIPHERAL,
 };
-static struct clk tcb_clk = {
-	.name		= "tcb_clk",
+static struct clk tcb0_clk = {
+	.name		= "tcb0_clk",
 	.pmc_mask	= 1 << AT91SAM9G45_ID_TCB,
 	.type		= CLK_TYPE_PERIPHERAL,
 };
@@ -176,6 +177,13 @@
 	.type		= CLK_TYPE_PERIPHERAL,
 };
 
+/* Video decoder clock - Only for sam9m10/sam9m11 */
+static struct clk vdec_clk = {
+	.name		= "vdec_clk",
+	.pmc_mask	= 1 << AT91SAM9G45_ID_VDEC,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+
 /* One additional fake clock for ohci */
 static struct clk ohci_clk = {
 	.name		= "ohci_clk",
@@ -184,6 +192,14 @@
 	.parent		= &uhphs_clk,
 };
 
+/* One additional fake clock for second TC block */
+static struct clk tcb1_clk = {
+	.name		= "tcb1_clk",
+	.pmc_mask	= 0,
+	.type		= CLK_TYPE_PERIPHERAL,
+	.parent		= &tcb0_clk,
+};
+
 static struct clk *periph_clocks[] __initdata = {
 	&pioA_clk,
 	&pioB_clk,
@@ -200,7 +216,7 @@
 	&spi1_clk,
 	&ssc0_clk,
 	&ssc1_clk,
-	&tcb_clk,
+	&tcb0_clk,
 	&pwm_clk,
 	&tsc_clk,
 	&dma_clk,
@@ -213,6 +229,7 @@
 	&mmc1_clk,
 	// irq0
 	&ohci_clk,
+	&tcb1_clk,
 };
 
 /*
@@ -239,6 +256,9 @@
 	for (i = 0; i < ARRAY_SIZE(periph_clocks); i++)
 		clk_register(periph_clocks[i]);
 
+	if (cpu_is_at91sam9m10() || cpu_is_at91sam9m11())
+		clk_register(&vdec_clk);
+
 	clk_register(&pck0);
 	clk_register(&pck1);
 }
Index: linux-2.6.35/arch/arm/mach-at91/board-sam9x5cm.c
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/board-sam9x5cm.c	(revision 0)
+++ linux-2.6.35/arch/arm/mach-at91/board-sam9x5cm.c	(revision 150)
@@ -0,0 +1,285 @@
+/*
+ *  CPU module specific setup code for the AT91SAM9x5 family
+ *
+ *  Copyright (C) 2011 Atmel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/fb.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <linux/clk.h>
+#include <mach/cpu.h>
+
+#include <video/atmel_lcdc.h>
+#include <media/atmel-isi.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/at91sam9_smc.h>
+#include <mach/at91_shdwc.h>
+
+#include "sam9_smc.h"
+#include "generic.h"
+#include <mach/board-sam9x5.h>
+
+void __init cm_map_io(void)
+{
+	/* Initialize processor: 12.000 MHz crystal */
+	at91sam9x5_initialize(12000000);
+
+	/* DGBU on ttyS0. (Rx & Tx only) */
+	at91_register_uart(0, 0, 0);
+
+	/* set serial console to ttyS0 (ie, DBGU) */
+	at91_set_serial_console(0);
+}
+
+void __init cm_init_irq(void)
+{
+	at91sam9x5_init_interrupts(NULL);
+}
+
+/*
+ * SPI devices.
+ */
+#if 0
+static struct mtd_partition cm_spi_flash_parts[] = {
+	{
+		.name = "full",
+		.offset = 0,
+		.size = MTDPART_SIZ_FULL,
+	},
+	{
+		.name = "little",
+		.offset = 0,
+		.size = 24 * SZ_1K,
+	},
+	{
+		.name = "remaining",
+		.offset = MTDPART_OFS_NXTBLK,
+		.size = MTDPART_SIZ_FULL,
+	},
+};
+#endif
+
+static const struct flash_platform_data cm_spi_flash_data = {
+		/*.type           = "sst25vf032b",*/
+		.name           = "spi_flash",
+		/*.parts		= cm_spi_flash_parts,*/
+		/*.nr_parts	= ARRAY_SIZE(cm_spi_flash_parts),*/
+};
+
+static struct spi_board_info cm_spi_devices[] = {
+	{	/* serial flash chip */
+		.modalias	= "m25p80",
+		.chip_select	= 0,
+		.max_speed_hz	= 15 * 1000 * 1000,
+		.bus_num	= 0,
+		.mode		= SPI_MODE_0,
+		.platform_data  = &cm_spi_flash_data,
+		.irq            = -1,
+	},
+};
+
+/*
+ * NAND flash
+ */
+static struct mtd_partition __initdata cm_nand_partition[] = {
+#ifdef CONFIG_BLK_DEV_INITRD
+    {
+		.name   = "Bootstrap",
+		.offset = 0,
+		.size   = 5 * 1024 * 1024,
+	},
+
+	{
+		.name	= "system",
+		.offset	= 5 * 1024 * 1024,
+		.size	= 95 * 1024 * 1024,
+	},
+
+	{  
+	         .name   ="userdata",        /*for mtd@userdata*/
+		.offset = 100 * 1024 * 1024,
+		.size   = 92 * 1024 * 1024,
+               
+	},
+        
+        {
+                 .name   = "atmel_product",
+                 .offset = 192 * 1024 * 1024,
+                 .size   = MTDPART_SIZ_FULL,  
+	},
+#else
+
+    {
+		.name   = "Bootstrap",
+		.offset = 0,
+		.size   = 5 * 1024 * 1024,
+	},
+
+	{
+		.name	= "ramdisk",
+		.offset	= 5 * 1024 * 1024,
+		.size	= 95 * 1024 * 1024,
+	},
+
+	{  
+	    .name   ="userdata",        /*for mtd@userdata*/
+		.offset = 100 * 1024 * 1024,
+		.size   = 64 * 1024 * 1024,
+	},		
+	
+	{
+		.name	= "cache",	
+		.offset = 164 * 1024 * 1024, 
+		.size	= 28 * 1024 * 1024,
+
+	},
+		
+	{	.name	= "atmel_product",  		/*for atmel product information*/
+	    .offset	= 192 * 1024 * 1024, 	
+	    .size	= MTDPART_SIZ_FULL, 
+	},
+
+#endif
+};
+
+static struct mtd_partition * __init nand_partitions(int size, int *num_partitions)
+{
+	*num_partitions = ARRAY_SIZE(cm_nand_partition);
+	return cm_nand_partition;
+}
+
+/* det_pin is not connected */
+static struct atmel_nand_data __initdata cm_nand_data = {
+	.ale		= 21,
+	.cle		= 22,
+	.enable_pin	= AT91_PIN_PD4,
+	.partition_info	= nand_partitions,
+#if defined(CONFIG_MTD_NAND_AT91_BUSWIDTH_16)
+	.bus_width_16	= 1,
+#endif
+};
+
+static struct sam9_smc_config __initdata cm_nand_smc_config = {
+	.ncs_read_setup		= 0,
+	.nrd_setup		= 1,
+	.ncs_write_setup	= 0,
+	.nwe_setup		= 1,
+
+	.ncs_read_pulse		= 6,
+	.nrd_pulse		= 4,
+	.ncs_write_pulse	= 5,
+	.nwe_pulse		= 3,
+
+	.read_cycle		= 6,
+	.write_cycle		= 5,
+
+	.mode			= AT91_SMC_READMODE | AT91_SMC_WRITEMODE | AT91_SMC_EXNWMODE_DISABLE,
+	.tdf_cycles		= 1,
+};
+
+static void __init cm_add_device_nand(void)
+{
+	/* setup bus-width (8 or 16) */
+	if (cm_nand_data.bus_width_16)
+		cm_nand_smc_config.mode |= AT91_SMC_DBW_16;
+	else
+		cm_nand_smc_config.mode |= AT91_SMC_DBW_8;
+
+	/* revision of board modify NAND wiring */
+	if (cm_is_revA()) {
+		cm_nand_data.bus_on_d0 = 1;
+		cm_nand_data.rdy_pin = AT91_PIN_PD6;
+	} else {
+		cm_nand_data.bus_on_d0 = 0;
+		cm_nand_data.rdy_pin = AT91_PIN_PD5;
+	}
+
+	/* configure chip-select 3 (NAND) */
+	sam9_smc_configure(3, &cm_nand_smc_config);
+
+	at91_add_device_nand(&cm_nand_data);
+}
+
+/*
+ * LEDs
+ */
+static struct gpio_led cm_leds[] = {
+	{	/* "left" led, blue, userled1 */
+		.name			= "d1",
+		.gpio			= AT91_PIN_PB18,
+		.default_trigger	= "heartbeat",
+	},
+	{	/* "right" led, red, userled2 */
+		.name			= "d2",
+		.gpio			= AT91_PIN_PD21,
+		.active_low		= 1,
+		.default_trigger	= "mmc0",
+	},
+};
+
+/*
+ * I2C Devices
+ */
+static struct i2c_board_info __initdata cm_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("24c512", 0x50)
+	},
+};
+
+void __init cm_board_init(u32 *cm_config)
+{
+	int i;
+
+	*cm_config = 0;
+
+#if 0
+	/* SPI */
+	at91_add_device_spi(cm_spi_devices, ARRAY_SIZE(cm_spi_devices));
+	/* Check SPI0 usage to take decision in mother board */
+	for (i = 0; i < ARRAY_SIZE(cm_spi_devices); i++) {
+		if (cm_spi_devices[i].bus_num == 0) {
+			*cm_config |= CM_CONFIG_SPI0_ENABLE;
+			break;
+		}
+	}
+#endif
+	/* NAND */
+	cm_add_device_nand();
+	/* I2C */
+	at91_add_device_i2c(0, cm_i2c_devices, ARRAY_SIZE(cm_i2c_devices));
+	*cm_config |= CM_CONFIG_I2C0_ENABLE;
+	/* LEDs */
+	at91_gpio_leds(cm_leds, ARRAY_SIZE(cm_leds));
+
+	/* TODO Remove: only for debugging */
+	if (cm_is_revA())
+		printk(KERN_CRIT "AT91: CM rev A\n");
+	else
+		printk(KERN_CRIT "AT91: CM rev B and higher\n");
+}
Index: linux-2.6.35/arch/arm/mach-at91/Kconfig
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/Kconfig	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/Kconfig	(revision 150)
@@ -74,6 +74,12 @@
 	select HAVE_AT91_USART3
 	select HAVE_FB_ATMEL
 
+config ARCH_AT91SAM9X5
+	bool "AT91SAM9X5"
+	select CPU_ARM926T
+	select GENERIC_CLOCKEVENTS
+	select HAVE_FB_ATMEL
+
 config ARCH_AT91CAP9
 	bool "AT91CAP9"
 	select CPU_ARM926T
@@ -384,6 +390,54 @@
 
 # ----------------------------------------------------------
 
+if ARCH_AT91SAM9X5
+
+choice
+	prompt "AT91SAM9x5 Variants"
+	default ARCH_AT91SAM9X5_SAM9G15
+
+config CHIP_SAM9G15
+	bool "AT91SAM9G15"
+	help
+	  Select this if you are using Atmel's AT91SAM9G15 System-on-Chip.
+
+config CHIP_SAM9G25
+	bool "AT91SAM9G25"
+	select HAVE_AT91_USART3
+	help
+	  Select this if you are using Atmel's AT91SAM9G25 System-on-Chip.
+
+config CHIP_SAM9X25
+	bool "AT91SAM9X25"
+	select HAVE_AT91_USART3
+	help
+	  Select this if you are using Atmel's AT91SAM9X25 System-on-Chip.
+
+config CHIP_SAM9G35
+	bool "AT91SAM9G35"
+	help
+	  Select this if you are using Atmel's AT91SAM9G35 System-on-Chip.
+
+config CHIP_SAM9X35
+	bool "AT91SAM9X35"
+	help
+	  Select this if you are using Atmel's AT91SAM9X35 System-on-Chip.
+endchoice
+
+comment "AT91SAM9x5 Series Board Type"
+
+config MACH_AT91SAM9X5EK
+	bool "Atmel AT91SAM9x5 Series Evaluation Kit"
+#	select HAVE_AT91_DATAFLASH_CARD
+#	select HAVE_NAND_ATMEL_BUSWIDTH_16
+	help
+	  Select this if you re using Atmel's AT91SAM9x5-EK Evaluation Kit.
+	  Supported chips are sam9g15, sam9g25, sam9x25, sam9g35 and sam9x35.
+endif
+# ----------------------------------------------------------
+
+# ----------------------------------------------------------
+
 if ARCH_AT91CAP9
 
 comment "AT91CAP9 Board Type"
Index: linux-2.6.35/arch/arm/mach-at91/generic.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/generic.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/generic.h	(revision 150)
@@ -15,6 +15,7 @@
 extern void __init at91sam9263_initialize(unsigned long main_clock);
 extern void __init at91sam9rl_initialize(unsigned long main_clock);
 extern void __init at91sam9g45_initialize(unsigned long main_clock);
+extern void __init at91sam9x5_initialize(unsigned long main_clock);
 extern void __init at91x40_initialize(unsigned long main_clock);
 extern void __init at91cap9_initialize(unsigned long main_clock);
 extern void __init at572d940hf_initialize(unsigned long main_clock);
@@ -26,6 +27,7 @@
 extern void __init at91sam9263_init_interrupts(unsigned int priority[]);
 extern void __init at91sam9rl_init_interrupts(unsigned int priority[]);
 extern void __init at91sam9g45_init_interrupts(unsigned int priority[]);
+extern void __init at91sam9x5_init_interrupts(unsigned int priority[]);
 extern void __init at91x40_init_interrupts(unsigned int priority[]);
 extern void __init at91cap9_init_interrupts(unsigned int priority[]);
 extern void __init at572d940hf_init_interrupts(unsigned int priority[]);
Index: linux-2.6.35/arch/arm/mach-at91/pm_slowclock.S
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/pm_slowclock.S	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/pm_slowclock.S	(revision 150)
@@ -16,10 +16,12 @@
 #include <mach/hardware.h>
 #include <mach/at91_pmc.h>
 
-#ifdef CONFIG_ARCH_AT91RM9200
+#if defined(CONFIG_ARCH_AT91RM9200)
 #include <mach/at91rm9200_mc.h>
 #elif defined(CONFIG_ARCH_AT91CAP9)
 #include <mach/at91cap9_ddrsdr.h>
+#elif defined(CONFIG_ARCH_AT91SAM9G45) || defined(CONFIG_ARCH_AT91SAM9X5)
+#include <mach/at91sam9_ddrsdr.h>
 #else
 #include <mach/at91sam9_sdramc.h>
 #endif
@@ -30,7 +32,6 @@
  * FIXME either or both the SDRAM controllers (EB0, EB1) might be in use;
  * handle those cases both here and in the Suspend-To-RAM support.
  */
-#define AT91_SDRAMC	AT91_SDRAMC0
 #warning Assuming EB1 SDRAM controller is *NOT* used
 #endif
 
@@ -113,34 +114,51 @@
 	/*
 	 * Register usage:
 	 *  R1 = Base address of AT91_PMC
-	 *  R2 = Base address of AT91_SDRAMC (or AT91_SYS on AT91RM9200)
+	 *  R2 = Base address of RAM Controller (SDRAM, DDRSDR, or AT91_SYS)
 	 *  R3 = temporary register
 	 *  R4 = temporary register
+	 *  R5 = Base address of second RAM Controller or 0 if not present
 	 */
 	ldr	r1, .at91_va_base_pmc
 	ldr	r2, .at91_va_base_sdramc
+	ldr	r5, .at91_va_base_ramc1
 
 	/* Drain write buffer */
+	mov	r0, #0
 	mcr	p15, 0, r0, c7, c10, 4
 
 #ifdef CONFIG_ARCH_AT91RM9200
 	/* Put SDRAM in self-refresh mode */
 	mov	r3, #1
 	str	r3, [r2, #AT91_SDRAMC_SRR]
-#elif defined(CONFIG_ARCH_AT91CAP9)
-	/* Enable SDRAM self-refresh mode */
-	ldr	r3, [r2, #AT91_DDRSDRC_LPR - AT91_DDRSDRC]
+#elif defined(CONFIG_ARCH_AT91CAP9) \
+	|| defined(CONFIG_ARCH_AT91SAM9G45) \
+	|| defined(CONFIG_ARCH_AT91SAM9X5)
+
+	/* prepare for DDRAM self-refresh mode */
+	ldr	r3, [r2, #AT91_DDRSDRC_LPR]
 	str	r3, .saved_sam9_lpr
+	bic	r3, #AT91_DDRSDRC_LPCB
+	orr	r3, #AT91_DDRSDRC_LPCB_SELF_REFRESH
 
-	mov	r3, #AT91_DDRSDRC_LPCB_SELF_REFRESH
-	str	r3, [r2, #AT91_DDRSDRC_LPR - AT91_DDRSDRC]
+	/* figure out if we use the second ram controller */
+	cmp	r5, #0
+	ldrne	r4, [r5, #AT91_DDRSDRC_LPR]
+	strne	r4, .saved_sam9_lpr1
+	bicne	r4, #AT91_DDRSDRC_LPCB
+	orrne	r4, #AT91_DDRSDRC_LPCB_SELF_REFRESH
+
+	/* Enable DDRAM self-refresh mode */
+	str	r3, [r2, #AT91_DDRSDRC_LPR]
+	strne	r4, [r5, #AT91_DDRSDRC_LPR]
 #else
 	/* Enable SDRAM self-refresh mode */
-	ldr	r3, [r2, #AT91_SDRAMC_LPR - AT91_SDRAMC]
+	ldr	r3, [r2, #AT91_SDRAMC_LPR]
 	str	r3, .saved_sam9_lpr
 
-	mov	r3, #AT91_SDRAMC_LPCB_SELF_REFRESH
-	str	r3, [r2, #AT91_SDRAMC_LPR - AT91_SDRAMC]
+	bic	r3, #AT91_SDRAMC_LPCB
+	orr	r3, #AT91_SDRAMC_LPCB_SELF_REFRESH
+	str	r3, [r2, #AT91_SDRAMC_LPR]
 #endif
 
 	/* Save Master clock setting */
@@ -247,14 +265,22 @@
 
 #ifdef CONFIG_ARCH_AT91RM9200
 	/* Do nothing - self-refresh is automatically disabled. */
-#elif defined(CONFIG_ARCH_AT91CAP9)
-	/* Restore LPR on AT91CAP9 */
+#elif defined(CONFIG_ARCH_AT91CAP9) \
+	|| defined(CONFIG_ARCH_AT91SAM9G45) \
+	|| defined(CONFIG_ARCH_AT91SAM9X5)
+	/* Restore LPR on AT91 with DDRAM */
 	ldr	r3, .saved_sam9_lpr
-	str	r3, [r2, #AT91_DDRSDRC_LPR - AT91_DDRSDRC]
+	str	r3, [r2, #AT91_DDRSDRC_LPR]
+
+	/* if we use the second ram controller */
+	cmp	r5, #0
+	ldrne	r4, .saved_sam9_lpr1
+	strne	r4, [r5, #AT91_DDRSDRC_LPR]
+
 #else
-	/* Restore LPR on AT91SAM9 */
+	/* Restore LPR on AT91 with SDRAM */
 	ldr	r3, .saved_sam9_lpr
-	str	r3, [r2, #AT91_SDRAMC_LPR - AT91_SDRAMC]
+	str	r3, [r2, #AT91_SDRAMC_LPR]
 #endif
 
 	/* Restore registers, and return */
@@ -273,19 +299,31 @@
 .saved_sam9_lpr:
 	.word 0
 
+.saved_sam9_lpr1:
+	.word 0
+
 .at91_va_base_pmc:
 	.word AT91_VA_BASE_SYS + AT91_PMC
 
 #ifdef CONFIG_ARCH_AT91RM9200
 .at91_va_base_sdramc:
 	.word AT91_VA_BASE_SYS
-#elif defined(CONFIG_ARCH_AT91CAP9)
+#elif defined(CONFIG_ARCH_AT91CAP9) \
+	|| defined(CONFIG_ARCH_AT91SAM9G45) \
+	|| defined(CONFIG_ARCH_AT91SAM9X5)
 .at91_va_base_sdramc:
-	.word AT91_VA_BASE_SYS + AT91_DDRSDRC
+	.word AT91_VA_BASE_SYS + AT91_DDRSDRC0
 #else
 .at91_va_base_sdramc:
-	.word AT91_VA_BASE_SYS + AT91_SDRAMC
+	.word AT91_VA_BASE_SYS + AT91_SDRAMC0
 #endif
 
+.at91_va_base_ramc1:
+#if defined(CONFIG_ARCH_AT91SAM9G45)
+	.word AT91_VA_BASE_SYS + AT91_DDRSDRC1
+#else
+	.word 0
+#endif
+
 ENTRY(at91_slow_clock_sz)
 	.word .-at91_slow_clock
Index: linux-2.6.35/arch/arm/mach-at91/pm.c
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/pm.c	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/pm.c	(revision 150)
@@ -258,16 +258,23 @@
 			 * NOTE: the Wait-for-Interrupt instruction needs to be
 			 * in icache so no SDRAM accesses are needed until the
 			 * wakeup IRQ occurs and self-refresh is terminated.
+			 * For ARM 926 based chips, this requirement is weaker
+			 * as at91sam9 can access a RAM in self-refresh mode.
 			 */
-			asm("b 1f; .align 5; 1:");
-			asm("mcr p15, 0, r0, c7, c10, 4");	/* drain write buffer */
+			asm volatile (	"mov r0, #0\n\t"
+					"b 1f\n\t"
+					".align 5\n\t"
+					"1: mcr p15, 0, r0, c7, c10, 4\n\t"
+					: /* no output */
+					: /* no input */
+					: "r0");
 			saved_lpr = sdram_selfrefresh_enable();
-			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+			wait_for_interrupt_enable();
 			sdram_selfrefresh_disable(saved_lpr);
 			break;
 
 		case PM_SUSPEND_ON:
-			asm("mcr p15, 0, r0, c7, c0, 4");	/* wait for interrupt */
+			cpu_do_idle();
 			break;
 
 		default:
Index: linux-2.6.35/arch/arm/mach-at91/pm.h
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/pm.h	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/pm.h	(revision 150)
@@ -21,6 +21,8 @@
 }
 
 #define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
+#define wait_for_interrupt_enable()		asm volatile ("mcr p15, 0, %0, c7, c0, 4" \
+								: : "r" (0))
 
 #elif defined(CONFIG_ARCH_AT91CAP9)
 #include <mach/at91cap9_ddrsdr.h>
@@ -30,15 +32,72 @@
 {
 	u32 saved_lpr, lpr;
 
-	saved_lpr = at91_sys_read(AT91_DDRSDRC_LPR);
+	saved_lpr = at91_ramc_read(0, AT91_DDRSDRC_LPR);
 
 	lpr = saved_lpr & ~AT91_DDRSDRC_LPCB;
-	at91_sys_write(AT91_DDRSDRC_LPR, lpr | AT91_DDRSDRC_LPCB_SELF_REFRESH);
+	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr | AT91_DDRSDRC_LPCB_SELF_REFRESH);
 	return saved_lpr;
 }
 
-#define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_DDRSDRC_LPR, saved_lpr)
+#define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr)
+#define wait_for_interrupt_enable()		cpu_do_idle()
 
+#elif defined(CONFIG_ARCH_AT91SAM9G45)
+#include <mach/at91sam9_ddrsdr.h>
+
+/* We manage both DDRAM/SDRAM controllers, we need more than one value to
+ * remember.
+ */
+static u32 saved_lpr1;
+
+static inline u32 sdram_selfrefresh_enable(void)
+{
+	/* Those tow values allow us to delay self-refresh activation
+	 * to the maximum. */
+	u32 lpr0, lpr1;
+	u32 saved_lpr0;
+
+	saved_lpr1 = at91_ramc_read(1, AT91_DDRSDRC_LPR);
+	lpr1 = saved_lpr1 & ~AT91_DDRSDRC_LPCB;
+	lpr1 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
+
+	saved_lpr0 = at91_ramc_read(0, AT91_DDRSDRC_LPR);
+	lpr0 = saved_lpr0 & ~AT91_DDRSDRC_LPCB;
+	lpr0 |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
+
+	/* self-refresh mode now */
+	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);
+	at91_ramc_write(1, AT91_DDRSDRC_LPR, lpr1);
+
+	return saved_lpr0;
+}
+
+#define sdram_selfrefresh_disable(saved_lpr0)	\
+	do { \
+		at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0); \
+		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1); \
+	} while (0)
+#define wait_for_interrupt_enable()		cpu_do_idle()
+
+#elif defined(CONFIG_ARCH_AT91SAM9X5)
+#include <mach/at91sam9_ddrsdr.h>
+
+static inline u32 sdram_selfrefresh_enable(void)
+{
+	u32 lpr, saved_lpr;
+
+	saved_lpr = at91_ramc_read(0, AT91_DDRSDRC_LPR);
+	lpr = saved_lpr & ~AT91_DDRSDRC_LPCB;
+	lpr |= AT91_DDRSDRC_LPCB_SELF_REFRESH;
+
+	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr);
+
+	return saved_lpr;
+}
+
+#define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr)
+#define wait_for_interrupt_enable()		cpu_do_idle()
+
 #else
 #include <mach/at91sam9_sdramc.h>
 
@@ -47,7 +106,6 @@
  * FIXME either or both the SDRAM controllers (EB0, EB1) might be in use;
  * handle those cases both here and in the Suspend-To-RAM support.
  */
-#define	AT91_SDRAMC	AT91_SDRAMC0
 #warning Assuming EB1 SDRAM controller is *NOT* used
 #endif
 
@@ -55,13 +113,14 @@
 {
 	u32 saved_lpr, lpr;
 
-	saved_lpr = at91_sys_read(AT91_SDRAMC_LPR);
+	saved_lpr = at91_ramc_read(0, AT91_SDRAMC_LPR);
 
 	lpr = saved_lpr & ~AT91_SDRAMC_LPCB;
-	at91_sys_write(AT91_SDRAMC_LPR, lpr | AT91_SDRAMC_LPCB_SELF_REFRESH);
+	at91_ramc_write(0, AT91_SDRAMC_LPR, lpr | AT91_SDRAMC_LPCB_SELF_REFRESH);
 	return saved_lpr;
 }
 
-#define sdram_selfrefresh_disable(saved_lpr)	at91_sys_write(AT91_SDRAMC_LPR, saved_lpr)
+#define sdram_selfrefresh_disable(saved_lpr)	at91_ramc_write(0, AT91_SDRAMC_LPR, saved_lpr)
+#define wait_for_interrupt_enable()		cpu_do_idle()
 
 #endif
Index: linux-2.6.35/arch/arm/mach-at91/at91sam9x5.c
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/at91sam9x5.c	(revision 0)
+++ linux-2.6.35/arch/arm/mach-at91/at91sam9x5.c	(revision 150)
@@ -0,0 +1,418 @@
+/*
+ *  Chip-specific setup code for the AT91SAM9x5 family
+ *
+ *  Copyright (C) 2010 Atmel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/pm.h>
+
+#include <asm/irq.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <mach/at91sam9x5.h>
+#include <mach/at91_pmc.h>
+#include <mach/at91_rstc.h>
+#include <mach/at91_shdwc.h>
+#include <mach/cpu.h>
+
+#include "generic.h"
+#include "clock.h"
+
+static struct map_desc at91sam9x5_io_desc[] __initdata = {
+	{
+		.virtual	= AT91_VA_BASE_SYS,
+		.pfn		= __phys_to_pfn(AT91_BASE_SYS),
+		.length		= SZ_16K,
+		.type		= MT_DEVICE,
+	}, {
+		.virtual	= AT91_IO_VIRT_BASE - AT91SAM9X5_SRAM_SIZE,
+		.pfn		= __phys_to_pfn(AT91SAM9X5_SRAM_BASE),
+		.length		= AT91SAM9X5_SRAM_SIZE,
+		.type		= MT_DEVICE,
+	}
+};
+
+/* --------------------------------------------------------------------
+ *  Clocks
+ * -------------------------------------------------------------------- */
+
+/*
+ * The peripheral clocks.
+ */
+static struct clk pioAB_clk = {
+	.name		= "pioAB_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_PIOAB,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk pioCD_clk = {
+	.name		= "pioCD_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_PIOCD,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk smd_clk = {
+	.name		= "smd_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_SMD,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk usart0_clk = {
+	.name		= "usart0_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_USART0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk usart1_clk = {
+	.name		= "usart1_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_USART1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk usart2_clk = {
+	.name		= "usart2_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_USART2,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+/* USART3 clock - Only for sam9g25/sam9x25 */
+static struct clk usart3_clk = {
+	.name		= "usart3_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_USART3,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk twi0_clk = {
+	.name		= "twi0_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_TWI0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk twi1_clk = {
+	.name		= "twi1_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_TWI1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk twi2_clk = {
+	.name		= "twi2_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_TWI2,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk mmc0_clk = {
+	.name		= "mci0_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_MCI0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk spi0_clk = {
+	.name		= "spi0_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_SPI0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk spi1_clk = {
+	.name		= "spi1_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_SPI1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk uart0_clk = {
+	.name		= "uart0_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_UART0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk uart1_clk = {
+	.name		= "uart1_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_UART1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk tcb0_clk = {
+	.name		= "tcb0_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_TCB,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk pwm_clk = {
+	.name		= "pwm_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_PWM,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk adc_clk = {
+	.name		= "adc_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_ADC,
+	.type	= CLK_TYPE_PERIPHERAL,
+};
+static struct clk dma0_clk = {
+	.name		= "dma0_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_DMA0,
+	.type	= CLK_TYPE_PERIPHERAL,
+};
+static struct clk dma1_clk = {
+	.name		= "dma1_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_DMA1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk uhphs_clk = {
+	.name		= "uhphs_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_UHPHS,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk udphs_clk = {
+	.name		= "udphs_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_UDPHS,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+/* emac0 clock - Only for sam9g25/sam9x25/sam9g35/sam9x35 */
+static struct clk macb0_clk = {
+	.name		= "macb0_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_EMAC0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+/* lcd clock - Only for sam9g15/sam9g35/sam9x35 */
+static struct clk lcdc_clk = {
+	.name		= "lcdc_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_LCDC,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+/* isi clock - Only for sam9g25 */
+static struct clk isi_clk = {
+	.name		= "isi_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_ISI,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk mmc1_clk = {
+	.name		= "mci1_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_MCI1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+/* emac1 clock - Only for sam9x25 */
+static struct clk macb1_clk = {
+	.name		= "macb1_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_EMAC1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+static struct clk ssc_clk = {
+	.name		= "ssc_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_SSC,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+/* can0 clock - Only for sam9x35 */
+static struct clk can0_clk = {
+	.name		= "can0_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_CAN0,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+/* can1 clock - Only for sam9x35 */
+static struct clk can1_clk = {
+	.name		= "can1_clk",
+	.pmc_mask	= 1 << AT91SAM9X5_ID_CAN1,
+	.type		= CLK_TYPE_PERIPHERAL,
+};
+
+/* One additional fake clock for ohci */
+static struct clk ohci_clk = {
+	.name		= "ohci_clk",
+	.pmc_mask	= 0,
+	.type		= CLK_TYPE_PERIPHERAL,
+	.parent		= &uhphs_clk,
+};
+
+/* One additional fake clock for second TC block */
+static struct clk tcb1_clk = {
+	.name		= "tcb1_clk",
+	.pmc_mask	= 0,
+	.type		= CLK_TYPE_PERIPHERAL,
+	.parent		= &tcb0_clk,
+};
+
+static struct clk *periph_clocks[] __initdata = {
+	&pioAB_clk,
+	&pioCD_clk,
+	&smd_clk,
+	&usart0_clk,
+	&usart1_clk,
+	&usart2_clk,
+	&twi0_clk,
+	&twi1_clk,
+	&twi2_clk,
+	&mmc0_clk,
+	&spi0_clk,
+	&spi1_clk,
+	&uart0_clk,
+	&uart1_clk,
+	&tcb0_clk,
+	&pwm_clk,
+	&adc_clk,
+	&dma0_clk,
+	&dma1_clk,
+	&uhphs_clk,
+	&udphs_clk,
+	&mmc1_clk,
+	&ssc_clk,
+	// irq0
+	&ohci_clk,
+	&tcb1_clk,
+};
+
+/*
+ * The two programmable clocks.
+ * You must configure pin multiplexing to bring these signals out.
+ */
+static struct clk pck0 = {
+	.name		= "pck0",
+	.pmc_mask	= AT91_PMC_PCK0,
+	.type		= CLK_TYPE_PROGRAMMABLE,
+	.id		= 0,
+};
+static struct clk pck1 = {
+	.name		= "pck1",
+	.pmc_mask	= AT91_PMC_PCK1,
+	.type		= CLK_TYPE_PROGRAMMABLE,
+	.id		= 1,
+};
+
+static void __init at91sam9x5_register_clocks(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(periph_clocks); i++)
+		clk_register(periph_clocks[i]);
+
+	if (cpu_is_at91sam9g25()
+	|| cpu_is_at91sam9x25())
+		clk_register(&usart3_clk);
+
+	if (cpu_is_at91sam9g25()
+	|| cpu_is_at91sam9x25()
+	|| cpu_is_at91sam9g35()
+	|| cpu_is_at91sam9x35())
+		clk_register(&macb0_clk);
+
+	if (cpu_is_at91sam9g15()
+	|| cpu_is_at91sam9g35()
+	|| cpu_is_at91sam9x35())
+		clk_register(&lcdc_clk);
+
+	if (cpu_is_at91sam9g25())
+		clk_register(&isi_clk);
+
+	if (cpu_is_at91sam9x25())
+		clk_register(&macb1_clk);
+
+	if (cpu_is_at91sam9x35()) {
+		clk_register(&can0_clk);
+		clk_register(&can1_clk);
+	}
+
+	clk_register(&pck0);
+	clk_register(&pck1);
+}
+
+/* --------------------------------------------------------------------
+ *  GPIO
+ * -------------------------------------------------------------------- */
+
+static struct at91_gpio_bank at91sam9x5_gpio[] = {
+	{
+		.id		= AT91SAM9X5_ID_PIOAB,
+		.offset		= AT91_PIOA,
+		.clock		= &pioAB_clk,
+	}, {
+		.id		= AT91SAM9X5_ID_PIOAB,
+		.offset		= AT91_PIOB,
+		.clock		= &pioAB_clk,
+	}, {
+		.id		= AT91SAM9X5_ID_PIOCD,
+		.offset		= AT91_PIOC,
+		.clock		= &pioCD_clk,
+	}, {
+		.id		= AT91SAM9X5_ID_PIOCD,
+		.offset		= AT91_PIOD,
+		.clock		= &pioCD_clk,
+	}
+};
+
+static void at91sam9x5_reset(void)
+{
+	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_PROCRST | AT91_RSTC_PERRST);
+}
+
+static void at91sam9x5_poweroff(void)
+{
+	at91_sys_read(AT91_SHDW_SR);
+	at91_sys_write(AT91_SHDW_MR, AT91_SHDW_WKMODE0_ANYLEVEL);
+	at91_sys_write(AT91_SHDW_CR, AT91_SHDW_KEY | AT91_SHDW_SHDW);
+}
+
+
+/* --------------------------------------------------------------------
+ *  AT91SAM9x5 processor initialization
+ * -------------------------------------------------------------------- */
+
+void __init at91sam9x5_initialize(unsigned long main_clock)
+{
+	/* Map peripherals */
+	iotable_init(at91sam9x5_io_desc, ARRAY_SIZE(at91sam9x5_io_desc));
+
+	at91_arch_reset = at91sam9x5_reset;
+	pm_power_off = at91sam9x5_poweroff;
+	at91_extern_irq = (1 << AT91SAM9X5_ID_IRQ0);
+
+	/* Init clock subsystem */
+	at91_clock_init(main_clock);
+
+	/* Register the processor-specific clocks */
+	at91sam9x5_register_clocks();
+
+	/* Register GPIO subsystem */
+	at91_gpio_init(at91sam9x5_gpio, 4);
+}
+
+/* --------------------------------------------------------------------
+ *  Interrupt initialization
+ * -------------------------------------------------------------------- */
+
+/*
+ * The default interrupt priority levels (0 = lowest, 7 = highest).
+ */
+static unsigned int at91sam9x5_default_irq_priority[NR_AIC_IRQS] __initdata = {
+	7,	/* Advanced Interrupt Controller (FIQ) */
+	7,	/* System Peripherals */
+	1,	/* Parallel IO Controller A and B */
+	1,	/* Parallel IO Controller C and D */
+	4,	/* Soft Modem */
+	5,	/* USART 0 */
+	5,	/* USART 1 */
+	5,	/* USART 2 */
+	5,	/* USART 3 */
+	6,	/* Two-Wire Interface 0 */
+	6,	/* Two-Wire Interface 1 */
+	6,	/* Two-Wire Interface 2 */
+	0,	/* Multimedia Card Interface 0 */
+	5,	/* Serial Peripheral Interface 0 */
+	5,	/* Serial Peripheral Interface 1 */
+	5,	/* UART 0 */
+	5,	/* UART 1 */
+	0,	/* Timer Counter 0, 1, 2, 3, 4 and 5 */
+	0,	/* Pulse Width Modulation Controller */
+	0,	/* ADC COntroller */
+	0,	/* DMA Controller 0 */
+	0,	/* DMA Controller 1 */
+	2,	/* USB Host High Speed port */
+	2,	/* USB Device High speed port */
+	3,	/* Ethernet MAC 0 */
+	3,	/* LDC Controller or Image Sensor Interface */
+	0,	/* Multimedia Card Interface 1 */
+	3,	/* Ethernet MAC 1 */
+	4,	/* Synchronous Serial Interface */
+	4,	/* CAN Controller 0 */
+	4,	/* CAN Controller 1 */
+	0,	/* Advanced Interrupt Controller (IRQ0) */
+};
+
+void __init at91sam9x5_init_interrupts(unsigned int priority[NR_AIC_IRQS])
+{
+	if (!priority)
+		priority = at91sam9x5_default_irq_priority;
+
+	/* Initialize the AIC interrupt controller */
+	at91_aic_init(priority);
+
+	/* Enable GPIO interrupts */
+	at91_gpio_irq_setup();
+}
Index: linux-2.6.35/arch/arm/mach-at91/at91sam9g45_devices.c
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/at91sam9g45_devices.c	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/at91sam9g45_devices.c	(revision 150)
@@ -46,7 +46,7 @@
 		.end	= AT91_BASE_SYS + AT91_DMA + SZ_512 - 1,
 		.flags	= IORESOURCE_MEM,
 	},
-	[2] = {
+	[1] = {
 		.start	= AT91SAM9G45_ID_DMA,
 		.end	= AT91SAM9G45_ID_DMA,
 		.flags	= IORESOURCE_IRQ,
@@ -835,9 +835,9 @@
 static void __init at91_add_device_tc(void)
 {
 	/* this chip has one clock and irq for all six TC channels */
-	at91_clock_associate("tcb_clk", &at91sam9g45_tcb0_device.dev, "t0_clk");
+	at91_clock_associate("tcb0_clk", &at91sam9g45_tcb0_device.dev, "t0_clk");
 	platform_device_register(&at91sam9g45_tcb0_device);
-	at91_clock_associate("tcb_clk", &at91sam9g45_tcb1_device.dev, "t0_clk");
+	at91_clock_associate("tcb1_clk", &at91sam9g45_tcb1_device.dev, "t0_clk");
 	platform_device_register(&at91sam9g45_tcb1_device);
 }
 #else
Index: linux-2.6.35/arch/arm/mach-at91/clock.c
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/clock.c	(revision 149)
+++ linux-2.6.35/arch/arm/mach-at91/clock.c	(revision 150)
@@ -49,25 +49,38 @@
  */
 #define cpu_has_utmi()		(  cpu_is_at91cap9() \
 				|| cpu_is_at91sam9rl() \
-				|| cpu_is_at91sam9g45())
+				|| cpu_is_at91sam9g45() \
+				|| cpu_is_at91sam9x5())
 
 #define cpu_has_800M_plla()	(  cpu_is_at91sam9g20() \
-				|| cpu_is_at91sam9g45())
+				|| cpu_is_at91sam9g45() \
+				|| cpu_is_at91sam9x5())
 
 #define cpu_has_300M_plla()	(cpu_is_at91sam9g10())
 
 #define cpu_has_pllb()		(!(cpu_is_at91sam9rl() \
-				|| cpu_is_at91sam9g45()))
+				|| cpu_is_at91sam9g45() \
+				|| cpu_is_at91sam9x5()))
 
-#define cpu_has_upll()		(cpu_is_at91sam9g45())
+#define cpu_has_upll()		(cpu_is_at91sam9g45() \
+				|| cpu_is_at91sam9x5())
 
 /* USB host HS & FS */
 #define cpu_has_uhp()		(!cpu_is_at91sam9rl())
 
 /* USB device FS only */
 #define cpu_has_udpfs()		(!(cpu_is_at91sam9rl() \
-				|| cpu_is_at91sam9g45()))
+				|| cpu_is_at91sam9g45() \
+				|| cpu_is_at91sam9x5()))
 
+#define cpu_has_plladiv2()	(cpu_is_at91sam9g45() \
+				|| cpu_is_at91sam9x5())
+
+#define cpu_has_mdiv3()		(cpu_is_at91sam9g45() \
+				|| cpu_is_at91sam9x5())
+
+#define cpu_has_alt_prescaler()	(cpu_is_at91sam9x5())
+
 static LIST_HEAD(clocks);
 static DEFINE_SPINLOCK(clk_lock);
 
@@ -139,13 +152,6 @@
 {
 	unsigned int uckr = at91_sys_read(AT91_CKGR_UCKR);
 
-	if (cpu_is_at91sam9g45()) {
-		if (is_on)
-			uckr |= AT91_PMC_BIASEN;
-		else
-			uckr &= ~AT91_PMC_BIASEN;
-	}
-
 	if (is_on) {
 		is_on = AT91_PMC_LOCKU;
 		at91_sys_write(AT91_CKGR_UCKR, uckr | clk->pmc_mask);
@@ -210,11 +216,26 @@
 				return &utmi_clk;
 			else if (cpu_has_pllb())
 				return &pllb;
+			break;
+		/* alternate PMC: can use master clock */
+		case AT91_PMC_CSS_MASTER:
+			return &mck;
 	}
 
 	return NULL;
 }
 
+
+static int pmc_prescaler_divider(u32 reg)
+{
+	if (cpu_has_alt_prescaler()) {
+		return 1 << ((reg & AT91_PMC_ALT_PRES) >> PMC_ALT_PRES_OFFSET);
+	} else {
+		return 1 << ((reg & AT91_PMC_PRES) >> PMC_PRES_OFFSET);
+	}
+}
+
+
 /*
  * Associate a particular clock with a function (eg, "uart") and device.
  * The drivers can then request the same 'function' with several different
@@ -353,12 +374,22 @@
 {
 	unsigned long	flags;
 	unsigned	prescale;
+	unsigned long	prescale_offset, css_mask;
 	unsigned long	actual;
 
 	if (!clk_is_programmable(clk))
 		return -EINVAL;
 	if (clk->users)
 		return -EBUSY;
+
+	if (cpu_has_alt_prescaler()) {
+		prescale_offset = PMC_ALT_PRES_OFFSET;
+		css_mask = AT91_PMC_ALT_PCKR_CSS;
+	} else {
+		prescale_offset = PMC_PRES_OFFSET;
+		css_mask = AT91_PMC_CSS;
+	}
+
 	spin_lock_irqsave(&clk_lock, flags);
 
 	actual = clk->parent->rate_hz;
@@ -367,8 +398,8 @@
 			u32	pckr;
 
 			pckr = at91_sys_read(AT91_PMC_PCKR(clk->id));
-			pckr &= AT91_PMC_CSS;	/* clock selection */
-			pckr |= prescale << 2;
+			pckr &= css_mask;	/* keep clock selection */
+			pckr |= prescale << prescale_offset;
 			at91_sys_write(AT91_PMC_PCKR(clk->id), pckr);
 			clk->rate_hz = actual;
 			break;
@@ -415,11 +446,17 @@
 {
 	struct clk	*parent;
 	u32		pckr;
+	unsigned int	css_mask;
 
+	if (cpu_has_alt_prescaler())
+		css_mask = AT91_PMC_ALT_PCKR_CSS;
+	else
+		css_mask = AT91_PMC_CSS;
+
 	pckr = at91_sys_read(AT91_PMC_PCKR(clk->id));
-	parent = at91_css_to_clk(pckr & AT91_PMC_CSS);
+	parent = at91_css_to_clk(pckr & css_mask);
 	clk->parent = parent;
-	clk->rate_hz = parent->rate_hz / (1 << ((pckr & AT91_PMC_PRES) >> 2));
+	clk->rate_hz = parent->rate_hz / pmc_prescaler_divider(pckr);
 }
 
 #endif	/* CONFIG_AT91_PROGRAMMABLE_CLOCKS */
@@ -501,7 +538,8 @@
 int __init clk_register(struct clk *clk)
 {
 	if (clk_is_peripheral(clk)) {
-		clk->parent = &mck;
+		if (!clk->parent)
+			clk->parent = &mck;
 		clk->mode = pmc_periph_mode;
 		list_add_tail(&clk->node, &clocks);
 	}
@@ -696,7 +734,7 @@
 	if (pll_overclock)
 		pr_info("Clocks: PLLA overclocked, %ld MHz\n", plla.rate_hz / 1000000);
 
-	if (cpu_is_at91sam9g45()) {
+	if (cpu_has_plladiv2()) {
 		mckr = at91_sys_read(AT91_PMC_MCKR);
 		plla.rate_hz /= (1 << ((mckr & AT91_PMC_PLLADIV2) >> 12));	/* plla divisor by 2 */
 	}
@@ -718,6 +756,10 @@
 		 * (obtain the USB High Speed 480 MHz when input is 12 MHz)
 		 */
 		utmi_clk.rate_hz = 40 * utmi_clk.parent->rate_hz;
+
+		/* UTMI bias and PLL are managed at the same time */
+		if (cpu_is_at91sam9g45() || cpu_is_at91sam9x5())
+			utmi_clk.pmc_mask |= AT91_PMC_BIASEN;
 	}
 
 	/*
@@ -736,7 +778,7 @@
 	mckr = at91_sys_read(AT91_PMC_MCKR);
 	mck.parent = at91_css_to_clk(mckr & AT91_PMC_CSS);
 	freq = mck.parent->rate_hz;
-	freq /= (1 << ((mckr & AT91_PMC_PRES) >> 2));				/* prescale */
+	freq /= pmc_prescaler_divider(mckr);					/* prescale */
 	if (cpu_is_at91rm9200()) {
 		mck.rate_hz = freq / (1 + ((mckr & AT91_PMC_MDIV) >> 8));	/* mdiv */
 	} else if (cpu_is_at91sam9g20()) {
@@ -744,13 +786,19 @@
 			freq / ((mckr & AT91_PMC_MDIV) >> 7) : freq;	/* mdiv ; (x >> 7) = ((x >> 8) * 2) */
 		if (mckr & AT91_PMC_PDIV)
 			freq /= 2;		/* processor clock division */
-	} else if (cpu_is_at91sam9g45()) {
+	} else if (cpu_has_mdiv3()) {
 		mck.rate_hz = (mckr & AT91_PMC_MDIV) == AT91SAM9_PMC_MDIV_3 ?
 			freq / 3 : freq / (1 << ((mckr & AT91_PMC_MDIV) >> 8));	/* mdiv */
 	} else {
 		mck.rate_hz = freq / (1 << ((mckr & AT91_PMC_MDIV) >> 8));		/* mdiv */
 	}
 
+	if (cpu_has_alt_prescaler()) {
+		/* Programmable clocks can use MCK */
+		mck.type |= CLK_TYPE_PRIMARY;
+		mck.id = 4;
+	}
+
 	/* Register the PMC's standard clocks */
 	for (i = 0; i < ARRAY_SIZE(standard_pmc_clocks); i++)
 		list_add_tail(&standard_pmc_clocks[i]->node, &clocks);
Index: linux-2.6.35/arch/arm/mach-at91/board-sam9x5ek.c
===================================================================
--- linux-2.6.35/arch/arm/mach-at91/board-sam9x5ek.c	(revision 0)
+++ linux-2.6.35/arch/arm/mach-at91/board-sam9x5ek.c	(revision 150)
@@ -0,0 +1,395 @@
+/*
+ *  Board-specific setup code for the AT91SAM9x5 Evaluation Kit family
+ *
+ *  Copyright (C) 2010 Atmel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/spi/flash.h>
+#include <linux/spi/spi.h>
+#include <linux/fb.h>
+#include <linux/gpio_keys.h>
+#include <linux/input.h>
+#include <linux/leds.h>
+#include <linux/clk.h>
+#include <mach/cpu.h>
+
+#include <video/atmel_lcdc.h>
+#include <mach/atmel_hlcdfb.h>
+#include <media/atmel-isi.h>
+
+#include <asm/setup.h>
+#include <asm/mach-types.h>
+#include <asm/irq.h>
+
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/mach/irq.h>
+
+#include <mach/hardware.h>
+#include <mach/board.h>
+#include <mach/gpio.h>
+#include <mach/at91sam9_smc.h>
+#include <mach/at91_shdwc.h>
+
+#include "sam9_smc.h"
+#include "generic.h"
+#include <mach/board-sam9x5.h>
+
+static void __init ek_map_io(void)
+{
+	/* Initialize processor and DBGU */
+	cm_map_io();
+
+	/* USART0 on ttyS1. (Rx, Tx, RTS, CTS) */
+	at91_register_uart(AT91SAM9X5_ID_USART0, 1, 0);
+}
+
+/*
+ * USB Host port (OHCI)
+ */
+/* Port A is shared with gadget port & Port C is full-speed only */
+static struct at91_usbh_data __initdata ek_usbh_fs_data = {
+	.ports		= 3,
+
+};
+
+/*
+ * USB HS Host port (EHCI)
+ */
+/* Port A is shared with gadget port */
+static struct at91_usbh_data __initdata ek_usbh_hs_data = {
+	.ports		= 2,
+};
+
+
+/*
+ * USB HS Device port
+ */
+static struct usba_platform_data __initdata ek_usba_udc_data;
+
+
+/*
+ * MACB Ethernet devices
+ */
+static struct at91_eth_data __initdata ek_macb0_data = {
+	.is_rmii	= 1,
+};
+
+static struct at91_eth_data __initdata ek_macb1_data = {
+	.phy_irq_pin	= AT91_PIN_PC26,
+	.is_rmii	= 1,
+};
+
+
+/*
+ * MCI (SD/MMC)
+ */
+/* mci0 detect_pin is revision dependent */
+static struct mci_platform_data __initdata mci0_data = {
+	.slot[0] = {
+		.bus_width	= 4,
+		.wp_pin		= -1,
+	},
+};
+
+static struct mci_platform_data __initdata mci1_data = {
+	.slot[0] = {
+		.bus_width	= 4,
+		.detect_pin	= AT91_PIN_PD14,
+		.wp_pin		= -1,
+	},
+};
+
+
+/*
+ *  ISI
+ */
+#if defined(CONFIG_VIDEO_ATMEL_ISI) || defined(CONFIG_VIDEO_ATMEL_ISI_MODULE) || defined(CONFIG_VIDEO_OV2640) || defined(CONFIG_VIDEO_OV9655)
+static struct isi_platform_data __initdata isi_data = {
+	.image_hsize	= 320,
+	.image_vsize	= 240,
+	.prev_hsize	= 320,
+	.prev_vsize	= 240,
+	.frate		= 0,
+	.pixfmt		= ATMEL_ISI_PIXFMT_YCbYCr,
+	.capture_v4l2_fmt = V4L2_PIX_FMT_YUYV,
+	.streaming_v4l2_fmt = V4L2_PIX_FMT_YUYV,
+	/* to use codec and preview path simultaneously */
+	.cr1_flags		= ISI_FULL,
+};
+
+static void __init isi_set_clk(void)
+{
+	struct clk *pck0;
+	struct clk *plla;
+
+	pck0 = clk_get(NULL, "pck0");
+	plla = clk_get(NULL, "plla");
+
+#if defined(CONFIG_VIDEO_OV2640)
+	/* Power down */
+	at91_set_gpio_output(AT91_PIN_PA13, 1);
+	/* reset */
+	at91_set_gpio_output(AT91_PIN_PA7, 0);
+	/* Power down disable */
+	at91_set_gpio_output(AT91_PIN_PA13, 0);
+	/* reset disable */
+	at91_set_gpio_output(AT91_PIN_PA7, 1);
+#endif
+
+	clk_set_parent(pck0, plla);
+	/* for the sensor ov9655: 10< Fclk < 48, Fclk typ = 24MHz */
+	clk_set_rate(pck0, 25000000);
+	clk_enable(pck0);
+}
+#else
+static void __init isi_set_clk(void)
+{
+	struct clk *pck0;
+	pck0 = clk_get(NULL, "pck0");
+}
+
+static struct isi_platform_data __initdata isi_data;
+#endif
+
+
+/*
+ * LCD Controller
+ */
+#if defined(CONFIG_FB_ATMEL) || defined(CONFIG_FB_ATMEL_MODULE)
+static struct fb_videomode at91_tft_vga_modes[] = {
+	{
+		.name           = "LG",
+		.refresh	= 60,
+		.xres		= 800,		.yres		= 480,
+		.pixclock	= KHZ2PICOS(22223),
+
+		.left_margin	= 64,		.right_margin	= 64,
+		.upper_margin	= 22,		.lower_margin	= 21,
+		.hsync_len	= 128,		.vsync_len	= 2,
+
+		.sync		= 0,
+		.vmode		= FB_VMODE_NONINTERLACED,
+	},
+};
+
+static struct fb_monspecs at91fb_default_monspecs = {
+	.manufacturer	= "LG",
+	.monitor        = "LB043WQ1",
+
+	.modedb		= at91_tft_vga_modes,
+	.modedb_len	= ARRAY_SIZE(at91_tft_vga_modes),
+	.hfmin		= 15000,
+	.hfmax		= 17640,
+	.vfmin		= 57,
+	.vfmax		= 67,
+};
+
+/* Default output mode is TFT 24 bit */
+#define AT91SAM9X5_DEFAULT_LCDCFG5	(LCDC_LCDCFG5_MODE_OUTPUT_24BPP)
+
+/* Driver datas */
+static struct atmel_lcdfb_info __initdata ek_lcdc_data = {
+	.lcdcon_is_backlight		= true,
+	.alpha_enabled			= false,
+	.default_bpp			= 16,
+	/* In 9x5 default_lcdcon2 is used for LCDCFG5 */
+	.default_lcdcon2		= AT91SAM9X5_DEFAULT_LCDCFG5,
+	.default_monspecs		= &at91fb_default_monspecs,
+	.guard_time			= 9,
+	.lcd_wiring_mode		= ATMEL_LCDC_WIRING_RGB,
+};
+
+#else
+static struct atmel_lcdfb_info __initdata ek_lcdc_data;
+#endif
+
+/*
+ * Touchscreen
+ */
+static struct at91_tsadcc_data ek_tsadcc_data = {
+	.adc_clock		= 300000,
+	.filtering_average	= 0x03,	/* averages 2^filtering_average ADC conversions */
+	.pendet_debounce	= 0x08,
+	.ts_sample_hold_time	= 0x0a,
+};
+
+/*
+ * GPIO Buttons
+ */
+#if defined(CONFIG_KEYBOARD_GPIO) || defined(CONFIG_KEYBOARD_GPIO_MODULE)
+static struct gpio_keys_button ek_buttons[] = {
+	{	/* BP3, "leftclic" */
+		.code		= BTN_LEFT,
+		.gpio		= AT91_PIN_PD18,
+		.active_low	= 1,
+		.desc		= "left_click",
+		.wakeup		= 1,
+	},
+	{	/* BP4, "rightclic" */
+		.code		= BTN_RIGHT,
+		.gpio		= AT91_PIN_PD19,
+		.active_low	= 1,
+		.desc		= "right_click",
+		.wakeup		= 1,
+	},
+};
+
+static struct gpio_keys_platform_data ek_button_data = {
+	.buttons	= ek_buttons,
+	.nbuttons	= ARRAY_SIZE(ek_buttons),
+};
+
+static struct platform_device ek_button_device = {
+	.name		= "gpio-keys",
+	.id		= -1,
+	.num_resources	= 0,
+	.dev		= {
+		.platform_data	= &ek_button_data,
+	}
+};
+
+static void __init ek_add_device_buttons(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(ek_buttons); i++) {
+		at91_set_pulldown(ek_buttons[i].gpio, 0);
+		at91_set_gpio_input(ek_buttons[i].gpio, 1);
+		at91_set_deglitch(ek_buttons[i].gpio, 1);
+	}
+
+	platform_device_register(&ek_button_device);
+}
+#else
+static void __init ek_add_device_buttons(void) {}
+#endif
+
+/*
+ * I2C Devices
+ */
+static struct i2c_board_info __initdata ek_i2c_devices[] = {
+	{
+		I2C_BOARD_INFO("wm8731", 0x1a)
+	},
+	{
+		.type = "qt1070",
+		.addr = 0x1b,
+		.irq = AT91_PIN_PA7,
+	},
+};
+
+
+
+static void __init ek_board_configure_pins(void)
+{
+	if (ek_is_revA()) {
+		/* Port A is shared with gadget port */
+		/*ek_usbh_fs_data.vbus_pin[0] = AT91_PIN_PD9;*/
+		/*ek_usbh_hs_data.vbus_pin[0] = AT91_PIN_PD9;*/
+		ek_usbh_fs_data.vbus_pin[1] = AT91_PIN_PD10;
+		ek_usbh_hs_data.vbus_pin[1] = AT91_PIN_PD10;
+		/* Port C is full-speed only */
+		ek_usbh_fs_data.vbus_pin[2] = AT91_PIN_PD11;
+
+		ek_usba_udc_data.vbus_pin = AT91_PIN_PB8;
+
+		ek_macb0_data.phy_irq_pin = 0;
+
+		mci0_data.slot[0].detect_pin = AT91_PIN_PD13;
+	} else {
+		/* Port A is shared with gadget port */
+		/*ek_usbh_fs_data.vbus_pin[0] = AT91_PIN_PD18;*/
+		/*ek_usbh_hs_data.vbus_pin[0] = AT91_PIN_PD18;*/
+		ek_usbh_fs_data.vbus_pin[1] = AT91_PIN_PD19;
+		ek_usbh_hs_data.vbus_pin[1] = AT91_PIN_PD19;
+		/* Port C is full-speed only */
+		ek_usbh_fs_data.vbus_pin[2] = AT91_PIN_PD20;
+
+		ek_usba_udc_data.vbus_pin = AT91_PIN_PB16;
+
+		ek_macb0_data.phy_irq_pin = AT91_PIN_PB8;
+
+		mci0_data.slot[0].detect_pin = AT91_PIN_PD15;
+	}
+}
+
+
+static void __init ek_board_init(void)
+{
+	u32 cm_config;
+
+	cm_board_init(&cm_config);
+	ek_board_configure_pins();
+	/* Serial */
+	at91_add_device_serial();
+	at91_add_device_usba(&ek_usba_udc_data);
+	/* Ethernet */
+	at91_add_device_eth(0, &ek_macb0_data);
+	at91_add_device_eth(1, &ek_macb1_data);
+	/* MMC */
+	at91_add_device_mci(0, &mci0_data);
+	/* Conflict between SPI0 and MCI1 pins */
+	if (!(cm_config & CM_CONFIG_SPI0_ENABLE))
+		at91_add_device_mci(1, &mci1_data);
+	/* I2C */
+	if (cm_config & CM_CONFIG_I2C0_ENABLE)
+		i2c_register_board_info(0,
+				ek_i2c_devices, ARRAY_SIZE(ek_i2c_devices));
+	else
+		at91_add_device_i2c(0,
+				ek_i2c_devices, ARRAY_SIZE(ek_i2c_devices));
+
+	if (cpu_is_at91sam9g25()) {
+		/* ISI */
+		/* NOTE: PCK0 provides ISI_MCK to the ISI module.
+		   ISI's PWD pin conflict with MCI1_CK due the hardware design.
+		 */
+		isi_set_clk();
+		at91_add_device_isi(&isi_data);
+	} else if (!cpu_is_at91sam9x25()) {
+		/* LCD Controller */
+		at91_add_device_lcdc(&ek_lcdc_data);
+		/* Touch Screen */
+		at91_add_device_tsadcc(&ek_tsadcc_data);
+	}
+	/* Push Buttons */
+	if (ek_is_revA())
+		ek_add_device_buttons();
+
+	if (!cpu_is_at91sam9g25()) {
+		/* conflict with ISI. */
+		at91_set_gpio_input(AT91_PIN_PA7, 1);
+	}
+
+	/* SSC (for WM8731) */
+	at91_add_device_ssc(AT91SAM9X5_ID_SSC, ATMEL_SSC_TX | ATMEL_SSC_RX);
+	/* TODO Remove: only for debugging */
+	if (ek_is_revA())
+		printk(KERN_CRIT "AT91: EK rev A\n");
+	else
+		printk(KERN_CRIT "AT91: EK rev B and higher\n");
+
+}
+
+MACHINE_START(AT91SAM9X5EK, "Atmel AT91SAM9X5-EK")
+	/* Maintainer: Atmel */
+	.phys_io	= AT91_BASE_SYS,
+	.io_pg_offst	= (AT91_VA_BASE_SYS >> 18) & 0xfffc,
+	.boot_params	= AT91_SDRAM_BASE + 0x100,
+	.timer		= &at91sam926x_timer,
+	.map_io		= ek_map_io,
+	.init_irq	= cm_init_irq,
+	.init_machine	= ek_board_init,
+MACHINE_END
Index: linux-2.6.35/arch/arm/Kconfig
===================================================================
--- linux-2.6.35/arch/arm/Kconfig	(revision 149)
+++ linux-2.6.35/arch/arm/Kconfig	(revision 150)
@@ -273,7 +273,6 @@
 	bool "Atmel AT91"
 	select ARCH_REQUIRE_GPIOLIB
 	select HAVE_CLK
-	select ARCH_USES_GETTIMEOFFSET
 	help
 	  This enables support for systems based on the Atmel AT91RM9200,
 	  AT91SAM9 and AT91CAP9 processors.
@@ -1027,6 +1026,18 @@
 	   is not correctly implemented in PL310 as clean lines are not
 	   invalidated as a result of these operations. Note that this errata
 	   uses Texas Instrument's secure monitor api.
+
+config ARM_ERRATA_720789
+	bool "ARM errata: TLBIASIDIS and TLBIMVAIS operations can broadcast a faulty ASID"
+	depends on CPU_V7 && SMP
+	help
+	  This option enables the workaround for the 720789 Cortex-A9 (prior to
+	  r2p0) erratum. A faulty ASID can be sent to the other CPUs for the
+	  broadcasted CP15 TLB maintenance operations TLBIASIDIS and TLBIMVAIS.
+	  As a consequence of this erratum, some TLB entries which should be
+	  invalidated are not, resulting in an incoherency in the system page
+	  tables. The workaround changes the TLB flushing routines to invalidate
+	  entries regardless of the ASID.
 endmenu
 
 source "arch/arm/common/Kconfig"
Index: linux-2.6.35/arch/arm/configs/at91sam9x5ek_defconfig
===================================================================
--- linux-2.6.35/arch/arm/configs/at91sam9x5ek_defconfig	(revision 0)
+++ linux-2.6.35/arch/arm/configs/at91sam9x5ek_defconfig	(revision 150)
@@ -0,0 +1,1884 @@
+#
+# Automatically generated make config: don't edit
+# Linux kernel version: 2.6.35
+# Mon Aug  8 17:55:15 2011
+#
+CONFIG_ARM=y
+CONFIG_SYS_SUPPORTS_APM_EMULATION=y
+CONFIG_GENERIC_GPIO=y
+CONFIG_GENERIC_TIME=y
+# CONFIG_ARCH_USES_GETTIMEOFFSET is not set
+CONFIG_GENERIC_CLOCKEVENTS=y
+CONFIG_HAVE_PROC_CPU=y
+CONFIG_GENERIC_HARDIRQS=y
+CONFIG_STACKTRACE_SUPPORT=y
+CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+CONFIG_LOCKDEP_SUPPORT=y
+CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+CONFIG_HARDIRQS_SW_RESEND=y
+CONFIG_GENERIC_IRQ_PROBE=y
+CONFIG_RWSEM_GENERIC_SPINLOCK=y
+CONFIG_GENERIC_HWEIGHT=y
+CONFIG_GENERIC_CALIBRATE_DELAY=y
+CONFIG_NEED_DMA_MAP_STATE=y
+CONFIG_GENERIC_HARDIRQS_NO__DO_IRQ=y
+CONFIG_VECTORS_BASE=0xffff0000
+CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+CONFIG_CONSTRUCTORS=y
+
+#
+# General setup
+#
+CONFIG_EXPERIMENTAL=y
+CONFIG_BROKEN_ON_SMP=y
+CONFIG_LOCK_KERNEL=y
+CONFIG_INIT_ENV_ARG_LIMIT=32
+CONFIG_CROSS_COMPILE=""
+CONFIG_LOCALVERSION=""
+# CONFIG_LOCALVERSION_AUTO is not set
+CONFIG_HAVE_KERNEL_GZIP=y
+CONFIG_HAVE_KERNEL_LZMA=y
+CONFIG_HAVE_KERNEL_LZO=y
+CONFIG_KERNEL_GZIP=y
+# CONFIG_KERNEL_BZIP2 is not set
+# CONFIG_KERNEL_LZMA is not set
+# CONFIG_KERNEL_LZO is not set
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_SYSVIPC_SYSCTL=y
+# CONFIG_POSIX_MQUEUE is not set
+# CONFIG_BSD_PROCESS_ACCT is not set
+# CONFIG_TASKSTATS is not set
+# CONFIG_AUDIT is not set
+
+#
+# RCU Subsystem
+#
+CONFIG_TREE_RCU=y
+# CONFIG_TREE_PREEMPT_RCU is not set
+# CONFIG_TINY_RCU is not set
+# CONFIG_RCU_TRACE is not set
+CONFIG_RCU_FANOUT=32
+# CONFIG_RCU_FANOUT_EXACT is not set
+# CONFIG_TREE_RCU_TRACE is not set
+CONFIG_IKCONFIG=y
+CONFIG_IKCONFIG_PROC=y
+CONFIG_LOG_BUF_SHIFT=14
+# CONFIG_CGROUPS is not set
+# CONFIG_SYSFS_DEPRECATED_V2 is not set
+# CONFIG_RELAY is not set
+CONFIG_NAMESPACES=y
+# CONFIG_UTS_NS is not set
+# CONFIG_IPC_NS is not set
+# CONFIG_USER_NS is not set
+# CONFIG_PID_NS is not set
+# CONFIG_NET_NS is not set
+# CONFIG_BLK_DEV_INITRD is not set
+CONFIG_CC_OPTIMIZE_FOR_SIZE=y
+CONFIG_SYSCTL=y
+CONFIG_ANON_INODES=y
+# CONFIG_EMBEDDED is not set
+CONFIG_UID16=y
+CONFIG_SYSCTL_SYSCALL=y
+CONFIG_KALLSYMS=y
+# CONFIG_KALLSYMS_EXTRA_PASS is not set
+CONFIG_HOTPLUG=y
+CONFIG_PRINTK=y
+CONFIG_BUG=y
+CONFIG_ELF_CORE=y
+CONFIG_BASE_FULL=y
+CONFIG_FUTEX=y
+CONFIG_EPOLL=y
+CONFIG_SIGNALFD=y
+CONFIG_TIMERFD=y
+CONFIG_EVENTFD=y
+CONFIG_SHMEM=y
+CONFIG_AIO=y
+CONFIG_HAVE_PERF_EVENTS=y
+CONFIG_PERF_USE_VMALLOC=y
+
+#
+# Kernel Performance Events And Counters
+#
+# CONFIG_PERF_EVENTS is not set
+# CONFIG_PERF_COUNTERS is not set
+CONFIG_VM_EVENT_COUNTERS=y
+CONFIG_COMPAT_BRK=y
+CONFIG_SLAB=y
+# CONFIG_SLUB is not set
+# CONFIG_SLOB is not set
+# CONFIG_PROFILING is not set
+CONFIG_HAVE_OPROFILE=y
+# CONFIG_KPROBES is not set
+CONFIG_HAVE_KPROBES=y
+CONFIG_HAVE_KRETPROBES=y
+CONFIG_HAVE_CLK=y
+
+#
+# GCOV-based kernel profiling
+#
+# CONFIG_SLOW_WORK is not set
+CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+CONFIG_SLABINFO=y
+CONFIG_RT_MUTEXES=y
+CONFIG_BASE_SMALL=0
+CONFIG_MODULES=y
+CONFIG_MODULE_FORCE_LOAD=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_MODULE_FORCE_UNLOAD=y
+# CONFIG_MODVERSIONS is not set
+# CONFIG_MODULE_SRCVERSION_ALL is not set
+CONFIG_BLOCK=y
+CONFIG_LBDAF=y
+# CONFIG_BLK_DEV_BSG is not set
+# CONFIG_BLK_DEV_INTEGRITY is not set
+
+#
+# IO Schedulers
+#
+CONFIG_IOSCHED_NOOP=y
+# CONFIG_IOSCHED_DEADLINE is not set
+# CONFIG_IOSCHED_CFQ is not set
+# CONFIG_DEFAULT_DEADLINE is not set
+# CONFIG_DEFAULT_CFQ is not set
+CONFIG_DEFAULT_NOOP=y
+CONFIG_DEFAULT_IOSCHED="noop"
+# CONFIG_INLINE_SPIN_TRYLOCK is not set
+# CONFIG_INLINE_SPIN_TRYLOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK is not set
+# CONFIG_INLINE_SPIN_LOCK_BH is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_SPIN_UNLOCK is not set
+# CONFIG_INLINE_SPIN_UNLOCK_BH is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQ is not set
+# CONFIG_INLINE_SPIN_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_READ_TRYLOCK is not set
+# CONFIG_INLINE_READ_LOCK is not set
+# CONFIG_INLINE_READ_LOCK_BH is not set
+# CONFIG_INLINE_READ_LOCK_IRQ is not set
+# CONFIG_INLINE_READ_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_READ_UNLOCK is not set
+# CONFIG_INLINE_READ_UNLOCK_BH is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQ is not set
+# CONFIG_INLINE_READ_UNLOCK_IRQRESTORE is not set
+# CONFIG_INLINE_WRITE_TRYLOCK is not set
+# CONFIG_INLINE_WRITE_LOCK is not set
+# CONFIG_INLINE_WRITE_LOCK_BH is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_LOCK_IRQSAVE is not set
+# CONFIG_INLINE_WRITE_UNLOCK is not set
+# CONFIG_INLINE_WRITE_UNLOCK_BH is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQ is not set
+# CONFIG_INLINE_WRITE_UNLOCK_IRQRESTORE is not set
+# CONFIG_MUTEX_SPIN_ON_OWNER is not set
+CONFIG_FREEZER=y
+
+#
+# System Type
+#
+CONFIG_MMU=y
+# CONFIG_ARCH_AAEC2000 is not set
+# CONFIG_ARCH_INTEGRATOR is not set
+# CONFIG_ARCH_REALVIEW is not set
+# CONFIG_ARCH_VERSATILE is not set
+# CONFIG_ARCH_VEXPRESS is not set
+CONFIG_ARCH_AT91=y
+# CONFIG_ARCH_BCMRING is not set
+# CONFIG_ARCH_CLPS711X is not set
+# CONFIG_ARCH_CNS3XXX is not set
+# CONFIG_ARCH_GEMINI is not set
+# CONFIG_ARCH_EBSA110 is not set
+# CONFIG_ARCH_EP93XX is not set
+# CONFIG_ARCH_FOOTBRIDGE is not set
+# CONFIG_ARCH_MXC is not set
+# CONFIG_ARCH_STMP3XXX is not set
+# CONFIG_ARCH_NETX is not set
+# CONFIG_ARCH_H720X is not set
+# CONFIG_ARCH_IOP13XX is not set
+# CONFIG_ARCH_IOP32X is not set
+# CONFIG_ARCH_IOP33X is not set
+# CONFIG_ARCH_IXP23XX is not set
+# CONFIG_ARCH_IXP2000 is not set
+# CONFIG_ARCH_IXP4XX is not set
+# CONFIG_ARCH_L7200 is not set
+# CONFIG_ARCH_DOVE is not set
+# CONFIG_ARCH_KIRKWOOD is not set
+# CONFIG_ARCH_LOKI is not set
+# CONFIG_ARCH_MV78XX0 is not set
+# CONFIG_ARCH_ORION5X is not set
+# CONFIG_ARCH_MMP is not set
+# CONFIG_ARCH_KS8695 is not set
+# CONFIG_ARCH_NS9XXX is not set
+# CONFIG_ARCH_W90X900 is not set
+# CONFIG_ARCH_NUC93X is not set
+# CONFIG_ARCH_PNX4008 is not set
+# CONFIG_ARCH_PXA is not set
+# CONFIG_ARCH_MSM is not set
+# CONFIG_ARCH_SHMOBILE is not set
+# CONFIG_ARCH_RPC is not set
+# CONFIG_ARCH_SA1100 is not set
+# CONFIG_ARCH_S3C2410 is not set
+# CONFIG_ARCH_S3C64XX is not set
+# CONFIG_ARCH_S5P6440 is not set
+# CONFIG_ARCH_S5P6442 is not set
+# CONFIG_ARCH_S5PC100 is not set
+# CONFIG_ARCH_S5PV210 is not set
+# CONFIG_ARCH_SHARK is not set
+# CONFIG_ARCH_LH7A40X is not set
+# CONFIG_ARCH_U300 is not set
+# CONFIG_ARCH_U8500 is not set
+# CONFIG_ARCH_NOMADIK is not set
+# CONFIG_ARCH_DAVINCI is not set
+# CONFIG_ARCH_OMAP is not set
+# CONFIG_PLAT_SPEAR is not set
+
+#
+# Atmel AT91 System-on-Chip
+#
+# CONFIG_ARCH_AT91RM9200 is not set
+# CONFIG_ARCH_AT91SAM9260 is not set
+# CONFIG_ARCH_AT91SAM9261 is not set
+# CONFIG_ARCH_AT91SAM9G10 is not set
+# CONFIG_ARCH_AT91SAM9263 is not set
+# CONFIG_ARCH_AT91SAM9RL is not set
+# CONFIG_ARCH_AT91SAM9G20 is not set
+# CONFIG_ARCH_AT91SAM9G45 is not set
+CONFIG_ARCH_AT91SAM9X5=y
+# CONFIG_ARCH_AT91CAP9 is not set
+# CONFIG_ARCH_AT572D940HF is not set
+# CONFIG_ARCH_AT91X40 is not set
+CONFIG_AT91_PMC_UNIT=y
+# CONFIG_CHIP_SAM9G15 is not set
+# CONFIG_CHIP_SAM9G25 is not set
+# CONFIG_CHIP_SAM9X25 is not set
+CONFIG_CHIP_SAM9G35=y
+# CONFIG_CHIP_SAM9X35 is not set
+
+#
+# AT91SAM9x5 Series Board Type
+#
+CONFIG_MACH_AT91SAM9X5EK=y
+
+#
+# AT91 Board Options
+#
+
+#
+# AT91 Feature Selections
+#
+CONFIG_AT91_PROGRAMMABLE_CLOCKS=y
+# CONFIG_AT91_SLOW_CLOCK is not set
+CONFIG_AT91_TIMER_HZ=100
+CONFIG_AT91_EARLY_DBGU=y
+# CONFIG_AT91_EARLY_USART0 is not set
+# CONFIG_AT91_EARLY_USART1 is not set
+# CONFIG_AT91_EARLY_USART2 is not set
+# CONFIG_AT91_EARLY_USART3 is not set
+# CONFIG_AT91_EARLY_USART4 is not set
+# CONFIG_AT91_EARLY_USART5 is not set
+
+#
+# Processor Type
+#
+CONFIG_CPU_ARM926T=y
+CONFIG_CPU_32v5=y
+CONFIG_CPU_ABRT_EV5TJ=y
+CONFIG_CPU_PABRT_LEGACY=y
+CONFIG_CPU_CACHE_VIVT=y
+CONFIG_CPU_COPY_V4WB=y
+CONFIG_CPU_TLB_V4WBI=y
+CONFIG_CPU_CP15=y
+CONFIG_CPU_CP15_MMU=y
+
+#
+# Processor Features
+#
+CONFIG_ARM_THUMB=y
+# CONFIG_CPU_ICACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_DISABLE is not set
+# CONFIG_CPU_DCACHE_WRITETHROUGH is not set
+# CONFIG_CPU_CACHE_ROUND_ROBIN is not set
+CONFIG_ARM_L1_CACHE_SHIFT=5
+
+#
+# Bus support
+#
+# CONFIG_PCI_SYSCALL is not set
+# CONFIG_ARCH_SUPPORTS_MSI is not set
+# CONFIG_PCCARD is not set
+
+#
+# Kernel Features
+#
+CONFIG_TICK_ONESHOT=y
+CONFIG_NO_HZ=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+CONFIG_VMSPLIT_3G=y
+# CONFIG_VMSPLIT_2G is not set
+# CONFIG_VMSPLIT_1G is not set
+CONFIG_PAGE_OFFSET=0xC0000000
+# CONFIG_PREEMPT_NONE is not set
+# CONFIG_PREEMPT_VOLUNTARY is not set
+CONFIG_PREEMPT=y
+CONFIG_HZ=100
+CONFIG_AEABI=y
+CONFIG_OABI_COMPAT=y
+# CONFIG_ARCH_SPARSEMEM_DEFAULT is not set
+# CONFIG_ARCH_SELECT_MEMORY_MODEL is not set
+# CONFIG_HIGHMEM is not set
+CONFIG_SELECT_MEMORY_MODEL=y
+CONFIG_FLATMEM_MANUAL=y
+# CONFIG_DISCONTIGMEM_MANUAL is not set
+# CONFIG_SPARSEMEM_MANUAL is not set
+CONFIG_FLATMEM=y
+CONFIG_FLAT_NODE_MEM_MAP=y
+CONFIG_PAGEFLAGS_EXTENDED=y
+CONFIG_SPLIT_PTLOCK_CPUS=999999
+# CONFIG_PHYS_ADDR_T_64BIT is not set
+CONFIG_ZONE_DMA_FLAG=0
+CONFIG_VIRT_TO_BUS=y
+# CONFIG_KSM is not set
+CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+CONFIG_LEDS=y
+CONFIG_LEDS_CPU=y
+CONFIG_ALIGNMENT_TRAP=y
+# CONFIG_UACCESS_WITH_MEMCPY is not set
+
+#
+# Boot options
+#
+CONFIG_ZBOOT_ROM_TEXT=0x0
+CONFIG_ZBOOT_ROM_BSS=0x0
+CONFIG_CMDLINE="mem=128M console=ttyS0,115200 root=/dev/nfs rw nfsroot=10.217.2.52:/nfsroot/dliang/buildroot nfsaddrs=10.217.2.200:10.217.2.52:10.217.2.250:255.255.255.0"
+# CONFIG_CMDLINE_FORCE is not set
+# CONFIG_XIP_KERNEL is not set
+# CONFIG_KEXEC is not set
+
+#
+# CPU Power Management
+#
+CONFIG_CPU_IDLE=y
+CONFIG_CPU_IDLE_GOV_LADDER=y
+CONFIG_CPU_IDLE_GOV_MENU=y
+
+#
+# Floating point emulation
+#
+
+#
+# At least one emulation must be selected
+#
+CONFIG_FPE_NWFPE=y
+# CONFIG_FPE_NWFPE_XP is not set
+# CONFIG_FPE_FASTFPE is not set
+# CONFIG_VFP is not set
+
+#
+# Userspace binary formats
+#
+CONFIG_BINFMT_ELF=y
+# CONFIG_CORE_DUMP_DEFAULT_ELF_HEADERS is not set
+CONFIG_HAVE_AOUT=y
+# CONFIG_BINFMT_AOUT is not set
+# CONFIG_BINFMT_MISC is not set
+
+#
+# Power management options
+#
+CONFIG_PM=y
+# CONFIG_PM_DEBUG is not set
+CONFIG_PM_SLEEP=y
+CONFIG_SUSPEND_NVS=y
+CONFIG_SUSPEND=y
+CONFIG_SUSPEND_FREEZER=y
+CONFIG_APM_EMULATION=y
+# CONFIG_PM_RUNTIME is not set
+CONFIG_PM_OPS=y
+CONFIG_ARCH_SUSPEND_POSSIBLE=y
+CONFIG_NET=y
+
+#
+# Networking options
+#
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+# CONFIG_NET_KEY is not set
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+# CONFIG_IP_ADVANCED_ROUTER is not set
+CONFIG_IP_FIB_HASH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_IP_PNP_RARP=y
+# CONFIG_NET_IPIP is not set
+# CONFIG_NET_IPGRE is not set
+# CONFIG_IP_MROUTE is not set
+# CONFIG_ARPD is not set
+# CONFIG_SYN_COOKIES is not set
+# CONFIG_INET_AH is not set
+# CONFIG_INET_ESP is not set
+# CONFIG_INET_IPCOMP is not set
+# CONFIG_INET_XFRM_TUNNEL is not set
+# CONFIG_INET_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_TRANSPORT is not set
+# CONFIG_INET_XFRM_MODE_TUNNEL is not set
+# CONFIG_INET_XFRM_MODE_BEET is not set
+# CONFIG_INET_LRO is not set
+CONFIG_INET_DIAG=y
+CONFIG_INET_TCP_DIAG=y
+# CONFIG_TCP_CONG_ADVANCED is not set
+CONFIG_TCP_CONG_CUBIC=y
+CONFIG_DEFAULT_TCP_CONG="cubic"
+# CONFIG_TCP_MD5SIG is not set
+# CONFIG_IPV6 is not set
+# CONFIG_NETWORK_SECMARK is not set
+# CONFIG_NETFILTER is not set
+# CONFIG_IP_DCCP is not set
+# CONFIG_IP_SCTP is not set
+# CONFIG_RDS is not set
+# CONFIG_TIPC is not set
+# CONFIG_ATM is not set
+# CONFIG_L2TP is not set
+# CONFIG_BRIDGE is not set
+# CONFIG_NET_DSA is not set
+# CONFIG_VLAN_8021Q is not set
+# CONFIG_DECNET is not set
+# CONFIG_LLC2 is not set
+# CONFIG_IPX is not set
+# CONFIG_ATALK is not set
+# CONFIG_X25 is not set
+# CONFIG_LAPB is not set
+# CONFIG_ECONET is not set
+# CONFIG_WAN_ROUTER is not set
+# CONFIG_PHONET is not set
+# CONFIG_IEEE802154 is not set
+# CONFIG_NET_SCHED is not set
+# CONFIG_DCB is not set
+
+#
+# Network testing
+#
+# CONFIG_NET_PKTGEN is not set
+# CONFIG_HAMRADIO is not set
+# CONFIG_CAN is not set
+# CONFIG_IRDA is not set
+# CONFIG_BT is not set
+# CONFIG_AF_RXRPC is not set
+CONFIG_WIRELESS=y
+CONFIG_WIRELESS_EXT=y
+CONFIG_WEXT_CORE=y
+CONFIG_WEXT_PROC=y
+CONFIG_WEXT_SPY=y
+CONFIG_WEXT_PRIV=y
+CONFIG_CFG80211=y
+# CONFIG_NL80211_TESTMODE is not set
+# CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+# CONFIG_CFG80211_REG_DEBUG is not set
+CONFIG_CFG80211_DEFAULT_PS=y
+# CONFIG_CFG80211_INTERNAL_REGDB is not set
+CONFIG_CFG80211_WEXT=y
+CONFIG_WIRELESS_EXT_SYSFS=y
+CONFIG_LIB80211=y
+CONFIG_LIB80211_CRYPT_WEP=y
+CONFIG_LIB80211_CRYPT_CCMP=y
+CONFIG_LIB80211_CRYPT_TKIP=y
+# CONFIG_LIB80211_DEBUG is not set
+# CONFIG_MAC80211 is not set
+
+#
+# Some wireless drivers require a rate control algorithm
+#
+# CONFIG_WIMAX is not set
+# CONFIG_RFKILL is not set
+# CONFIG_NET_9P is not set
+# CONFIG_CAIF is not set
+
+#
+# Device Drivers
+#
+
+#
+# Generic Driver Options
+#
+CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+# CONFIG_DEVTMPFS is not set
+CONFIG_STANDALONE=y
+CONFIG_PREVENT_FIRMWARE_BUILD=y
+CONFIG_FW_LOADER=y
+CONFIG_FIRMWARE_IN_KERNEL=y
+CONFIG_EXTRA_FIRMWARE=""
+# CONFIG_SYS_HYPERVISOR is not set
+# CONFIG_CONNECTOR is not set
+CONFIG_MTD=y
+# CONFIG_MTD_DEBUG is not set
+# CONFIG_MTD_TESTS is not set
+CONFIG_MTD_CONCAT=y
+CONFIG_MTD_PARTITIONS=y
+# CONFIG_MTD_REDBOOT_PARTS is not set
+CONFIG_MTD_CMDLINE_PARTS=y
+# CONFIG_MTD_AFS_PARTS is not set
+# CONFIG_MTD_AR7_PARTS is not set
+
+#
+# User Modules And Translation Layers
+#
+CONFIG_MTD_CHAR=y
+CONFIG_MTD_BLKDEVS=y
+CONFIG_MTD_BLOCK=y
+# CONFIG_FTL is not set
+# CONFIG_NFTL is not set
+# CONFIG_INFTL is not set
+# CONFIG_RFD_FTL is not set
+# CONFIG_SSFDC is not set
+# CONFIG_SM_FTL is not set
+# CONFIG_MTD_OOPS is not set
+
+#
+# RAM/ROM/Flash chip drivers
+#
+# CONFIG_MTD_CFI is not set
+# CONFIG_MTD_JEDECPROBE is not set
+CONFIG_MTD_MAP_BANK_WIDTH_1=y
+CONFIG_MTD_MAP_BANK_WIDTH_2=y
+CONFIG_MTD_MAP_BANK_WIDTH_4=y
+# CONFIG_MTD_MAP_BANK_WIDTH_8 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_16 is not set
+# CONFIG_MTD_MAP_BANK_WIDTH_32 is not set
+CONFIG_MTD_CFI_I1=y
+CONFIG_MTD_CFI_I2=y
+# CONFIG_MTD_CFI_I4 is not set
+# CONFIG_MTD_CFI_I8 is not set
+# CONFIG_MTD_RAM is not set
+# CONFIG_MTD_ROM is not set
+# CONFIG_MTD_ABSENT is not set
+
+#
+# Mapping drivers for chip access
+#
+# CONFIG_MTD_COMPLEX_MAPPINGS is not set
+# CONFIG_MTD_PLATRAM is not set
+
+#
+# Self-contained MTD device drivers
+#
+# CONFIG_MTD_SLRAM is not set
+# CONFIG_MTD_PHRAM is not set
+# CONFIG_MTD_MTDRAM is not set
+# CONFIG_MTD_BLOCK2MTD is not set
+
+#
+# Disk-On-Chip Device Drivers
+#
+# CONFIG_MTD_DOC2000 is not set
+# CONFIG_MTD_DOC2001 is not set
+# CONFIG_MTD_DOC2001PLUS is not set
+CONFIG_MTD_NAND_ECC=y
+# CONFIG_MTD_NAND_ECC_SMC is not set
+CONFIG_MTD_NAND=y
+# CONFIG_MTD_NAND_VERIFY_WRITE is not set
+# CONFIG_MTD_SM_COMMON is not set
+# CONFIG_MTD_NAND_MUSEUM_IDS is not set
+CONFIG_MTD_NAND_DENALI_SCRATCH_REG_ADDR=0xFF108018
+# CONFIG_MTD_NAND_GPIO is not set
+CONFIG_MTD_NAND_IDS=y
+# CONFIG_MTD_NAND_DISKONCHIP is not set
+CONFIG_MTD_NAND_ATMEL=y
+# CONFIG_MTD_NAND_ATMEL_ECC_HW is not set
+# CONFIG_MTD_NAND_ATMEL_PMECC_HW is not set
+CONFIG_MTD_NAND_ATMEL_ECC_SOFT=y
+# CONFIG_MTD_NAND_ATMEL_ECC_NONE is not set
+# CONFIG_MTD_NAND_NANDSIM is not set
+# CONFIG_MTD_NAND_PLATFORM is not set
+# CONFIG_MTD_ALAUDA is not set
+# CONFIG_MTD_ONENAND is not set
+
+#
+# LPDDR flash memory drivers
+#
+# CONFIG_MTD_LPDDR is not set
+
+#
+# UBI - Unsorted block images
+#
+CONFIG_MTD_UBI=y
+CONFIG_MTD_UBI_WL_THRESHOLD=4096
+CONFIG_MTD_UBI_BEB_RESERVE=1
+# CONFIG_MTD_UBI_GLUEBI is not set
+
+#
+# UBI debugging options
+#
+# CONFIG_MTD_UBI_DEBUG is not set
+# CONFIG_PARPORT is not set
+CONFIG_BLK_DEV=y
+# CONFIG_BLK_DEV_COW_COMMON is not set
+CONFIG_BLK_DEV_LOOP=y
+# CONFIG_BLK_DEV_CRYPTOLOOP is not set
+
+#
+# DRBD disabled because PROC_FS, INET or CONNECTOR not selected
+#
+# CONFIG_BLK_DEV_NBD is not set
+# CONFIG_BLK_DEV_UB is not set
+CONFIG_BLK_DEV_RAM=y
+CONFIG_BLK_DEV_RAM_COUNT=2
+CONFIG_BLK_DEV_RAM_SIZE=32768
+# CONFIG_BLK_DEV_XIP is not set
+# CONFIG_CDROM_PKTCDVD is not set
+# CONFIG_ATA_OVER_ETH is not set
+# CONFIG_MG_DISK is not set
+CONFIG_MISC_DEVICES=y
+# CONFIG_AD525X_DPOT is not set
+CONFIG_ATMEL_TCLIB=y
+CONFIG_ATMEL_TCB_CLKSRC=y
+CONFIG_ATMEL_TCB_CLKSRC_BLOCK=0
+CONFIG_ATMEL_TCB_CLKSRC_32BIT=y
+# CONFIG_ICS932S401 is not set
+CONFIG_ATMEL_SSC=y
+# CONFIG_ENCLOSURE_SERVICES is not set
+# CONFIG_ISL29003 is not set
+# CONFIG_SENSORS_TSL2550 is not set
+# CONFIG_DS1682 is not set
+# CONFIG_C2PORT is not set
+
+#
+# EEPROM support
+#
+# CONFIG_EEPROM_AT24 is not set
+# CONFIG_EEPROM_LEGACY is not set
+# CONFIG_EEPROM_MAX6875 is not set
+# CONFIG_EEPROM_93CX6 is not set
+# CONFIG_IWMC3200TOP is not set
+CONFIG_HAVE_IDE=y
+# CONFIG_IDE is not set
+
+#
+# SCSI device support
+#
+CONFIG_SCSI_MOD=y
+# CONFIG_RAID_ATTRS is not set
+CONFIG_SCSI=y
+CONFIG_SCSI_DMA=y
+# CONFIG_SCSI_TGT is not set
+# CONFIG_SCSI_NETLINK is not set
+CONFIG_SCSI_PROC_FS=y
+
+#
+# SCSI support type (disk, tape, CD-ROM)
+#
+CONFIG_BLK_DEV_SD=y
+# CONFIG_CHR_DEV_ST is not set
+# CONFIG_CHR_DEV_OSST is not set
+# CONFIG_BLK_DEV_SR is not set
+# CONFIG_CHR_DEV_SG is not set
+# CONFIG_CHR_DEV_SCH is not set
+CONFIG_SCSI_MULTI_LUN=y
+# CONFIG_SCSI_CONSTANTS is not set
+# CONFIG_SCSI_LOGGING is not set
+# CONFIG_SCSI_SCAN_ASYNC is not set
+CONFIG_SCSI_WAIT_SCAN=m
+
+#
+# SCSI Transports
+#
+# CONFIG_SCSI_SPI_ATTRS is not set
+# CONFIG_SCSI_FC_ATTRS is not set
+# CONFIG_SCSI_ISCSI_ATTRS is not set
+# CONFIG_SCSI_SAS_LIBSAS is not set
+# CONFIG_SCSI_SRP_ATTRS is not set
+# CONFIG_SCSI_LOWLEVEL is not set
+# CONFIG_SCSI_DH is not set
+# CONFIG_SCSI_OSD_INITIATOR is not set
+# CONFIG_ATA is not set
+# CONFIG_MD is not set
+CONFIG_NETDEVICES=y
+# CONFIG_DUMMY is not set
+# CONFIG_BONDING is not set
+# CONFIG_MACVLAN is not set
+# CONFIG_EQUALIZER is not set
+# CONFIG_TUN is not set
+# CONFIG_VETH is not set
+CONFIG_PHYLIB=y
+
+#
+# MII PHY device drivers
+#
+# CONFIG_MARVELL_PHY is not set
+CONFIG_DAVICOM_PHY=y
+# CONFIG_QSEMI_PHY is not set
+# CONFIG_LXT_PHY is not set
+# CONFIG_CICADA_PHY is not set
+# CONFIG_VITESSE_PHY is not set
+# CONFIG_SMSC_PHY is not set
+# CONFIG_BROADCOM_PHY is not set
+# CONFIG_ICPLUS_PHY is not set
+# CONFIG_REALTEK_PHY is not set
+# CONFIG_NATIONAL_PHY is not set
+# CONFIG_STE10XP is not set
+# CONFIG_LSI_ET1011C_PHY is not set
+# CONFIG_MICREL_PHY is not set
+# CONFIG_FIXED_PHY is not set
+# CONFIG_MDIO_BITBANG is not set
+CONFIG_NET_ETHERNET=y
+CONFIG_MII=y
+CONFIG_MACB=y
+# CONFIG_AX88796 is not set
+# CONFIG_SMC91X is not set
+# CONFIG_DM9000 is not set
+# CONFIG_ETHOC is not set
+# CONFIG_SMC911X is not set
+# CONFIG_SMSC911X is not set
+# CONFIG_DNET is not set
+# CONFIG_IBM_NEW_EMAC_ZMII is not set
+# CONFIG_IBM_NEW_EMAC_RGMII is not set
+# CONFIG_IBM_NEW_EMAC_TAH is not set
+# CONFIG_IBM_NEW_EMAC_EMAC4 is not set
+# CONFIG_IBM_NEW_EMAC_NO_FLOW_CTRL is not set
+# CONFIG_IBM_NEW_EMAC_MAL_CLR_ICINTSTAT is not set
+# CONFIG_IBM_NEW_EMAC_MAL_COMMON_ERR is not set
+# CONFIG_B44 is not set
+# CONFIG_KS8842 is not set
+# CONFIG_KS8851_MLL is not set
+# CONFIG_NETDEV_1000 is not set
+# CONFIG_NETDEV_10000 is not set
+CONFIG_WLAN=y
+# CONFIG_USB_ZD1201 is not set
+# CONFIG_USB_NET_RNDIS_WLAN is not set
+# CONFIG_ATH_COMMON is not set
+CONFIG_HOSTAP=y
+# CONFIG_HOSTAP_FIRMWARE is not set
+# CONFIG_IWM is not set
+# CONFIG_LIBERTAS is not set
+
+#
+# Enable WiMAX (Networking options) to see the WiMAX drivers
+#
+
+#
+# USB Network Adapters
+#
+# CONFIG_USB_CATC is not set
+# CONFIG_USB_KAWETH is not set
+# CONFIG_USB_PEGASUS is not set
+# CONFIG_USB_RTL8150 is not set
+# CONFIG_USB_USBNET is not set
+# CONFIG_USB_IPHETH is not set
+# CONFIG_WAN is not set
+# CONFIG_PPP is not set
+# CONFIG_SLIP is not set
+# CONFIG_NETCONSOLE is not set
+# CONFIG_NETPOLL is not set
+# CONFIG_NET_POLL_CONTROLLER is not set
+# CONFIG_ISDN is not set
+# CONFIG_PHONE is not set
+
+#
+# Input device support
+#
+CONFIG_INPUT=y
+# CONFIG_INPUT_FF_MEMLESS is not set
+# CONFIG_INPUT_POLLDEV is not set
+# CONFIG_INPUT_SPARSEKMAP is not set
+
+#
+# Userland interfaces
+#
+CONFIG_INPUT_MOUSEDEV=y
+# CONFIG_INPUT_MOUSEDEV_PSAUX is not set
+CONFIG_INPUT_MOUSEDEV_SCREEN_X=320
+CONFIG_INPUT_MOUSEDEV_SCREEN_Y=240
+# CONFIG_INPUT_JOYDEV is not set
+CONFIG_INPUT_EVDEV=y
+# CONFIG_INPUT_EVBUG is not set
+
+#
+# Input Device Drivers
+#
+CONFIG_INPUT_KEYBOARD=y
+# CONFIG_KEYBOARD_ADP5588 is not set
+# CONFIG_KEYBOARD_ATKBD is not set
+CONFIG_KEYBOARD_QT1070=y
+# CONFIG_KEYBOARD_QT2160 is not set
+# CONFIG_KEYBOARD_LKKBD is not set
+# CONFIG_KEYBOARD_GPIO is not set
+# CONFIG_KEYBOARD_TCA6416 is not set
+# CONFIG_KEYBOARD_MATRIX is not set
+# CONFIG_KEYBOARD_LM8323 is not set
+# CONFIG_KEYBOARD_MAX7359 is not set
+# CONFIG_KEYBOARD_NEWTON is not set
+# CONFIG_KEYBOARD_OPENCORES is not set
+# CONFIG_KEYBOARD_STOWAWAY is not set
+# CONFIG_KEYBOARD_SUNKBD is not set
+# CONFIG_KEYBOARD_XTKBD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_INPUT_JOYSTICK is not set
+# CONFIG_INPUT_TABLET is not set
+CONFIG_INPUT_TOUCHSCREEN=y
+# CONFIG_TOUCHSCREEN_AD7879_I2C is not set
+# CONFIG_TOUCHSCREEN_AD7879 is not set
+# CONFIG_TOUCHSCREEN_DYNAPRO is not set
+# CONFIG_TOUCHSCREEN_HAMPSHIRE is not set
+# CONFIG_TOUCHSCREEN_EETI is not set
+# CONFIG_TOUCHSCREEN_FUJITSU is not set
+# CONFIG_TOUCHSCREEN_GUNZE is not set
+# CONFIG_TOUCHSCREEN_ELO is not set
+# CONFIG_TOUCHSCREEN_WACOM_W8001 is not set
+# CONFIG_TOUCHSCREEN_MCS5000 is not set
+# CONFIG_TOUCHSCREEN_MTOUCH is not set
+# CONFIG_TOUCHSCREEN_INEXIO is not set
+# CONFIG_TOUCHSCREEN_MK712 is not set
+# CONFIG_TOUCHSCREEN_PENMOUNT is not set
+# CONFIG_TOUCHSCREEN_TOUCHRIGHT is not set
+# CONFIG_TOUCHSCREEN_TOUCHWIN is not set
+CONFIG_TOUCHSCREEN_ATMEL_TSADCC=y
+# CONFIG_TOUCHSCREEN_WM97XX is not set
+# CONFIG_TOUCHSCREEN_USB_COMPOSITE is not set
+# CONFIG_TOUCHSCREEN_TOUCHIT213 is not set
+# CONFIG_TOUCHSCREEN_TSC2007 is not set
+# CONFIG_TOUCHSCREEN_W90X900 is not set
+# CONFIG_TOUCHSCREEN_TPS6507X is not set
+CONFIG_INPUT_MISC=y
+# CONFIG_INPUT_AD714X is not set
+# CONFIG_INPUT_ATI_REMOTE is not set
+# CONFIG_INPUT_ATI_REMOTE2 is not set
+# CONFIG_INPUT_KEYSPAN_REMOTE is not set
+# CONFIG_INPUT_POWERMATE is not set
+# CONFIG_INPUT_YEALINK is not set
+# CONFIG_INPUT_CM109 is not set
+# CONFIG_INPUT_UINPUT is not set
+# CONFIG_INPUT_PCF8574 is not set
+# CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
+
+#
+# Hardware I/O ports
+#
+CONFIG_SERIO=y
+CONFIG_SERIO_SERPORT=y
+# CONFIG_SERIO_RAW is not set
+# CONFIG_SERIO_ALTERA_PS2 is not set
+# CONFIG_GAMEPORT is not set
+
+#
+# Character devices
+#
+CONFIG_VT=y
+CONFIG_CONSOLE_TRANSLATIONS=y
+CONFIG_VT_CONSOLE=y
+CONFIG_HW_CONSOLE=y
+# CONFIG_VT_HW_CONSOLE_BINDING is not set
+CONFIG_DEVKMEM=y
+# CONFIG_SERIAL_NONSTANDARD is not set
+# CONFIG_N_GSM is not set
+
+#
+# Serial drivers
+#
+# CONFIG_SERIAL_8250 is not set
+
+#
+# Non-8250 serial port support
+#
+CONFIG_SERIAL_ATMEL=y
+CONFIG_SERIAL_ATMEL_CONSOLE=y
+# CONFIG_SERIAL_ATMEL_DMA is not set
+# CONFIG_SERIAL_ATMEL_TTYAT is not set
+CONFIG_SERIAL_CORE=y
+CONFIG_SERIAL_CORE_CONSOLE=y
+# CONFIG_SERIAL_TIMBERDALE is not set
+# CONFIG_SERIAL_ALTERA_JTAGUART is not set
+# CONFIG_SERIAL_ALTERA_UART is not set
+CONFIG_UNIX98_PTYS=y
+# CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+CONFIG_LEGACY_PTYS=y
+CONFIG_LEGACY_PTY_COUNT=16
+# CONFIG_IPMI_HANDLER is not set
+# CONFIG_HW_RANDOM is not set
+# CONFIG_R3964 is not set
+# CONFIG_RAW_DRIVER is not set
+# CONFIG_TCG_TPM is not set
+# CONFIG_RAMOOPS is not set
+CONFIG_I2C=y
+CONFIG_I2C_BOARDINFO=y
+CONFIG_I2C_COMPAT=y
+# CONFIG_I2C_CHARDEV is not set
+CONFIG_I2C_HELPER_AUTO=y
+CONFIG_I2C_ALGOBIT=y
+
+#
+# I2C Hardware Bus support
+#
+
+#
+# I2C system bus drivers (mostly embedded / system-on-chip)
+#
+# CONFIG_I2C_DESIGNWARE is not set
+CONFIG_I2C_GPIO=y
+# CONFIG_I2C_OCORES is not set
+# CONFIG_I2C_PCA_PLATFORM is not set
+# CONFIG_I2C_SIMTEC is not set
+# CONFIG_I2C_XILINX is not set
+
+#
+# External I2C/SMBus adapter drivers
+#
+# CONFIG_I2C_PARPORT_LIGHT is not set
+# CONFIG_I2C_TAOS_EVM is not set
+# CONFIG_I2C_TINY_USB is not set
+
+#
+# Other I2C/SMBus bus drivers
+#
+# CONFIG_I2C_STUB is not set
+# CONFIG_I2C_DEBUG_CORE is not set
+# CONFIG_I2C_DEBUG_ALGO is not set
+# CONFIG_I2C_DEBUG_BUS is not set
+# CONFIG_SPI is not set
+
+#
+# PPS support
+#
+# CONFIG_PPS is not set
+CONFIG_ARCH_REQUIRE_GPIOLIB=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_SYSFS=y
+
+#
+# Memory mapped GPIO expanders:
+#
+# CONFIG_GPIO_IT8761E is not set
+
+#
+# I2C GPIO expanders:
+#
+# CONFIG_GPIO_MAX7300 is not set
+# CONFIG_GPIO_MAX732X is not set
+# CONFIG_GPIO_PCA953X is not set
+# CONFIG_GPIO_PCF857X is not set
+# CONFIG_GPIO_ADP5588 is not set
+
+#
+# PCI GPIO expanders:
+#
+
+#
+# SPI GPIO expanders:
+#
+
+#
+# AC97 GPIO expanders:
+#
+
+#
+# MODULbus GPIO expanders:
+#
+# CONFIG_W1 is not set
+CONFIG_POWER_SUPPLY=y
+# CONFIG_POWER_SUPPLY_DEBUG is not set
+# CONFIG_PDA_POWER is not set
+# CONFIG_APM_POWER is not set
+# CONFIG_TEST_POWER is not set
+# CONFIG_BATTERY_DS2760 is not set
+# CONFIG_BATTERY_DS2782 is not set
+# CONFIG_BATTERY_BQ27x00 is not set
+# CONFIG_BATTERY_MAX17040 is not set
+# CONFIG_HWMON is not set
+# CONFIG_THERMAL is not set
+CONFIG_WATCHDOG=y
+# CONFIG_WATCHDOG_NOWAYOUT is not set
+
+#
+# Watchdog Device Drivers
+#
+# CONFIG_SOFT_WATCHDOG is not set
+CONFIG_AT91SAM9X_WATCHDOG=y
+# CONFIG_MAX63XX_WATCHDOG is not set
+
+#
+# USB-based Watchdog Cards
+#
+# CONFIG_USBPCWATCHDOG is not set
+CONFIG_SSB_POSSIBLE=y
+
+#
+# Sonics Silicon Backplane
+#
+# CONFIG_SSB is not set
+# CONFIG_MFD_SUPPORT is not set
+# CONFIG_REGULATOR is not set
+CONFIG_MEDIA_SUPPORT=y
+
+#
+# Multimedia core support
+#
+# CONFIG_VIDEO_DEV is not set
+# CONFIG_DVB_CORE is not set
+# CONFIG_VIDEO_MEDIA is not set
+
+#
+# Multimedia drivers
+#
+CONFIG_IR_CORE=y
+CONFIG_VIDEO_IR=y
+CONFIG_RC_MAP=y
+CONFIG_IR_NEC_DECODER=y
+CONFIG_IR_RC5_DECODER=y
+CONFIG_IR_RC6_DECODER=y
+CONFIG_IR_JVC_DECODER=y
+CONFIG_IR_SONY_DECODER=y
+# CONFIG_IR_IMON is not set
+CONFIG_DAB=y
+# CONFIG_USB_DABUSB is not set
+
+#
+# Graphics support
+#
+CONFIG_HAVE_FB_ATMEL=y
+# CONFIG_VGASTATE is not set
+CONFIG_VIDEO_OUTPUT_CONTROL=y
+CONFIG_FB=y
+# CONFIG_FIRMWARE_EDID is not set
+# CONFIG_FB_DDC is not set
+# CONFIG_FB_BOOT_VESA_SUPPORT is not set
+CONFIG_FB_CFB_FILLRECT=y
+CONFIG_FB_CFB_COPYAREA=y
+CONFIG_FB_CFB_IMAGEBLIT=y
+# CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+# CONFIG_FB_SYS_FILLRECT is not set
+# CONFIG_FB_SYS_COPYAREA is not set
+# CONFIG_FB_SYS_IMAGEBLIT is not set
+# CONFIG_FB_FOREIGN_ENDIAN is not set
+# CONFIG_FB_SYS_FOPS is not set
+# CONFIG_FB_SVGALIB is not set
+# CONFIG_FB_MACMODES is not set
+# CONFIG_FB_BACKLIGHT is not set
+CONFIG_FB_MODE_HELPERS=y
+CONFIG_FB_TILEBLITTING=y
+
+#
+# Frame buffer hardware drivers
+#
+# CONFIG_FB_S1D13XXX is not set
+CONFIG_FB_ATMEL=y
+# CONFIG_FB_VIRTUAL is not set
+# CONFIG_FB_METRONOME is not set
+# CONFIG_FB_MB862XX is not set
+# CONFIG_FB_BROADSHEET is not set
+CONFIG_BACKLIGHT_LCD_SUPPORT=y
+CONFIG_LCD_CLASS_DEVICE=y
+CONFIG_LCD_PLATFORM=y
+CONFIG_BACKLIGHT_CLASS_DEVICE=y
+CONFIG_BACKLIGHT_ATMEL_LCDC=y
+CONFIG_BACKLIGHT_GENERIC=m
+# CONFIG_BACKLIGHT_ADP8860 is not set
+
+#
+# Display device support
+#
+CONFIG_DISPLAY_SUPPORT=y
+
+#
+# Display hardware drivers
+#
+
+#
+# Console display driver support
+#
+# CONFIG_VGA_CONSOLE is not set
+CONFIG_DUMMY_CONSOLE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+# CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+# CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+CONFIG_FONTS=y
+CONFIG_FONT_8x8=y
+CONFIG_FONT_8x16=y
+# CONFIG_FONT_6x11 is not set
+# CONFIG_FONT_7x14 is not set
+# CONFIG_FONT_PEARL_8x8 is not set
+# CONFIG_FONT_ACORN_8x8 is not set
+# CONFIG_FONT_MINI_4x6 is not set
+# CONFIG_FONT_SUN8x16 is not set
+# CONFIG_FONT_SUN12x22 is not set
+# CONFIG_FONT_10x18 is not set
+# CONFIG_LOGO is not set
+CONFIG_SOUND=y
+# CONFIG_SOUND_OSS_CORE is not set
+CONFIG_SND=y
+CONFIG_SND_TIMER=y
+CONFIG_SND_PCM=y
+CONFIG_SND_JACK=y
+# CONFIG_SND_SEQUENCER is not set
+# CONFIG_SND_MIXER_OSS is not set
+# CONFIG_SND_PCM_OSS is not set
+# CONFIG_SND_HRTIMER is not set
+# CONFIG_SND_DYNAMIC_MINORS is not set
+CONFIG_SND_SUPPORT_OLD_API=y
+CONFIG_SND_VERBOSE_PROCFS=y
+# CONFIG_SND_VERBOSE_PRINTK is not set
+# CONFIG_SND_DEBUG is not set
+CONFIG_SND_VMASTER=y
+# CONFIG_SND_RAWMIDI_SEQ is not set
+# CONFIG_SND_OPL3_LIB_SEQ is not set
+# CONFIG_SND_OPL4_LIB_SEQ is not set
+# CONFIG_SND_SBAWE_SEQ is not set
+# CONFIG_SND_EMU10K1_SEQ is not set
+CONFIG_SND_AC97_CODEC=y
+CONFIG_SND_DRIVERS=y
+# CONFIG_SND_DUMMY is not set
+# CONFIG_SND_MTPAV is not set
+# CONFIG_SND_SERIAL_U16550 is not set
+# CONFIG_SND_MPU401 is not set
+# CONFIG_SND_AC97_POWER_SAVE is not set
+CONFIG_SND_ARM=y
+
+#
+# Atmel devices (AVR32 and AT91)
+#
+CONFIG_SND_ATMEL_AC97C=y
+CONFIG_SND_USB=y
+# CONFIG_SND_USB_AUDIO is not set
+# CONFIG_SND_USB_UA101 is not set
+# CONFIG_SND_USB_CAIAQ is not set
+CONFIG_SND_SOC=y
+CONFIG_SND_ATMEL_SOC=y
+CONFIG_SND_ATMEL_SOC_SSC=y
+CONFIG_SND_AT91_SOC_SAM9X5_WM8731=y
+CONFIG_SND_SOC_I2C_AND_SPI=y
+# CONFIG_SND_SOC_ALL_CODECS is not set
+CONFIG_SND_SOC_WM8731=y
+# CONFIG_SOUND_PRIME is not set
+CONFIG_AC97_BUS=y
+CONFIG_HID_SUPPORT=y
+CONFIG_HID=y
+# CONFIG_HIDRAW is not set
+
+#
+# USB Input Devices
+#
+CONFIG_USB_HID=y
+# CONFIG_HID_PID is not set
+# CONFIG_USB_HIDDEV is not set
+
+#
+# Special HID drivers
+#
+# CONFIG_HID_3M_PCT is not set
+CONFIG_HID_A4TECH=y
+CONFIG_HID_APPLE=y
+CONFIG_HID_BELKIN=y
+# CONFIG_HID_CANDO is not set
+CONFIG_HID_CHERRY=y
+CONFIG_HID_CHICONY=y
+# CONFIG_HID_PRODIKEYS is not set
+CONFIG_HID_CYPRESS=y
+# CONFIG_HID_DRAGONRISE is not set
+# CONFIG_HID_EGALAX is not set
+CONFIG_HID_EZKEY=y
+CONFIG_HID_KYE=y
+# CONFIG_HID_GYRATION is not set
+# CONFIG_HID_TWINHAN is not set
+CONFIG_HID_KENSINGTON=y
+CONFIG_HID_LOGITECH=y
+# CONFIG_LOGITECH_FF is not set
+# CONFIG_LOGIRUMBLEPAD2_FF is not set
+# CONFIG_LOGIG940_FF is not set
+CONFIG_HID_MICROSOFT=y
+# CONFIG_HID_MOSART is not set
+CONFIG_HID_MONTEREY=y
+# CONFIG_HID_NTRIG is not set
+# CONFIG_HID_ORTEK is not set
+# CONFIG_HID_PANTHERLORD is not set
+# CONFIG_HID_PETALYNX is not set
+# CONFIG_HID_PICOLCD is not set
+# CONFIG_HID_QUANTA is not set
+# CONFIG_HID_ROCCAT is not set
+# CONFIG_HID_ROCCAT_KONE is not set
+# CONFIG_HID_SAMSUNG is not set
+# CONFIG_HID_SONY is not set
+# CONFIG_HID_STANTUM is not set
+# CONFIG_HID_SUNPLUS is not set
+# CONFIG_HID_GREENASIA is not set
+# CONFIG_HID_SMARTJOYPLUS is not set
+# CONFIG_HID_TOPSEED is not set
+# CONFIG_HID_THRUSTMASTER is not set
+# CONFIG_HID_ZEROPLUS is not set
+# CONFIG_HID_ZYDACRON is not set
+CONFIG_USB_SUPPORT=y
+CONFIG_USB_ARCH_HAS_HCD=y
+CONFIG_USB_ARCH_HAS_OHCI=y
+CONFIG_USB_ARCH_HAS_EHCI=y
+CONFIG_USB=y
+# CONFIG_USB_DEBUG is not set
+# CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
+
+#
+# Miscellaneous USB options
+#
+# CONFIG_USB_DEVICEFS is not set
+# CONFIG_USB_DEVICE_CLASS is not set
+# CONFIG_USB_DYNAMIC_MINORS is not set
+# CONFIG_USB_MON is not set
+# CONFIG_USB_WUSB is not set
+# CONFIG_USB_WUSB_CBAF is not set
+
+#
+# USB Host Controller Drivers
+#
+# CONFIG_USB_C67X00_HCD is not set
+CONFIG_USB_EHCI_HCD=y
+# CONFIG_USB_EHCI_ROOT_HUB_TT is not set
+# CONFIG_USB_EHCI_TT_NEWSCHED is not set
+# CONFIG_USB_OXU210HP_HCD is not set
+# CONFIG_USB_ISP116X_HCD is not set
+# CONFIG_USB_ISP1760_HCD is not set
+# CONFIG_USB_ISP1362_HCD is not set
+CONFIG_USB_OHCI_HCD=y
+# CONFIG_USB_OHCI_BIG_ENDIAN_DESC is not set
+# CONFIG_USB_OHCI_BIG_ENDIAN_MMIO is not set
+CONFIG_USB_OHCI_LITTLE_ENDIAN=y
+# CONFIG_USB_SL811_HCD is not set
+# CONFIG_USB_R8A66597_HCD is not set
+# CONFIG_USB_HWA_HCD is not set
+# CONFIG_USB_MUSB_HDRC is not set
+# CONFIG_USB_GADGET_MUSB_HDRC is not set
+
+#
+# USB Device Class drivers
+#
+# CONFIG_USB_ACM is not set
+# CONFIG_USB_PRINTER is not set
+# CONFIG_USB_WDM is not set
+# CONFIG_USB_TMC is not set
+
+#
+# NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
+#
+
+#
+# also be needed; see USB_STORAGE Help for more info
+#
+CONFIG_USB_STORAGE=y
+# CONFIG_USB_STORAGE_DEBUG is not set
+# CONFIG_USB_STORAGE_DATAFAB is not set
+# CONFIG_USB_STORAGE_FREECOM is not set
+# CONFIG_USB_STORAGE_ISD200 is not set
+# CONFIG_USB_STORAGE_USBAT is not set
+# CONFIG_USB_STORAGE_SDDR09 is not set
+# CONFIG_USB_STORAGE_SDDR55 is not set
+# CONFIG_USB_STORAGE_JUMPSHOT is not set
+# CONFIG_USB_STORAGE_ALAUDA is not set
+# CONFIG_USB_STORAGE_ONETOUCH is not set
+# CONFIG_USB_STORAGE_KARMA is not set
+# CONFIG_USB_STORAGE_CYPRESS_ATACB is not set
+# CONFIG_USB_LIBUSUAL is not set
+
+#
+# USB Imaging devices
+#
+# CONFIG_USB_MDC800 is not set
+# CONFIG_USB_MICROTEK is not set
+
+#
+# USB port drivers
+#
+CONFIG_USB_SERIAL=y
+# CONFIG_USB_SERIAL_CONSOLE is not set
+# CONFIG_USB_EZUSB is not set
+# CONFIG_USB_SERIAL_GENERIC is not set
+# CONFIG_USB_SERIAL_AIRCABLE is not set
+# CONFIG_USB_SERIAL_ARK3116 is not set
+# CONFIG_USB_SERIAL_BELKIN is not set
+# CONFIG_USB_SERIAL_CH341 is not set
+# CONFIG_USB_SERIAL_WHITEHEAT is not set
+# CONFIG_USB_SERIAL_DIGI_ACCELEPORT is not set
+# CONFIG_USB_SERIAL_CP210X is not set
+# CONFIG_USB_SERIAL_CYPRESS_M8 is not set
+# CONFIG_USB_SERIAL_EMPEG is not set
+# CONFIG_USB_SERIAL_FTDI_SIO is not set
+# CONFIG_USB_SERIAL_FUNSOFT is not set
+# CONFIG_USB_SERIAL_VISOR is not set
+# CONFIG_USB_SERIAL_IPAQ is not set
+# CONFIG_USB_SERIAL_IR is not set
+# CONFIG_USB_SERIAL_EDGEPORT is not set
+# CONFIG_USB_SERIAL_EDGEPORT_TI is not set
+# CONFIG_USB_SERIAL_GARMIN is not set
+# CONFIG_USB_SERIAL_IPW is not set
+# CONFIG_USB_SERIAL_IUU is not set
+# CONFIG_USB_SERIAL_KEYSPAN_PDA is not set
+# CONFIG_USB_SERIAL_KEYSPAN is not set
+# CONFIG_USB_SERIAL_KLSI is not set
+# CONFIG_USB_SERIAL_KOBIL_SCT is not set
+# CONFIG_USB_SERIAL_MCT_U232 is not set
+# CONFIG_USB_SERIAL_MOS7720 is not set
+# CONFIG_USB_SERIAL_MOS7840 is not set
+# CONFIG_USB_SERIAL_MOTOROLA is not set
+# CONFIG_USB_SERIAL_NAVMAN is not set
+# CONFIG_USB_SERIAL_PL2303 is not set
+# CONFIG_USB_SERIAL_OTI6858 is not set
+# CONFIG_USB_SERIAL_QCAUX is not set
+# CONFIG_USB_SERIAL_QUALCOMM is not set
+# CONFIG_USB_SERIAL_SPCP8X5 is not set
+# CONFIG_USB_SERIAL_HP4X is not set
+# CONFIG_USB_SERIAL_SAFE is not set
+# CONFIG_USB_SERIAL_SIEMENS_MPI is not set
+# CONFIG_USB_SERIAL_SIERRAWIRELESS is not set
+# CONFIG_USB_SERIAL_SYMBOL is not set
+# CONFIG_USB_SERIAL_TI is not set
+# CONFIG_USB_SERIAL_CYBERJACK is not set
+# CONFIG_USB_SERIAL_XIRCOM is not set
+# CONFIG_USB_SERIAL_OPTION is not set
+# CONFIG_USB_SERIAL_OMNINET is not set
+# CONFIG_USB_SERIAL_OPTICON is not set
+# CONFIG_USB_SERIAL_VIVOPAY_SERIAL is not set
+# CONFIG_USB_SERIAL_ZIO is not set
+# CONFIG_USB_SERIAL_DEBUG is not set
+
+#
+# USB Miscellaneous drivers
+#
+# CONFIG_USB_EMI62 is not set
+# CONFIG_USB_EMI26 is not set
+# CONFIG_USB_ADUTUX is not set
+# CONFIG_USB_SEVSEG is not set
+# CONFIG_USB_RIO500 is not set
+# CONFIG_USB_LEGOTOWER is not set
+# CONFIG_USB_LCD is not set
+# CONFIG_USB_LED is not set
+# CONFIG_USB_CYPRESS_CY7C63 is not set
+# CONFIG_USB_CYTHERM is not set
+# CONFIG_USB_IDMOUSE is not set
+# CONFIG_USB_FTDI_ELAN is not set
+# CONFIG_USB_APPLEDISPLAY is not set
+# CONFIG_USB_SISUSBVGA is not set
+# CONFIG_USB_LD is not set
+# CONFIG_USB_TRANCEVIBRATOR is not set
+# CONFIG_USB_IOWARRIOR is not set
+# CONFIG_USB_TEST is not set
+# CONFIG_USB_ISIGHTFW is not set
+CONFIG_USB_GADGET=y
+# CONFIG_USB_GADGET_DEBUG_FILES is not set
+CONFIG_USB_GADGET_VBUS_DRAW=2
+CONFIG_USB_GADGET_SELECTED=y
+# CONFIG_USB_GADGET_AT91 is not set
+CONFIG_USB_GADGET_ATMEL_USBA=y
+CONFIG_USB_ATMEL_USBA=y
+# CONFIG_USB_GADGET_FSL_USB2 is not set
+# CONFIG_USB_GADGET_LH7A40X is not set
+# CONFIG_USB_GADGET_OMAP is not set
+# CONFIG_USB_GADGET_PXA25X is not set
+# CONFIG_USB_GADGET_R8A66597 is not set
+# CONFIG_USB_GADGET_PXA27X is not set
+# CONFIG_USB_GADGET_S3C_HSOTG is not set
+# CONFIG_USB_GADGET_IMX is not set
+# CONFIG_USB_GADGET_S3C2410 is not set
+# CONFIG_USB_GADGET_M66592 is not set
+# CONFIG_USB_GADGET_AMD5536UDC is not set
+# CONFIG_USB_GADGET_FSL_QE is not set
+# CONFIG_USB_GADGET_CI13XXX is not set
+# CONFIG_USB_GADGET_NET2280 is not set
+# CONFIG_USB_GADGET_GOKU is not set
+# CONFIG_USB_GADGET_LANGWELL is not set
+# CONFIG_USB_GADGET_DUMMY_HCD is not set
+CONFIG_USB_GADGET_DUALSPEED=y
+# CONFIG_USB_ZERO is not set
+# CONFIG_USB_AUDIO is not set
+# CONFIG_USB_ETH is not set
+# CONFIG_USB_GADGETFS is not set
+# CONFIG_USB_FUNCTIONFS is not set
+# CONFIG_USB_FILE_STORAGE is not set
+# CONFIG_USB_MASS_STORAGE is not set
+# CONFIG_USB_G_SERIAL is not set
+# CONFIG_USB_MIDI_GADGET is not set
+# CONFIG_USB_G_PRINTER is not set
+# CONFIG_USB_CDC_COMPOSITE is not set
+# CONFIG_USB_G_NOKIA is not set
+# CONFIG_USB_G_MULTI is not set
+# CONFIG_USB_G_HID is not set
+# CONFIG_USB_G_WEBCAM is not set
+
+#
+# OTG and related infrastructure
+#
+# CONFIG_USB_GPIO_VBUS is not set
+# CONFIG_USB_ULPI is not set
+# CONFIG_NOP_USB_XCEIV is not set
+CONFIG_MMC=y
+CONFIG_MMC_DEBUG=y
+CONFIG_MMC_UNSAFE_RESUME=y
+
+#
+# MMC/SD/SDIO Card Drivers
+#
+CONFIG_MMC_BLOCK=y
+CONFIG_MMC_BLOCK_BOUNCE=y
+# CONFIG_SDIO_UART is not set
+# CONFIG_MMC_TEST is not set
+
+#
+# MMC/SD/SDIO Host Controller Drivers
+#
+# CONFIG_MMC_SDHCI is not set
+# CONFIG_MMC_AT91 is not set
+CONFIG_MMC_ATMELMCI=y
+# CONFIG_MMC_ATMELMCI_DMA is not set
+# CONFIG_MEMSTICK is not set
+CONFIG_NEW_LEDS=y
+CONFIG_LEDS_CLASS=y
+
+#
+# LED drivers
+#
+# CONFIG_LEDS_PCA9532 is not set
+CONFIG_LEDS_GPIO=y
+CONFIG_LEDS_GPIO_PLATFORM=y
+# CONFIG_LEDS_LP3944 is not set
+# CONFIG_LEDS_PCA955X is not set
+# CONFIG_LEDS_BD2802 is not set
+# CONFIG_LEDS_LT3593 is not set
+CONFIG_LEDS_TRIGGERS=y
+
+#
+# LED Triggers
+#
+CONFIG_LEDS_TRIGGER_TIMER=y
+CONFIG_LEDS_TRIGGER_HEARTBEAT=y
+# CONFIG_LEDS_TRIGGER_BACKLIGHT is not set
+CONFIG_LEDS_TRIGGER_GPIO=y
+# CONFIG_LEDS_TRIGGER_DEFAULT_ON is not set
+
+#
+# iptables trigger is under Netfilter config (LED target)
+#
+# CONFIG_ACCESSIBILITY is not set
+CONFIG_RTC_LIB=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_HCTOSYS=y
+CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+# CONFIG_RTC_DEBUG is not set
+
+#
+# RTC interfaces
+#
+CONFIG_RTC_INTF_SYSFS=y
+CONFIG_RTC_INTF_PROC=y
+CONFIG_RTC_INTF_DEV=y
+# CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+# CONFIG_RTC_DRV_TEST is not set
+
+#
+# I2C RTC drivers
+#
+# CONFIG_RTC_DRV_DS1307 is not set
+# CONFIG_RTC_DRV_DS1374 is not set
+# CONFIG_RTC_DRV_DS1672 is not set
+# CONFIG_RTC_DRV_MAX6900 is not set
+# CONFIG_RTC_DRV_RS5C372 is not set
+# CONFIG_RTC_DRV_ISL1208 is not set
+# CONFIG_RTC_DRV_X1205 is not set
+# CONFIG_RTC_DRV_PCF8563 is not set
+# CONFIG_RTC_DRV_PCF8583 is not set
+# CONFIG_RTC_DRV_M41T80 is not set
+# CONFIG_RTC_DRV_BQ32K is not set
+# CONFIG_RTC_DRV_S35390A is not set
+# CONFIG_RTC_DRV_FM3130 is not set
+# CONFIG_RTC_DRV_RX8581 is not set
+# CONFIG_RTC_DRV_RX8025 is not set
+
+#
+# SPI RTC drivers
+#
+
+#
+# Platform RTC drivers
+#
+# CONFIG_RTC_DRV_CMOS is not set
+# CONFIG_RTC_DRV_DS1286 is not set
+# CONFIG_RTC_DRV_DS1511 is not set
+# CONFIG_RTC_DRV_DS1553 is not set
+# CONFIG_RTC_DRV_DS1742 is not set
+# CONFIG_RTC_DRV_STK17TA8 is not set
+# CONFIG_RTC_DRV_M48T86 is not set
+# CONFIG_RTC_DRV_M48T35 is not set
+# CONFIG_RTC_DRV_M48T59 is not set
+# CONFIG_RTC_DRV_MSM6242 is not set
+# CONFIG_RTC_DRV_BQ4802 is not set
+# CONFIG_RTC_DRV_RP5C01 is not set
+# CONFIG_RTC_DRV_V3020 is not set
+
+#
+# on-CPU RTC drivers
+#
+CONFIG_RTC_DRV_AT91RM9200=y
+CONFIG_DMADEVICES=y
+CONFIG_DMADEVICES_DEBUG=y
+# CONFIG_DMADEVICES_VDEBUG is not set
+
+#
+# DMA Devices
+#
+CONFIG_AT_HDMAC=y
+# CONFIG_TIMB_DMA is not set
+CONFIG_DMA_ENGINE=y
+
+#
+# DMA Clients
+#
+# CONFIG_NET_DMA is not set
+# CONFIG_ASYNC_TX_DMA is not set
+# CONFIG_DMATEST is not set
+# CONFIG_AUXDISPLAY is not set
+# CONFIG_UIO is not set
+CONFIG_STAGING=y
+# CONFIG_STAGING_EXCLUDE_BUILD is not set
+# CONFIG_USB_IP_COMMON is not set
+# CONFIG_PRISM2_USB is not set
+# CONFIG_ECHO is not set
+# CONFIG_RT2870 is not set
+# CONFIG_COMEDI is not set
+# CONFIG_ASUS_OLED is not set
+# CONFIG_TRANZPORT is not set
+# CONFIG_POHMELFS is not set
+# CONFIG_LINE6_USB is not set
+# CONFIG_USB_SERIAL_QUATECH2 is not set
+# CONFIG_USB_SERIAL_QUATECH_USB2 is not set
+# CONFIG_VT6656 is not set
+# CONFIG_FB_UDL is not set
+
+#
+# RAR Register Driver
+#
+# CONFIG_IIO is not set
+# CONFIG_BATMAN_ADV is not set
+# CONFIG_FB_SM7XX is not set
+
+#
+# Texas Instruments shared transport line discipline
+#
+
+#
+# File systems
+#
+CONFIG_EXT2_FS=y
+# CONFIG_EXT2_FS_XATTR is not set
+# CONFIG_EXT2_FS_XIP is not set
+# CONFIG_EXT3_FS is not set
+# CONFIG_EXT4_FS is not set
+# CONFIG_REISERFS_FS is not set
+# CONFIG_JFS_FS is not set
+CONFIG_FS_POSIX_ACL=y
+# CONFIG_XFS_FS is not set
+# CONFIG_GFS2_FS is not set
+# CONFIG_OCFS2_FS is not set
+# CONFIG_BTRFS_FS is not set
+# CONFIG_NILFS2_FS is not set
+CONFIG_FILE_LOCKING=y
+CONFIG_FSNOTIFY=y
+# CONFIG_DNOTIFY is not set
+CONFIG_INOTIFY=y
+CONFIG_INOTIFY_USER=y
+# CONFIG_QUOTA is not set
+# CONFIG_AUTOFS_FS is not set
+# CONFIG_AUTOFS4_FS is not set
+# CONFIG_FUSE_FS is not set
+
+#
+# Caches
+#
+# CONFIG_FSCACHE is not set
+
+#
+# CD-ROM/DVD Filesystems
+#
+# CONFIG_ISO9660_FS is not set
+# CONFIG_UDF_FS is not set
+
+#
+# DOS/FAT/NT Filesystems
+#
+CONFIG_FAT_FS=y
+CONFIG_MSDOS_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_FAT_DEFAULT_CODEPAGE=437
+CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+# CONFIG_NTFS_FS is not set
+
+#
+# Pseudo filesystems
+#
+CONFIG_PROC_FS=y
+CONFIG_PROC_SYSCTL=y
+CONFIG_PROC_PAGE_MONITOR=y
+CONFIG_SYSFS=y
+CONFIG_TMPFS=y
+# CONFIG_TMPFS_POSIX_ACL is not set
+# CONFIG_HUGETLB_PAGE is not set
+# CONFIG_CONFIGFS_FS is not set
+CONFIG_MISC_FILESYSTEMS=y
+# CONFIG_ADFS_FS is not set
+# CONFIG_AFFS_FS is not set
+# CONFIG_HFS_FS is not set
+# CONFIG_HFSPLUS_FS is not set
+# CONFIG_BEFS_FS is not set
+# CONFIG_BFS_FS is not set
+# CONFIG_EFS_FS is not set
+CONFIG_JFFS2_FS=y
+CONFIG_JFFS2_FS_DEBUG=0
+CONFIG_JFFS2_FS_WRITEBUFFER=y
+# CONFIG_JFFS2_FS_WBUF_VERIFY is not set
+CONFIG_JFFS2_SUMMARY=y
+# CONFIG_JFFS2_FS_XATTR is not set
+# CONFIG_JFFS2_COMPRESSION_OPTIONS is not set
+CONFIG_JFFS2_ZLIB=y
+# CONFIG_JFFS2_LZO is not set
+CONFIG_JFFS2_RTIME=y
+# CONFIG_JFFS2_RUBIN is not set
+CONFIG_UBIFS_FS=y
+# CONFIG_UBIFS_FS_XATTR is not set
+CONFIG_UBIFS_FS_ADVANCED_COMPR=y
+CONFIG_UBIFS_FS_LZO=y
+CONFIG_UBIFS_FS_ZLIB=y
+# CONFIG_UBIFS_FS_DEBUG is not set
+# CONFIG_LOGFS is not set
+CONFIG_CRAMFS=y
+# CONFIG_SQUASHFS is not set
+# CONFIG_VXFS_FS is not set
+# CONFIG_MINIX_FS is not set
+# CONFIG_OMFS_FS is not set
+# CONFIG_HPFS_FS is not set
+# CONFIG_QNX4FS_FS is not set
+# CONFIG_ROMFS_FS is not set
+# CONFIG_SYSV_FS is not set
+# CONFIG_UFS_FS is not set
+CONFIG_NETWORK_FILESYSTEMS=y
+CONFIG_NFS_FS=y
+CONFIG_NFS_V3=y
+CONFIG_NFS_V3_ACL=y
+CONFIG_NFS_V4=y
+# CONFIG_NFS_V4_1 is not set
+CONFIG_ROOT_NFS=y
+# CONFIG_NFSD is not set
+CONFIG_LOCKD=y
+CONFIG_LOCKD_V4=y
+CONFIG_NFS_ACL_SUPPORT=y
+CONFIG_NFS_COMMON=y
+CONFIG_SUNRPC=y
+CONFIG_SUNRPC_GSS=y
+CONFIG_RPCSEC_GSS_KRB5=y
+# CONFIG_RPCSEC_GSS_SPKM3 is not set
+# CONFIG_SMB_FS is not set
+# CONFIG_CEPH_FS is not set
+# CONFIG_CIFS is not set
+# CONFIG_NCP_FS is not set
+# CONFIG_CODA_FS is not set
+# CONFIG_AFS_FS is not set
+
+#
+# Partition Types
+#
+# CONFIG_PARTITION_ADVANCED is not set
+CONFIG_MSDOS_PARTITION=y
+CONFIG_NLS=y
+CONFIG_NLS_DEFAULT="iso8859-1"
+CONFIG_NLS_CODEPAGE_437=y
+# CONFIG_NLS_CODEPAGE_737 is not set
+# CONFIG_NLS_CODEPAGE_775 is not set
+CONFIG_NLS_CODEPAGE_850=y
+# CONFIG_NLS_CODEPAGE_852 is not set
+# CONFIG_NLS_CODEPAGE_855 is not set
+# CONFIG_NLS_CODEPAGE_857 is not set
+# CONFIG_NLS_CODEPAGE_860 is not set
+# CONFIG_NLS_CODEPAGE_861 is not set
+# CONFIG_NLS_CODEPAGE_862 is not set
+# CONFIG_NLS_CODEPAGE_863 is not set
+# CONFIG_NLS_CODEPAGE_864 is not set
+# CONFIG_NLS_CODEPAGE_865 is not set
+# CONFIG_NLS_CODEPAGE_866 is not set
+# CONFIG_NLS_CODEPAGE_869 is not set
+# CONFIG_NLS_CODEPAGE_936 is not set
+# CONFIG_NLS_CODEPAGE_950 is not set
+# CONFIG_NLS_CODEPAGE_932 is not set
+# CONFIG_NLS_CODEPAGE_949 is not set
+# CONFIG_NLS_CODEPAGE_874 is not set
+# CONFIG_NLS_ISO8859_8 is not set
+# CONFIG_NLS_CODEPAGE_1250 is not set
+# CONFIG_NLS_CODEPAGE_1251 is not set
+# CONFIG_NLS_ASCII is not set
+CONFIG_NLS_ISO8859_1=y
+# CONFIG_NLS_ISO8859_2 is not set
+# CONFIG_NLS_ISO8859_3 is not set
+# CONFIG_NLS_ISO8859_4 is not set
+# CONFIG_NLS_ISO8859_5 is not set
+# CONFIG_NLS_ISO8859_6 is not set
+# CONFIG_NLS_ISO8859_7 is not set
+# CONFIG_NLS_ISO8859_9 is not set
+# CONFIG_NLS_ISO8859_13 is not set
+# CONFIG_NLS_ISO8859_14 is not set
+CONFIG_NLS_ISO8859_15=y
+# CONFIG_NLS_KOI8_R is not set
+# CONFIG_NLS_KOI8_U is not set
+CONFIG_NLS_UTF8=y
+# CONFIG_DLM is not set
+
+#
+# Kernel hacking
+#
+# CONFIG_PRINTK_TIME is not set
+# CONFIG_ENABLE_WARN_DEPRECATED is not set
+CONFIG_ENABLE_MUST_CHECK=y
+CONFIG_FRAME_WARN=1024
+# CONFIG_MAGIC_SYSRQ is not set
+# CONFIG_STRIP_ASM_SYMS is not set
+# CONFIG_UNUSED_SYMBOLS is not set
+# CONFIG_DEBUG_FS is not set
+# CONFIG_HEADERS_CHECK is not set
+# CONFIG_DEBUG_KERNEL is not set
+CONFIG_DEBUG_BUGVERBOSE=y
+CONFIG_DEBUG_MEMORY_INIT=y
+CONFIG_RCU_CPU_STALL_DETECTOR=y
+# CONFIG_LATENCYTOP is not set
+# CONFIG_SYSCTL_SYSCALL_CHECK is not set
+CONFIG_HAVE_FUNCTION_TRACER=y
+CONFIG_TRACING_SUPPORT=y
+# CONFIG_FTRACE is not set
+# CONFIG_ATOMIC64_SELFTEST is not set
+# CONFIG_SAMPLES is not set
+CONFIG_HAVE_ARCH_KGDB=y
+CONFIG_ARM_UNWIND=y
+CONFIG_DEBUG_USER=y
+# CONFIG_OC_ETM is not set
+
+#
+# Security options
+#
+# CONFIG_KEYS is not set
+# CONFIG_SECURITY is not set
+# CONFIG_SECURITYFS is not set
+# CONFIG_DEFAULT_SECURITY_SELINUX is not set
+# CONFIG_DEFAULT_SECURITY_SMACK is not set
+# CONFIG_DEFAULT_SECURITY_TOMOYO is not set
+CONFIG_DEFAULT_SECURITY_DAC=y
+CONFIG_DEFAULT_SECURITY=""
+CONFIG_CRYPTO=y
+
+#
+# Crypto core or helper
+#
+# CONFIG_CRYPTO_FIPS is not set
+CONFIG_CRYPTO_ALGAPI=y
+CONFIG_CRYPTO_ALGAPI2=y
+CONFIG_CRYPTO_AEAD2=y
+CONFIG_CRYPTO_BLKCIPHER=y
+CONFIG_CRYPTO_BLKCIPHER2=y
+CONFIG_CRYPTO_HASH=y
+CONFIG_CRYPTO_HASH2=y
+CONFIG_CRYPTO_RNG=m
+CONFIG_CRYPTO_RNG2=y
+CONFIG_CRYPTO_PCOMP=y
+CONFIG_CRYPTO_MANAGER=y
+CONFIG_CRYPTO_MANAGER2=y
+# CONFIG_CRYPTO_GF128MUL is not set
+# CONFIG_CRYPTO_NULL is not set
+CONFIG_CRYPTO_WORKQUEUE=y
+# CONFIG_CRYPTO_CRYPTD is not set
+# CONFIG_CRYPTO_AUTHENC is not set
+# CONFIG_CRYPTO_TEST is not set
+
+#
+# Authenticated Encryption with Associated Data
+#
+# CONFIG_CRYPTO_CCM is not set
+# CONFIG_CRYPTO_GCM is not set
+# CONFIG_CRYPTO_SEQIV is not set
+
+#
+# Block modes
+#
+CONFIG_CRYPTO_CBC=y
+# CONFIG_CRYPTO_CTR is not set
+# CONFIG_CRYPTO_CTS is not set
+CONFIG_CRYPTO_ECB=y
+# CONFIG_CRYPTO_LRW is not set
+# CONFIG_CRYPTO_PCBC is not set
+# CONFIG_CRYPTO_XTS is not set
+
+#
+# Hash modes
+#
+# CONFIG_CRYPTO_HMAC is not set
+# CONFIG_CRYPTO_XCBC is not set
+# CONFIG_CRYPTO_VMAC is not set
+
+#
+# Digest
+#
+# CONFIG_CRYPTO_CRC32C is not set
+# CONFIG_CRYPTO_GHASH is not set
+# CONFIG_CRYPTO_MD4 is not set
+CONFIG_CRYPTO_MD5=y
+CONFIG_CRYPTO_MICHAEL_MIC=y
+# CONFIG_CRYPTO_RMD128 is not set
+# CONFIG_CRYPTO_RMD160 is not set
+# CONFIG_CRYPTO_RMD256 is not set
+# CONFIG_CRYPTO_RMD320 is not set
+# CONFIG_CRYPTO_SHA1 is not set
+# CONFIG_CRYPTO_SHA256 is not set
+# CONFIG_CRYPTO_SHA512 is not set
+# CONFIG_CRYPTO_TGR192 is not set
+# CONFIG_CRYPTO_WP512 is not set
+
+#
+# Ciphers
+#
+CONFIG_CRYPTO_AES=y
+# CONFIG_CRYPTO_ANUBIS is not set
+CONFIG_CRYPTO_ARC4=y
+# CONFIG_CRYPTO_BLOWFISH is not set
+# CONFIG_CRYPTO_CAMELLIA is not set
+CONFIG_CRYPTO_CAST5=y
+# CONFIG_CRYPTO_CAST6 is not set
+CONFIG_CRYPTO_DES=y
+# CONFIG_CRYPTO_FCRYPT is not set
+# CONFIG_CRYPTO_KHAZAD is not set
+# CONFIG_CRYPTO_SALSA20 is not set
+# CONFIG_CRYPTO_SEED is not set
+# CONFIG_CRYPTO_SERPENT is not set
+# CONFIG_CRYPTO_TEA is not set
+# CONFIG_CRYPTO_TWOFISH is not set
+
+#
+# Compression
+#
+CONFIG_CRYPTO_DEFLATE=y
+# CONFIG_CRYPTO_ZLIB is not set
+CONFIG_CRYPTO_LZO=y
+
+#
+# Random Number Generation
+#
+CONFIG_CRYPTO_ANSI_CPRNG=m
+CONFIG_CRYPTO_HW=y
+# CONFIG_BINARY_PRINTF is not set
+
+#
+# Library routines
+#
+CONFIG_BITREVERSE=y
+CONFIG_GENERIC_FIND_LAST_BIT=y
+# CONFIG_CRC_CCITT is not set
+CONFIG_CRC16=y
+# CONFIG_CRC_T10DIF is not set
+# CONFIG_CRC_ITU_T is not set
+CONFIG_CRC32=y
+# CONFIG_CRC7 is not set
+# CONFIG_LIBCRC32C is not set
+CONFIG_ZLIB_INFLATE=y
+CONFIG_ZLIB_DEFLATE=y
+CONFIG_LZO_COMPRESS=y
+CONFIG_LZO_DECOMPRESS=y
+CONFIG_HAS_IOMEM=y
+CONFIG_HAS_IOPORT=y
+CONFIG_HAS_DMA=y
+CONFIG_NLATTR=y
+CONFIG_GENERIC_ATOMIC64=y
Index: linux-2.6.35/drivers/serial/atmel_serial.c
===================================================================
--- linux-2.6.35/drivers/serial/atmel_serial.c	(revision 149)
+++ linux-2.6.35/drivers/serial/atmel_serial.c	(revision 150)
@@ -45,6 +45,7 @@
 
 #include <asm/mach/serial_at91.h>
 #include <mach/board.h>
+#include <mach/at_hdmac.h>
 
 #ifdef CONFIG_ARM
 #include <mach/cpu.h>
@@ -141,13 +142,22 @@
 	u32			backup_imr;	/* IMR saved during suspend */
 	int			break_active;	/* break being received */
 
-	short			use_dma_rx;	/* enable PDC receiver */
+	short			use_dma_rx;	/* enable DMA receiver */
 	short			pdc_rx_idx;	/* current PDC RX buffer */
 	struct atmel_dma_buffer	pdc_rx[2];	/* PDC receier */
 
-	short			use_dma_tx;	/* enable PDC transmitter */
+	short			use_dma_tx;	/* enable DMA transmitter */
 	struct atmel_dma_buffer	pdc_tx;		/* PDC transmitter */
 
+	spinlock_t			lock_tx;	/* port lock */
+	struct dma_chan			*chan_tx;
+	struct dma_async_tx_descriptor	*desc_tx;
+	dma_cookie_t			cookie_tx;
+
+	signed int			xmit_head;
+	struct scatterlist		sg_tx;
+	unsigned int			sg_len_tx;
+
 	struct tasklet_struct	tasklet;
 	unsigned int		irq_status;
 	unsigned int		irq_status_prev;
@@ -171,27 +181,41 @@
 }
 
 #ifdef CONFIG_SERIAL_ATMEL_PDC
-static bool atmel_use_dma_rx(struct uart_port *port)
+static bool atmel_use_pdc_rx(struct uart_port *port)
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
 	return atmel_port->use_dma_rx;
 }
 
-static bool atmel_use_dma_tx(struct uart_port *port)
+static bool atmel_use_pdc_tx(struct uart_port *port)
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
 	return atmel_port->use_dma_tx;
 }
 #else
-static bool atmel_use_dma_rx(struct uart_port *port)
+static bool atmel_use_pdc_rx(struct uart_port *port)
 {
 	return false;
 }
 
+static bool atmel_use_pdc_tx(struct uart_port *port)
+{
+	return false;
+}
+#endif
+
+#ifdef CONFIG_SERIAL_ATMEL_DMA
 static bool atmel_use_dma_tx(struct uart_port *port)
 {
+	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
+
+	return atmel_port->use_dma_tx;
+}
+#else
+static bool atmel_use_dma_tx(struct uart_port *port)
+{
 	return false;
 }
 #endif
@@ -221,7 +245,7 @@
 		mode |= ATMEL_US_USMODE_RS485;
 	} else {
 		dev_dbg(port->dev, "Setting UART to RS232\n");
-		if (atmel_use_dma_tx(port))
+		if (atmel_use_pdc_tx(port))
 			atmel_port->tx_done_mask = ATMEL_US_ENDTX |
 				ATMEL_US_TXBUFE;
 		else
@@ -331,10 +355,11 @@
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
-	if (atmel_use_dma_tx(port)) {
+	if (atmel_use_pdc_tx(port)) {
 		/* disable PDC transmit */
 		UART_PUT_PTCR(port, ATMEL_PDC_TXTDIS);
 	}
+
 	/* Disable interrupts */
 	UART_PUT_IDR(port, atmel_port->tx_done_mask);
 
@@ -349,7 +374,7 @@
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
-	if (atmel_use_dma_tx(port)) {
+	if (atmel_use_pdc_tx(port)) {
 		if (UART_GET_PTSR(port) & ATMEL_PDC_TXTEN)
 			/* The transmitter is already running.  Yes, we
 			   really need this.*/
@@ -361,6 +386,7 @@
 		/* re-enable PDC transmit */
 		UART_PUT_PTCR(port, ATMEL_PDC_TXTEN);
 	}
+
 	/* Enable interrupts */
 	UART_PUT_IER(port, atmel_port->tx_done_mask);
 }
@@ -372,7 +398,7 @@
 {
 	UART_PUT_CR(port, ATMEL_US_RSTSTA);  /* reset status and receiver */
 
-	if (atmel_use_dma_rx(port)) {
+	if (atmel_use_pdc_rx(port)) {
 		/* enable PDC controller */
 		UART_PUT_IER(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT |
 			port->read_status_mask);
@@ -387,7 +413,7 @@
  */
 static void atmel_stop_rx(struct uart_port *port)
 {
-	if (atmel_use_dma_rx(port)) {
+	if (atmel_use_pdc_rx(port)) {
 		/* disable PDC receive */
 		UART_PUT_PTCR(port, ATMEL_PDC_RXTDIS);
 		UART_PUT_IDR(port, ATMEL_US_ENDRX | ATMEL_US_TIMEOUT |
@@ -544,7 +570,208 @@
 		UART_PUT_IER(port, atmel_port->tx_done_mask);
 }
 
+#ifdef CONFIG_SERIAL_ATMEL_DMA
+static void atmel_dma_tx_complete(void *arg)
+{
+	struct atmel_uart_port *atmel_port = arg;
+	struct uart_port *port = &atmel_port->uart;
+	struct circ_buf *xmit = &port->state->xmit;
+	unsigned long flags;
+
+	spin_lock_irqsave(&port->lock, flags);
+
+	xmit->tail += sg_dma_len(&atmel_port->sg_tx);
+	xmit->tail &= UART_XMIT_SIZE - 1;
+
+	port->icount.tx += sg_dma_len(&atmel_port->sg_tx);
+
+	spin_lock_irq(&atmel_port->lock_tx);
+	async_tx_ack(atmel_port->desc_tx);
+	atmel_port->cookie_tx = -EINVAL;
+	atmel_port->desc_tx = NULL;
+	spin_unlock_irq(&atmel_port->lock_tx);
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+
+	/* Do we really need this? */
+	if (!uart_circ_empty(xmit)) {
+		tasklet_schedule(&atmel_port->tasklet);
+	}
+
+	spin_unlock_irqrestore(&port->lock, flags);
+}
+
+static void atmel_tx_dma_release(struct atmel_uart_port *atmel_port)
+{
+	struct dma_chan *chan = atmel_port->chan_tx;
+
+	atmel_port->chan_tx = NULL;
+	atmel_port->cookie_tx = -EINVAL;
+	if (chan) {
+		chan->device->device_control(chan, DMA_TERMINATE_ALL, 0);
+		dma_release_channel(chan);
+	}
+}
+
 /*
+ * Called from tasklet with TXRDY interrupt is disabled.
+ */
+static void atmel_tx_dma(struct uart_port *port)
+{
+	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
+	struct circ_buf *xmit = &port->state->xmit;
+	struct dma_chan *chan = atmel_port->chan_tx;
+	struct dma_async_tx_descriptor *desc;
+	struct scatterlist *sg = &atmel_port->sg_tx;
+
+	spin_lock_irq(&atmel_port->lock_tx);
+	/* Make sure we have an idle channel */
+	if (atmel_port->desc_tx != NULL) {
+		spin_lock_irq(&atmel_port->lock_tx);
+		return;
+	}
+	spin_unlock_irq(&atmel_port->lock_tx);
+
+	if (!uart_circ_empty(xmit) && !uart_tx_stopped(port)) {
+		/*
+		 * DMA is idle now.
+		 * Port xmit buffer is already mapped, and it is one page... Just adjust
+		 * offsets and lengths. Since it is a circular buffer, we have to
+		 * transmit till the end, and then the rest. Take the port lock to get a
+		 * consistent xmit buffer state.
+		 */
+		spin_lock_irq(&port->lock);
+		if (atmel_port->xmit_head != -1) {
+			if (atmel_port->xmit_head != xmit->head) {
+				atmel_port->xmit_head = xmit->head;
+			} else {
+				spin_unlock_irq(&port->lock);
+				return;
+			}
+		} else {
+			atmel_port->xmit_head = xmit->head;
+		}
+
+		sg->offset = xmit->tail & (UART_XMIT_SIZE - 1);
+		sg_dma_address(sg) = (sg_dma_address(sg) & ~(UART_XMIT_SIZE - 1))
+							+ sg->offset;
+		sg_dma_len(sg) = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);
+		spin_unlock_irq(&port->lock);
+
+		BUG_ON(!sg_dma_len(sg));
+
+		desc = chan->device->device_prep_slave_sg(chan,
+				sg, atmel_port->sg_len_tx, DMA_TO_DEVICE,
+				DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+		if (!desc) {
+			spin_unlock_irq(&port->lock);
+			printk (KERN_ERR "#### Error! Failed to send via dma!\n");
+			return;
+		}
+
+		dma_sync_sg_for_device(port->dev, sg, 1, DMA_TO_DEVICE);
+
+		spin_lock_irq(&port->lock);
+		atmel_port->desc_tx = desc;
+		desc->callback = atmel_dma_tx_complete;
+		desc->callback_param = atmel_port;
+		spin_unlock_irq(&port->lock);
+		atmel_port->cookie_tx = desc->tx_submit(desc);
+		if (atmel_port->cookie_tx < 0) {
+			dev_warn(port->dev, "Failed submitting Tx DMA descriptor\n");
+			/* switch to PIO */
+			atmel_tx_dma_release(atmel_port);
+			return;
+		}
+
+		dma_async_issue_pending(chan);
+	} else {
+		if (atmel_port->rs485.flags & SER_RS485_ENABLED) {
+			/* DMA done, stop TX, start RX for RS485 */
+			atmel_start_rx(port);
+		}
+	}
+
+	if (uart_circ_chars_pending(xmit) < WAKEUP_CHARS)
+		uart_write_wakeup(port);
+}
+
+static bool filter(struct dma_chan *chan, void *slave)
+{
+	struct	at_dma_slave		*sl = slave;
+
+	if (sl->dma_dev == chan->device->dev) {
+		chan->private = sl;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void atmel_tx_request_dma(struct atmel_uart_port *atmel_port)
+{
+	struct uart_port	*port;
+	struct atmel_uart_data	*pdata;
+	dma_cap_mask_t		mask;
+	struct dma_chan		*chan = NULL;
+
+	if (atmel_port == NULL)
+		return;
+
+	port = &(atmel_port->uart);
+	pdata = (struct atmel_uart_data *)port->private_data;
+
+	if (!pdata) {
+		dev_notice(port->dev, "DMA not available, using PIO\n");
+		return;
+	}
+
+	dma_cap_zero(mask);
+	dma_cap_set(DMA_SLAVE, mask);
+
+	if (atmel_use_dma_tx(port) && pdata->dma_tx_slave) {
+		pdata->dma_tx_slave->tx_reg = port->mapbase + ATMEL_US_THR;
+		chan = dma_request_channel(mask, filter, pdata->dma_tx_slave);
+		dev_dbg(port->dev, "%s: TX: got channel %p\n", __func__, chan);
+	}
+
+	if (chan) {
+		int nent;
+
+		spin_lock_init(&atmel_port->lock_tx);
+		atmel_port->chan_tx = chan;
+
+		sg_init_table(&atmel_port->sg_tx, 1);
+		/* UART circular tx buffer is an aligned page. */
+		BUG_ON((int)port->state->xmit.buf & ~PAGE_MASK);
+		sg_set_page(&atmel_port->sg_tx,
+				virt_to_page(port->state->xmit.buf),
+				UART_XMIT_SIZE,
+				(int)port->state->xmit.buf & ~PAGE_MASK);
+				nent = dma_map_sg(port->dev, &atmel_port->sg_tx, 1,
+				DMA_TO_DEVICE);
+
+		if (!nent)
+			dev_dbg(port->dev, "need to release resource of dma\n");
+		else
+			dev_dbg(port->dev, "%s: mapped %d@%p to %x\n", __func__,
+				sg_dma_len(&atmel_port->sg_tx),
+				port->state->xmit.buf,
+				sg_dma_address(&atmel_port->sg_tx));
+
+		atmel_port->sg_len_tx = nent;
+		atmel_port->xmit_head = -1;
+	}
+}
+#else
+static void atmel_dma_tx_complete(void *arg) {}
+static void atmel_tx_dma_release(struct atmel_uart_port *atmel_port) {}
+static void atmel_tx_dma(struct uart_port *port) {}
+static void atmel_tx_request_dma(struct atmel_uart_port *atmel_port) {}
+#endif
+
+/*
  * receive interrupt handler.
  */
 static void
@@ -552,7 +779,7 @@
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
-	if (atmel_use_dma_rx(port)) {
+	if (atmel_use_pdc_rx(port)) {
 		/*
 		 * PDC receive. Just schedule the tasklet and let it
 		 * figure out the details.
@@ -641,7 +868,7 @@
 /*
  * Called from tasklet with ENDTX and TXBUFE interrupts disabled.
  */
-static void atmel_tx_dma(struct uart_port *port)
+static void atmel_tx_pdc(struct uart_port *port)
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 	struct circ_buf *xmit = &port->state->xmit;
@@ -757,7 +984,7 @@
 	spin_lock(&port->lock);
 }
 
-static void atmel_rx_from_dma(struct uart_port *port)
+static void atmel_rx_from_pdc(struct uart_port *port)
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 	struct tty_struct *tty = port->state->port.tty;
@@ -846,7 +1073,9 @@
 	/* The interrupt handler does not take the lock */
 	spin_lock(&port->lock);
 
-	if (atmel_use_dma_tx(port))
+	if (atmel_use_pdc_tx(port))
+		atmel_tx_pdc(port);
+	else if (atmel_use_dma_tx(port))
 		atmel_tx_dma(port);
 	else
 		atmel_tx_chars(port);
@@ -871,8 +1100,8 @@
 		atmel_port->irq_status_prev = status;
 	}
 
-	if (atmel_use_dma_rx(port))
-		atmel_rx_from_dma(port);
+	if (atmel_use_pdc_rx(port))
+		atmel_rx_from_pdc(port);
 	else
 		atmel_rx_from_ring(port);
 
@@ -908,7 +1137,7 @@
 	/*
 	 * Initialize DMA (if necessary)
 	 */
-	if (atmel_use_dma_rx(port)) {
+	if (atmel_use_pdc_rx(port)) {
 		int i;
 
 		for (i = 0; i < 2; i++) {
@@ -942,7 +1171,8 @@
 		UART_PUT_RNPR(port, atmel_port->pdc_rx[1].dma_addr);
 		UART_PUT_RNCR(port, PDC_BUFFER_SIZE);
 	}
-	if (atmel_use_dma_tx(port)) {
+	if (atmel_use_pdc_tx(port)) {
+
 		struct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;
 		struct circ_buf *xmit = &port->state->xmit;
 
@@ -955,6 +1185,9 @@
 		pdc->ofs = 0;
 	}
 
+	if (atmel_use_dma_tx(port))
+		atmel_tx_request_dma(atmel_port);
+
 	/*
 	 * If there is a specific "open" function (to register
 	 * control line interrupts)
@@ -978,7 +1211,7 @@
 	/* enable xmit & rcvr */
 	UART_PUT_CR(port, ATMEL_US_TXEN | ATMEL_US_RXEN);
 
-	if (atmel_use_dma_rx(port)) {
+	if (atmel_use_pdc_rx(port)) {
 		/* set UART timeout */
 		UART_PUT_RTOR(port, PDC_RX_TIMEOUT);
 		UART_PUT_CR(port, ATMEL_US_STTTO);
@@ -1009,7 +1242,7 @@
 	/*
 	 * Shut-down the DMA.
 	 */
-	if (atmel_use_dma_rx(port)) {
+	if (atmel_use_pdc_rx(port)) {
 		int i;
 
 		for (i = 0; i < 2; i++) {
@@ -1022,7 +1255,7 @@
 			kfree(pdc->buf);
 		}
 	}
-	if (atmel_use_dma_tx(port)) {
+	if (atmel_use_pdc_tx(port)) {
 		struct atmel_dma_buffer *pdc = &atmel_port->pdc_tx;
 
 		dma_unmap_single(port->dev,
@@ -1031,6 +1264,9 @@
 				 DMA_TO_DEVICE);
 	}
 
+	if (atmel_use_dma_tx(port)) {
+		atmel_tx_dma_release(atmel_port);
+	}
 	/*
 	 * Disable all interrupts, port and break condition.
 	 */
@@ -1058,10 +1294,16 @@
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
-	if (atmel_use_dma_tx(port)) {
+	if (atmel_use_pdc_tx(port)) {
 		UART_PUT_TCR(port, 0);
 		atmel_port->pdc_tx.ofs = 0;
 	}
+
+	if (atmel_use_dma_tx(port)) {
+		struct dma_chan *chan = atmel_port->chan_tx;
+		if (chan)
+			chan->device->device_control(chan, DMA_TERMINATE_ALL, 0);
+	}
 }
 
 /*
@@ -1171,7 +1413,7 @@
 	if (termios->c_iflag & (BRKINT | PARMRK))
 		port->read_status_mask |= ATMEL_US_RXBRK;
 
-	if (atmel_use_dma_rx(port))
+	if (atmel_use_pdc_rx(port))
 		/* need to enable error interrupts */
 		UART_PUT_IER(port, port->read_status_mask);
 
@@ -1405,6 +1647,7 @@
 	port->dev		= &pdev->dev;
 	port->mapbase	= pdev->resource[0].start;
 	port->irq	= pdev->resource[1].start;
+	port->private_data	= data;
 
 	tasklet_init(&atmel_port->tasklet, atmel_tasklet_func,
 			(unsigned long)port);
@@ -1434,7 +1677,7 @@
 	/* Use TXEMPTY for interrupt when rs485 else TXRDY or ENDTX|TXBUFE */
 	if (atmel_port->rs485.flags & SER_RS485_ENABLED)
 		atmel_port->tx_done_mask = ATMEL_US_TXEMPTY;
-	else if (atmel_use_dma_tx(port)) {
+	else if (atmel_use_pdc_tx(port)) {
 		port->fifosize = PDC_BUFFER_SIZE;
 		atmel_port->tx_done_mask = ATMEL_US_ENDTX | ATMEL_US_TXBUFE;
 	} else {
@@ -1700,7 +1943,7 @@
 
 	atmel_init_port(port, pdev);
 
-	if (!atmel_use_dma_rx(&port->uart)) {
+	if (!atmel_use_pdc_rx(&port->uart)) {
 		ret = -ENOMEM;
 		data = kmalloc(sizeof(struct atmel_uart_char)
 				* ATMEL_SERIAL_RINGSIZE, GFP_KERNEL);
Index: linux-2.6.35/drivers/serial/Kconfig
===================================================================
--- linux-2.6.35/drivers/serial/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/serial/Kconfig	(revision 150)
@@ -379,7 +379,7 @@
 
 config SERIAL_ATMEL_PDC
 	bool "Support DMA transfers on AT91 / AT32 serial port"
-	depends on SERIAL_ATMEL
+	depends on SERIAL_ATMEL && !(ARCH_AT91SAM9X5)
 	default y
 	help
 	  Say Y here if you wish to use the PDC to do DMA transfers to
@@ -392,6 +392,14 @@
 	  properly when DMA is enabled. Make sure that ports where
 	  this matters don't use DMA.
 
+config SERIAL_ATMEL_DMA
+	bool "Atmel Serial DMA support"
+	depends on SERIAL_ATMEL && ARCH_AT91SAM9X5 && DMA_ENGINE && EXPERIMENTAL
+	default y
+	help
+	  Say Y here to have the Atmel serial driver use a DMA engine to do data
+	  transfers and thus increase the throughput and reduce the CPU utilization.
+
 config SERIAL_ATMEL_TTYAT
 	bool "Install as device ttyATn instead of ttySn"
 	depends on SERIAL_ATMEL=y
Index: linux-2.6.35/drivers/media/video/Kconfig
===================================================================
--- linux-2.6.35/drivers/media/video/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/media/video/Kconfig	(revision 150)
@@ -63,7 +63,16 @@
 	  Some of those devices also supports FM radio.
 
 if VIDEO_CAPTURE_DRIVERS && VIDEO_V4L2
+config VIDEO_ATMEL_ISI
+	tristate "ATMEL video support"
+	depends on VIDEO_DEV
+	default n
+	---help---
+	  This module makes the ATMEL Image Sensor Interface available
+	  as a v4l2 device.
 
+	  When in doubt, say N.
+
 config VIDEO_ADV_DEBUG
 	bool "Enable advanced debug functionality"
 	default n
@@ -321,6 +330,22 @@
 	  OV7670 VGA camera.  It currently only works with the M88ALP01
 	  controller.
 
+config VIDEO_OV9655
+	tristate "OmniVision OV9655 sensor support"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV9655 camera.  It is currently working with the ATMEL AT91
+	  camera controller.
+
+config VIDEO_OV2640
+	tristate "OmnVision OV2640 sensor support"
+	depends on I2C && VIDEO_V4L2
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the OmniVision
+	  OV2640 camera.  It is currently working with the ATMEL AT91
+	  camera controller.
+
 config VIDEO_MT9V011
 	tristate "Micron mt9v011 sensor support"
 	depends on I2C && VIDEO_V4L2
Index: linux-2.6.35/drivers/media/video/ov2640_atmel.c
===================================================================
--- linux-2.6.35/drivers/media/video/ov2640_atmel.c	(revision 0)
+++ linux-2.6.35/drivers/media/video/ov2640_atmel.c	(revision 150)
@@ -0,0 +1,848 @@
+/*
+ * Omnivision ov2640 Camera driver
+ *
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#define DEBUG			12
+#define VERBOSE			12
+#define VERBOSE_DEBUG		12
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <mach/gpio.h>
+
+#include <media/atmel-isi.h>
+#include "ov2640.h"
+
+
+//static unsigned short normal_i2c[] = {
+//	OV2640_I2C_ADDR,
+//	I2C_CLIENT_END
+//};
+//I2C_CLIENT_INSMOD;
+
+static char mclk_name[32] = "isi_clk";
+module_param_string(mclk, mclk_name, sizeof(mclk_name), 0644);
+MODULE_PARM_DESC(mclk, "Name of the clock used as camera clock input");
+MODULE_PARM_DESC(mclk, "Name of mclk parent clock");
+
+struct ov2640 {
+	struct mutex		mutex;
+	u8			miscel_ctrl;
+	u16			pll_avr_ctrl;
+	struct clk		*mclk;
+	struct i2c_client	*client;
+	struct atmel_isi_camera	cam;
+};
+#define to_ov2640(cam) container_of(cam, struct ov2640, cam)
+
+/*
+ * OV2640 register configuration for all combinations of pixel format and
+ * image size(for the moment only qvga YUV...)
+ */
+static struct ov2640_reg dump_list[] = {
+	{ OV2640_REG_TERM, OV2640_VAL_TERM }
+};
+
+/* YUV configs */
+static const struct ov2640_reg qqcif_yuv[] = { };
+static const struct ov2640_reg qqvga_yuv[] = { };
+static const struct ov2640_reg sqcif_yuv[] = {
+	{ OV2640_REG_TERM, OV2640_VAL_TERM }
+};
+
+static const struct ov2640_reg qcif_yuv[] = {
+{0xff, 0x01}, {0x12, 0x80}, {0xff, 0x00}, {0x2c, 0xff}, {0x2e, 0xdf},
+{0xff, 0x01}, {0x3c, 0x32}, {0x11, 0x00}, {0x09, 0x02}, {0x04, 0x28},
+{0x13, 0xe5}, {0x14, 0x48}, {0x2c, 0x0c}, {0x33, 0x78}, {0x3a, 0x33},
+{0x3b, 0xfb}, {0x3e, 0x00}, {0x43, 0x11}, {0x16, 0x10}, {0x39, 0x02},
+{0x35, 0x88}, {0x22, 0x0a}, {0x37, 0x40}, {0x23, 0x00}, {0x34, 0xa0},
+{0x36, 0x1a}, {0x06, 0x02}, {0x07, 0xc0}, {0x0d, 0xb7}, {0x0e, 0x01},
+{0x4c, 0x00}, {0x4a, 0x81}, {0x21, 0x99}, {0x24, 0x3a}, {0x25, 0x32},
+{0x26, 0x82}, {0x5c, 0x00}, {0x63, 0x00}, {0x5d, 0x55}, {0x5e, 0x7d},
+{0x5f, 0x7d}, {0x60, 0x55}, {0x61, 0x70}, {0x62, 0x80}, {0x7c, 0x05},
+{0x20, 0x80}, {0x28, 0x30}, {0x6c, 0x00}, {0x6d, 0x80}, {0x6e, 0x00},
+{0x70, 0x02}, {0x71, 0x94}, {0x73, 0xc1}, {0x3d, 0x34}, {0x5a, 0x57},
+{0x4f, 0xbb}, {0x50, 0x9c}, {0xff, 0x00}, {0xe5, 0x7f}, {0xf9, 0xc0},
+{0x41, 0x24}, {0xe0, 0x14}, {0x76, 0xff}, {0x33, 0xa0}, {0x42, 0x20},
+{0x43, 0x18}, {0x4c, 0x00}, {0x87, 0xd0}, {0x88, 0x3f}, {0xd7, 0x03},
+{0xd9, 0x10}, {0xd3, 0x82}, {0xc8, 0x08}, {0xc9, 0x80}, {0x7c, 0x00},
+{0x7d, 0x02}, {0x7c, 0x03}, {0x7d, 0x48}, {0x7d, 0x48}, {0x7c, 0x08},
+{0x7d, 0x20}, {0x7d, 0x10}, {0x7d, 0x0e}, {0x90, 0x00}, {0x91, 0x0e},
+{0x91, 0x1a}, {0x91, 0x31}, {0x91, 0x5a}, {0x91, 0x69}, {0x91, 0x75},
+{0x91, 0x7e}, {0x91, 0x88}, {0x91, 0x8f}, {0x91, 0x96}, {0x91, 0xa3},
+{0x91, 0xaf}, {0x91, 0xc4}, {0x91, 0xd7}, {0x91, 0xe8}, {0x91, 0x20},
+{0x92, 0x00}, {0x93, 0x06}, {0x93, 0xe3}, {0x93, 0x05}, {0x93, 0x05},
+{0x93, 0x00}, {0x93, 0x02}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00},
+{0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x96, 0x00},
+{0x97, 0x08}, {0x97, 0x19}, {0x97, 0x02}, {0x97, 0x0c}, {0x97, 0x24},
+{0x97, 0x30}, {0x97, 0x28}, {0x97, 0x26}, {0x97, 0x02}, {0x97, 0x98},
+{0x97, 0x80}, {0x97, 0x00}, {0x97, 0x00}, {0xc3, 0xed}, {0xa4, 0x00},
+{0xa8, 0x00}, {0xc5, 0x11}, {0xc6, 0x51}, {0xbf, 0x80}, {0xc7, 0x10},
+{0xb6, 0x66}, {0xb8, 0xa5}, {0xb7, 0x64}, {0xb9, 0x7c}, {0xb3, 0xaf},
+{0xb4, 0x97}, {0xb5, 0xff}, {0xb0, 0xc5}, {0xb1, 0x94}, {0xb2, 0x0f},
+{0xc4, 0x5c}, {0xc0, 0xc8}, {0xc1, 0x96}, {0x86, 0x1d}, {0x50, 0x00},
+{0x51, 0x90}, {0x52, 0x18}, {0x53, 0x00}, {0x54, 0x00}, {0x55, 0x88},
+{0x57, 0x00}, {0x5a, 0x90}, {0x5b, 0x18}, {0x5c, 0x05}, {0xc3, 0xed},
+{0x7f, 0x00}, {0xda, 0x04}, {0xe5, 0x1f}, {0xe1, 0x67}, {0xe0, 0x00},
+{0xdd, 0xff}, {0x05, 0x00}, {0xff, 0x01}, {0x11, 0x01},
+
+{0xff, 0x01}, {0x12, 0x40}, {0x17, 0x11}, {0x18, 0x43}, {0x19, 0x00},
+{0x1a, 0x4b}, {0x32, 0x09}, {0x4f, 0xca}, {0x50, 0xa8}, {0x5a, 0x23},
+{0x6d, 0x00}, {0x3d, 0x38},
+
+{0x39, 0x12}, {0x35, 0xda}, {0x22, 0x1a}, {0x37, 0xc3}, {0x23, 0x00},
+{0x34, 0xc0}, {0x36, 0x1a}, {0x06, 0x88}, {0x07, 0xc0}, {0x0d, 0x87},
+{0x0e, 0x41}, {0x4c, 0x00}, {0x48, 0x00}, {0x5B, 0x00}, {0x42, 0x03},
+
+{0xff, 0x00}, {0xe0, 0x04}, {0xc0, 0x64}, {0xc1, 0x4B}, {0x8c, 0x00},
+{0x86, 0x1D}, {0xd3, 0x82}, {0xe0, 0x00},
+
+/* QCIF */
+{0xff, 0x00}, {0xc0, 0x64}, {0xc1, 0x4B}, {0x8c, 0x00}, {0x86, 0x3D},
+{0x50, 0x92}, {0x51, 0xC8}, {0x52, 0x96}, {0x53, 0x00}, {0x54, 0x00},
+{0x55, 0x00}, {0x5a, 0x2C}, {0x5b, 0x24}, {0x5c, 0x00}, {0xd3, 0x04},
+
+{0xFF, 0x00}, {0xE0, 0x04}, {0xE1, 0x67}, {0xD7, 0x01}, {0xDA, 0x00},
+{0xD3, 0x82}, {0xE0, 0x00},
+
+{ OV2640_REG_TERM, OV2640_VAL_TERM }
+};
+
+/* QVGA YUV */
+static const struct ov2640_reg qvga_yuv[] = {
+	/* Value provided by Omnivision */
+{0xff, 0x01}, {0x12, 0x80}, {0xff, 0x00}, {0x2c, 0xff}, {0x2e, 0xdf},
+{0xff, 0x01}, {0x3c, 0x32}, {0x11, 0x00}, {0x09, 0x02}, {0x04, 0x28},
+{0x13, 0xe5}, {0x14, 0x48}, {0x2c, 0x0c}, {0x33, 0x78}, {0x3a, 0x33},
+{0x3b, 0xfb}, {0x3e, 0x00}, {0x43, 0x11}, {0x16, 0x10}, {0x39, 0x02},
+{0x35, 0x88}, {0x22, 0x0a}, {0x37, 0x40}, {0x23, 0x00}, {0x34, 0xa0},
+{0x36, 0x1a}, {0x06, 0x02}, {0x07, 0xc0}, {0x0d, 0xb7}, {0x0e, 0x01},
+{0x4c, 0x00}, {0x4a, 0x81}, {0x21, 0x99}, {0x24, 0x3a}, {0x25, 0x32},
+{0x26, 0x82}, {0x5c, 0x00}, {0x63, 0x00}, {0x5d, 0x55}, {0x5e, 0x7d},
+{0x5f, 0x7d}, {0x60, 0x55}, {0x61, 0x70}, {0x62, 0x80}, {0x7c, 0x05},
+{0x20, 0x80}, {0x28, 0x30}, {0x6c, 0x00}, {0x6d, 0x80}, {0x6e, 0x00},
+{0x70, 0x02}, {0x71, 0x94}, {0x73, 0xc1}, {0x3d, 0x34}, {0x5a, 0x57},
+{0x4f, 0xbb}, {0x50, 0x9c}, {0xff, 0x00}, {0xe5, 0x7f}, {0xf9, 0xc0},
+{0x41, 0x24}, {0xe0, 0x14}, {0x76, 0xff}, {0x33, 0xa0}, {0x42, 0x20},
+{0x43, 0x18}, {0x4c, 0x00}, {0x87, 0xd0}, {0x88, 0x3f}, {0xd7, 0x03},
+{0xd9, 0x10}, {0xd3, 0x82}, {0xc8, 0x08}, {0xc9, 0x80}, {0x7c, 0x00},
+{0x7d, 0x02}, {0x7c, 0x03}, {0x7d, 0x48}, {0x7d, 0x48}, {0x7c, 0x08},
+{0x7d, 0x20}, {0x7d, 0x10}, {0x7d, 0x0e}, {0x90, 0x00}, {0x91, 0x0e},
+{0x91, 0x1a}, {0x91, 0x31}, {0x91, 0x5a}, {0x91, 0x69}, {0x91, 0x75},
+{0x91, 0x7e}, {0x91, 0x88}, {0x91, 0x8f}, {0x91, 0x96}, {0x91, 0xa3},
+{0x91, 0xaf}, {0x91, 0xc4}, {0x91, 0xd7}, {0x91, 0xe8}, {0x91, 0x20},
+{0x92, 0x00}, {0x93, 0x06}, {0x93, 0xe3}, {0x93, 0x05}, {0x93, 0x05},
+{0x93, 0x00}, {0x93, 0x02}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00},
+{0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x96, 0x00},
+{0x97, 0x08}, {0x97, 0x19}, {0x97, 0x02}, {0x97, 0x0c}, {0x97, 0x24},
+{0x97, 0x30}, {0x97, 0x28}, {0x97, 0x26}, {0x97, 0x02}, {0x97, 0x98},
+{0x97, 0x80}, {0x97, 0x00}, {0x97, 0x00}, {0xc3, 0xed}, {0xa4, 0x00},
+{0xa8, 0x00}, {0xc5, 0x11}, {0xc6, 0x51}, {0xbf, 0x80}, {0xc7, 0x10},
+{0xb6, 0x66}, {0xb8, 0xa5}, {0xb7, 0x64}, {0xb9, 0x7c}, {0xb3, 0xaf},
+{0xb4, 0x97}, {0xb5, 0xff}, {0xb0, 0xc5}, {0xb1, 0x94}, {0xb2, 0x0f},
+{0xc4, 0x5c}, {0xc0, 0xc8}, {0xc1, 0x96}, {0x86, 0x1d}, {0x50, 0x00},
+{0x51, 0x90}, {0x52, 0x18}, {0x53, 0x00}, {0x54, 0x00}, {0x55, 0x88},
+{0x57, 0x00}, {0x5a, 0x90}, {0x5b, 0x18}, {0x5c, 0x05}, {0xc3, 0xed},
+{0x7f, 0x00}, {0xda, 0x04}, {0xe5, 0x1f}, {0xe1, 0x67}, {0xe0, 0x00},
+{0xdd, 0xff}, {0x05, 0x00}, {0xff, 0x01}, {0x11, 0x01},
+
+{0xff, 0x01}, {0x12, 0x40}, {0x17, 0x11}, {0x18, 0x43}, {0x19, 0x00},
+{0x1a, 0x4b}, {0x32, 0x09}, {0x4f, 0xca}, {0x50, 0xa8}, {0x5a, 0x23},
+{0x6d, 0x00}, {0x3d, 0x38},
+
+{0x39, 0x12}, {0x35, 0xda}, {0x22, 0x1a}, {0x37, 0xc3}, {0x23, 0x00},
+{0x34, 0xc0}, {0x36, 0x1a}, {0x06, 0x88}, {0x07, 0xc0}, {0x0d, 0x87},
+{0x0e, 0x41}, {0x4c, 0x00}, {0x48, 0x00}, {0x5B, 0x00},
+
+{0x42, 0x03}, {0xff, 0x00}, {0xe0, 0x04}, {0xc0, 0x64}, {0xc1, 0x4B},
+{0x8c, 0x00}, {0x86, 0x1D}, {0xd3, 0x82}, {0xe0, 0x00},
+
+{0xff, 0x00}, {0xc0, 0x64}, {0xc1, 0x4B}, {0x8c, 0x00}, {0x86, 0x3D},
+{0x50, 0x89}, {0x51, 0xC8}, {0x52, 0x96}, {0x53, 0x00}, {0x54, 0x00},
+{0x55, 0x00}, {0x5a, 0x50}, {0x5b, 0x3C}, {0x5c, 0x00}, {0xd3, 0x04},
+
+/* 10 fps */
+/*{0xff, 0x01}, {0x11, 0x01}, {0x3d, 0x3a}, {0x2b, 0x95},*/
+
+/* 15 fps */
+/*{0xff, 0x01}, {0x11, 0x01}, {0x3d, 0x38}, {0x2b, 0x00},*/
+
+/* 20 fps */
+/*{0xff, 0x01}, {0x11, 0x00}, {0x3d, 0x3a}, {0x2b, 0x95},*/
+
+/* 25 fps */
+/*{0xff, 0x01}, {0x11, 0x00}, {0x3d, 0x39}, {0x2b, 0x3c},*/
+
+/* 30 fps*/
+{0xff, 0x01}, {0x11, 0x01}, {0x3d, 0x38}, {0x2b, 0x00},
+
+{0xFF, 0x00}, {0xE0, 0x04}, {0xE1, 0x67}, {0xD7, 0x01}, {0xDA, 0x00},
+{0xD3, 0x82}, {0xE0, 0x00},
+
+{ OV2640_REG_TERM, OV2640_VAL_TERM }
+};
+static const struct ov2640_reg cif_yuv[] = {};
+static const struct ov2640_reg vga_yuv[] = {
+{0xff, 0x01}, {0x12, 0x80}, {0xff, 0x00}, {0x2c, 0xff}, {0x2e, 0xdf},
+{0xff, 0x01}, {0x3c, 0x32}, {0x11, 0x00}, {0x09, 0x02}, {0x04, 0x28},
+{0x13, 0xe5}, {0x14, 0x48}, {0x2c, 0x0c}, {0x33, 0x78}, {0x3a, 0x33},
+{0x3b, 0xfb}, {0x3e, 0x00}, {0x43, 0x11}, {0x16, 0x10}, {0x39, 0x02},
+{0x35, 0x88}, {0x22, 0x0a}, {0x37, 0x40}, {0x23, 0x00}, {0x34, 0xa0},
+{0x36, 0x1a}, {0x06, 0x02}, {0x07, 0xc0}, {0x0d, 0xb7}, {0x0e, 0x01},
+{0x4c, 0x00}, {0x4a, 0x81}, {0x21, 0x99}, {0x24, 0x3a}, {0x25, 0x32},
+{0x26, 0x82}, {0x5c, 0x00}, {0x63, 0x00}, {0x5d, 0x55}, {0x5e, 0x7d},
+{0x5f, 0x7d}, {0x60, 0x55}, {0x61, 0x70}, {0x62, 0x80}, {0x7c, 0x05},
+{0x20, 0x80}, {0x28, 0x30}, {0x6c, 0x00}, {0x6d, 0x80}, {0x6e, 0x00},
+{0x70, 0x02}, {0x71, 0x94}, {0x73, 0xc1}, {0x3d, 0x34}, {0x5a, 0x57},
+{0x4f, 0xbb}, {0x50, 0x9c}, {0xff, 0x00}, {0xe5, 0x7f}, {0xf9, 0xc0},
+{0x41, 0x24}, {0xe0, 0x14}, {0x76, 0xff}, {0x33, 0xa0}, {0x42, 0x20},
+{0x43, 0x18}, {0x4c, 0x00}, {0x87, 0xd0}, {0x88, 0x3f}, {0xd7, 0x03},
+{0xd9, 0x10}, {0xd3, 0x82}, {0xc8, 0x08}, {0xc9, 0x80}, {0x7c, 0x00},
+{0x7d, 0x02}, {0x7c, 0x03}, {0x7d, 0x48}, {0x7d, 0x48}, {0x7c, 0x08},
+{0x7d, 0x20}, {0x7d, 0x10}, {0x7d, 0x0e}, {0x90, 0x00}, {0x91, 0x0e},
+{0x91, 0x1a}, {0x91, 0x31}, {0x91, 0x5a}, {0x91, 0x69}, {0x91, 0x75},
+{0x91, 0x7e}, {0x91, 0x88}, {0x91, 0x8f}, {0x91, 0x96}, {0x91, 0xa3},
+{0x91, 0xaf}, {0x91, 0xc4}, {0x91, 0xd7}, {0x91, 0xe8}, {0x91, 0x20},
+{0x92, 0x00}, {0x93, 0x06}, {0x93, 0xe3}, {0x93, 0x05}, {0x93, 0x05},
+{0x93, 0x00}, {0x93, 0x02}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00},
+{0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x96, 0x00},
+{0x97, 0x08}, {0x97, 0x19}, {0x97, 0x02}, {0x97, 0x0c}, {0x97, 0x24},
+{0x97, 0x30}, {0x97, 0x28}, {0x97, 0x26}, {0x97, 0x02}, {0x97, 0x98},
+{0x97, 0x80}, {0x97, 0x00}, {0x97, 0x00}, {0xc3, 0xed}, {0xa4, 0x00},
+{0xa8, 0x00}, {0xc5, 0x11}, {0xc6, 0x51}, {0xbf, 0x80}, {0xc7, 0x10},
+{0xb6, 0x66}, {0xb8, 0xa5}, {0xb7, 0x64}, {0xb9, 0x7c}, {0xb3, 0xaf},
+{0xb4, 0x97}, {0xb5, 0xff}, {0xb0, 0xc5}, {0xb1, 0x94}, {0xb2, 0x0f},
+{0xc4, 0x5c}, {0xc0, 0xc8}, {0xc1, 0x96}, {0x86, 0x1d}, {0x50, 0x00},
+{0x51, 0x90}, {0x52, 0x18}, {0x53, 0x00}, {0x54, 0x00}, {0x55, 0x88},
+{0x57, 0x00}, {0x5a, 0x90}, {0x5b, 0x18}, {0x5c, 0x05}, {0xc3, 0xed},
+{0x7f, 0x00}, {0xda, 0x04}, {0xe5, 0x1f}, {0xe1, 0x67}, {0xe0, 0x00},
+{0xdd, 0xff}, {0x05, 0x00}, {0xff, 0x01}, {0x11, 0x01},
+
+{0xff, 0x01}, {0x12, 0x40}, {0x17, 0x11}, {0x18, 0x43}, {0x19, 0x00},
+{0x1a, 0x4b}, {0x32, 0x09}, {0x4f, 0xca}, {0x50, 0xa8}, {0x5a, 0x23},
+{0x6d, 0x00}, {0x3d, 0x38},
+
+{0x39, 0x12}, {0x35, 0xda}, {0x22, 0x1a}, {0x37, 0xc3}, {0x23, 0x00},
+{0x34, 0xc0}, {0x36, 0x1a}, {0x06, 0x88}, {0x07, 0xc0}, {0x0d, 0x87},
+{0x0e, 0x41}, {0x4c, 0x00}, {0x48, 0x00}, {0x5B, 0x00}, {0x42, 0x03},
+
+{0xff, 0x00}, {0xe0, 0x04}, {0xc0, 0x64}, {0xc1, 0x4B}, {0x8c, 0x00},
+{0x86, 0x1D}, {0xd3, 0x82}, {0xe0, 0x00},
+
+{0xff, 0x00}, {0xc0, 0x64}, {0xc1, 0x4B}, {0x8c, 0x00}, {0x86, 0x3D},
+{0x50, 0x00}, {0x51, 0xC8}, {0x52, 0x96}, {0x53, 0x00}, {0x54, 0x00},
+{0x55, 0x00}, {0x5a, 0xA0}, {0x5b, 0x78}, {0x5c, 0x00}, {0xd3, 0x04},
+
+/* fps settings are here */
+/* 10 fps */
+/*{0xff, 0x01}, {0x11, 0x01}, {0x3d, 0x3a}, {0x2b, 0x95},*/
+
+/* 15 fps */
+/*{0xff, 0x01}, {0x11, 0x01}, {0x3d, 0x38}, {0x2b, 0x00},*/
+
+/* 20 fps */
+/*{0xff, 0x01}, {0x11, 0x00}, {0x3d, 0x3a}, {0x2b, 0x95},*/
+
+/* 25 fps */
+{0xff, 0x01}, {0x11, 0x00}, {0x3d, 0x39}, {0x2b, 0x3c},
+
+/* 30 fps*/
+/*{0xff, 0x01}, {0x11, 0x01}, {0x3d, 0x38}, {0x2b, 0x00},*/
+
+{0xFF, 0x00}, {0xE0, 0x04}, {0xE1, 0x67}, {0xD7, 0x01}, {0xDA, 0x00},
+{0xD3, 0x82}, {0xE0, 0x00},
+
+{ OV2640_REG_TERM, OV2640_VAL_TERM }
+};
+static const struct ov2640_reg svga_yuv[] = {
+{0xff, 0x01}, {0x12, 0x80}, {0xff, 0x00}, {0x2c, 0xff}, {0x2e, 0xdf},
+{0xff, 0x01}, {0x3c, 0x32}, {0x11, 0x00}, {0x09, 0x02}, {0x04, 0x28},
+{0x13, 0xe5}, {0x14, 0x48}, {0x2c, 0x0c}, {0x33, 0x78}, {0x3a, 0x33},
+{0x3b, 0xfb}, {0x3e, 0x00}, {0x43, 0x11}, {0x16, 0x10}, {0x39, 0x02},
+{0x35, 0x88}, {0x22, 0x0a}, {0x37, 0x40}, {0x23, 0x00}, {0x34, 0xa0},
+{0x36, 0x1a}, {0x06, 0x02}, {0x07, 0xc0}, {0x0d, 0xb7}, {0x0e, 0x01},
+{0x4c, 0x00}, {0x4a, 0x81}, {0x21, 0x99}, {0x24, 0x3a}, {0x25, 0x32},
+{0x26, 0x82}, {0x5c, 0x00}, {0x63, 0x00}, {0x5d, 0x55}, {0x5e, 0x7d},
+{0x5f, 0x7d}, {0x60, 0x55}, {0x61, 0x70}, {0x62, 0x80}, {0x7c, 0x05},
+{0x20, 0x80}, {0x28, 0x30}, {0x6c, 0x00}, {0x6d, 0x80}, {0x6e, 0x00},
+{0x70, 0x02}, {0x71, 0x94}, {0x73, 0xc1}, {0x3d, 0x34}, {0x5a, 0x57},
+{0x4f, 0xbb}, {0x50, 0x9c}, {0xff, 0x00}, {0xe5, 0x7f}, {0xf9, 0xc0},
+{0x41, 0x24}, {0xe0, 0x14}, {0x76, 0xff}, {0x33, 0xa0}, {0x42, 0x20},
+{0x43, 0x18}, {0x4c, 0x00}, {0x87, 0xd0}, {0x88, 0x3f}, {0xd7, 0x03},
+{0xd9, 0x10}, {0xd3, 0x82}, {0xc8, 0x08}, {0xc9, 0x80}, {0x7c, 0x00},
+{0x7d, 0x02}, {0x7c, 0x03}, {0x7d, 0x48}, {0x7d, 0x48}, {0x7c, 0x08},
+{0x7d, 0x20}, {0x7d, 0x10}, {0x7d, 0x0e}, {0x90, 0x00}, {0x91, 0x0e},
+{0x91, 0x1a}, {0x91, 0x31}, {0x91, 0x5a}, {0x91, 0x69}, {0x91, 0x75},
+{0x91, 0x7e}, {0x91, 0x88}, {0x91, 0x8f}, {0x91, 0x96}, {0x91, 0xa3},
+{0x91, 0xaf}, {0x91, 0xc4}, {0x91, 0xd7}, {0x91, 0xe8}, {0x91, 0x20},
+{0x92, 0x00}, {0x93, 0x06}, {0x93, 0xe3}, {0x93, 0x05}, {0x93, 0x05},
+{0x93, 0x00}, {0x93, 0x02}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00},
+{0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x96, 0x00},
+{0x97, 0x08}, {0x97, 0x19}, {0x97, 0x02}, {0x97, 0x0c}, {0x97, 0x24},
+{0x97, 0x30}, {0x97, 0x28}, {0x97, 0x26}, {0x97, 0x02}, {0x97, 0x98},
+{0x97, 0x80}, {0x97, 0x00}, {0x97, 0x00}, {0xc3, 0xed}, {0xa4, 0x00},
+{0xa8, 0x00}, {0xc5, 0x11}, {0xc6, 0x51}, {0xbf, 0x80}, {0xc7, 0x10},
+{0xb6, 0x66}, {0xb8, 0xa5}, {0xb7, 0x64}, {0xb9, 0x7c}, {0xb3, 0xaf},
+{0xb4, 0x97}, {0xb5, 0xff}, {0xb0, 0xc5}, {0xb1, 0x94}, {0xb2, 0x0f},
+{0xc4, 0x5c}, {0xc0, 0xc8}, {0xc1, 0x96}, {0x86, 0x1d}, {0x50, 0x00},
+{0x51, 0x90}, {0x52, 0x18}, {0x53, 0x00}, {0x54, 0x00}, {0x55, 0x88},
+{0x57, 0x00}, {0x5a, 0x90}, {0x5b, 0x18}, {0x5c, 0x05}, {0xc3, 0xed},
+{0x7f, 0x00}, {0xda, 0x04}, {0xe5, 0x1f}, {0xe1, 0x67}, {0xe0, 0x00},
+{0xdd, 0xff}, {0x05, 0x00}, {0xff, 0x01}, {0x11, 0x01},
+
+//SVGA
+{0xff, 0x01}, {0x12, 0x40}, {0x17, 0x11}, {0x18, 0x43}, {0x19, 0x00},
+{0x1a, 0x4b}, {0x32, 0x09}, {0x4f, 0xca}, {0x50, 0xa8}, {0x5a, 0x23},
+{0x6d, 0x00}, {0x3d, 0x38},
+
+{0x39, 0x12}, {0x35, 0xda}, {0x22, 0x1a}, {0x37, 0xc3}, {0x23, 0x00},
+{0x34, 0xc0}, {0x36, 0x1a}, {0x06, 0x88}, {0x07, 0xc0}, {0x0d, 0x87},
+{0x0e, 0x41}, {0x4c, 0x00}, {0x48, 0x00}, {0x5B, 0x00}, {0x42, 0x03},
+
+{0xff, 0x00}, {0xe0, 0x04}, {0xc0, 0x64}, {0xc1, 0x4B}, {0x8c, 0x00},
+{0x86, 0x1D}, {0xd3, 0x82}, {0xe0, 0x00},
+
+/* 25 fps*/
+{0xff, 0x01}, {0x11, 0x00}, {0x3d, 0x39}, {0x2b, 0x3c},
+
+//V422
+{0xFF, 0x00}, {0xE0, 0x04}, {0xE1, 0x67}, {0xD7, 0x01}, {0xDA, 0x00},
+{0xD3, 0x82}, {0xE0, 0x00},
+
+{ OV2640_REG_TERM, OV2640_VAL_TERM }
+};
+
+static const struct ov2640_reg sxga_yuv[] = {
+{0xff, 0x01}, {0x12, 0x80}, {0xff, 0x00}, {0x2c, 0xff}, {0x2e, 0xdf},
+{0xff, 0x01}, {0x3c, 0x32}, {0x11, 0x00}, {0x09, 0x02}, {0x04, 0x28},
+{0x13, 0xe5}, {0x14, 0x48}, {0x2c, 0x0c}, {0x33, 0x78}, {0x3a, 0x33},
+{0x3b, 0xfb}, {0x3e, 0x00}, {0x43, 0x11}, {0x16, 0x10}, {0x39, 0x02},
+{0x35, 0x88}, {0x22, 0x0a}, {0x37, 0x40}, {0x23, 0x00}, {0x34, 0xa0},
+{0x36, 0x1a}, {0x06, 0x02}, {0x07, 0xc0}, {0x0d, 0xb7}, {0x0e, 0x01},
+{0x4c, 0x00}, {0x4a, 0x81}, {0x21, 0x99}, {0x24, 0x3a}, {0x25, 0x32},
+{0x26, 0x82}, {0x5c, 0x00}, {0x63, 0x00}, {0x5d, 0x55}, {0x5e, 0x7d},
+{0x5f, 0x7d}, {0x60, 0x55}, {0x61, 0x70}, {0x62, 0x80}, {0x7c, 0x05},
+{0x20, 0x80}, {0x28, 0x30}, {0x6c, 0x00}, {0x6d, 0x80}, {0x6e, 0x00},
+{0x70, 0x02}, {0x71, 0x94}, {0x73, 0xc1}, {0x3d, 0x34}, {0x5a, 0x57},
+{0x4f, 0xbb}, {0x50, 0x9c}, {0xff, 0x00}, {0xe5, 0x7f}, {0xf9, 0xc0},
+{0x41, 0x24}, {0xe0, 0x14}, {0x76, 0xff}, {0x33, 0xa0}, {0x42, 0x20},
+{0x43, 0x18}, {0x4c, 0x00}, {0x87, 0xd0}, {0x88, 0x3f}, {0xd7, 0x03},
+{0xd9, 0x10}, {0xd3, 0x82}, {0xc8, 0x08}, {0xc9, 0x80}, {0x7c, 0x00},
+{0x7d, 0x02}, {0x7c, 0x03}, {0x7d, 0x48}, {0x7d, 0x48}, {0x7c, 0x08},
+{0x7d, 0x20}, {0x7d, 0x10}, {0x7d, 0x0e}, {0x90, 0x00}, {0x91, 0x0e},
+{0x91, 0x1a}, {0x91, 0x31}, {0x91, 0x5a}, {0x91, 0x69}, {0x91, 0x75},
+{0x91, 0x7e}, {0x91, 0x88}, {0x91, 0x8f}, {0x91, 0x96}, {0x91, 0xa3},
+{0x91, 0xaf}, {0x91, 0xc4}, {0x91, 0xd7}, {0x91, 0xe8}, {0x91, 0x20},
+{0x92, 0x00}, {0x93, 0x06}, {0x93, 0xe3}, {0x93, 0x05}, {0x93, 0x05},
+{0x93, 0x00}, {0x93, 0x02}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00},
+{0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x93, 0x00}, {0x96, 0x00},
+{0x97, 0x08}, {0x97, 0x19}, {0x97, 0x02}, {0x97, 0x0c}, {0x97, 0x24},
+{0x97, 0x30}, {0x97, 0x28}, {0x97, 0x26}, {0x97, 0x02}, {0x97, 0x98},
+{0x97, 0x80}, {0x97, 0x00}, {0x97, 0x00}, {0xc3, 0xed}, {0xa4, 0x00},
+{0xa8, 0x00}, {0xc5, 0x11}, {0xc6, 0x51}, {0xbf, 0x80}, {0xc7, 0x10},
+{0xb6, 0x66}, {0xb8, 0xa5}, {0xb7, 0x64}, {0xb9, 0x7c}, {0xb3, 0xaf},
+{0xb4, 0x97}, {0xb5, 0xff}, {0xb0, 0xc5}, {0xb1, 0x94}, {0xb2, 0x0f},
+{0xc4, 0x5c}, {0xc0, 0xc8}, {0xc1, 0x96}, {0x86, 0x1d}, {0x50, 0x00},
+{0x51, 0x90}, {0x52, 0x18}, {0x53, 0x00}, {0x54, 0x00}, {0x55, 0x88},
+{0x57, 0x00}, {0x5a, 0x90}, {0x5b, 0x18}, {0x5c, 0x05}, {0xc3, 0xed},
+{0x7f, 0x00}, {0xda, 0x04}, {0xe5, 0x1f}, {0xe1, 0x67}, {0xe0, 0x00},
+{0xdd, 0xff}, {0x05, 0x00}, {0xff, 0x01}, {0x11, 0x00},
+
+
+//SXGA
+{0xff, 0x00}, {0xc0, 0xc8}, {0xc1, 0x96}, {0x8c, 0x00}, {0x86, 0x3d},
+{0x50, 0x00}, {0x51, 0x90}, {0x52, 0x2c}, {0x53, 0x00}, {0x54, 0x00},
+{0x55, 0x88}, {0x5a, 0x40}, {0x5b, 0x00}, {0x5c, 0x05}, {0xd3, 0x82},
+
+//V422
+{0xFF, 0x00}, {0xE0, 0x04}, {0xE1, 0x67}, {0xD7, 0x01}, {0xDA, 0x00},
+{0xD3, 0x82}, {0xE0, 0x00},
+
+{ OV2640_REG_TERM, OV2640_VAL_TERM }
+};
+
+/* 565 configs */
+static const struct ov2640_reg qqcif_565[] = { };
+static const struct ov2640_reg qqvga_565[] = { };
+static const struct ov2640_reg qcif_565[] = { };
+static const struct ov2640_reg qvga_565[] = { };
+static const struct ov2640_reg cif_565[] = { };
+static const struct ov2640_reg vga_565[] = { };
+static const struct ov2640_reg svga_565[] = { };
+static const struct ov2640_reg sxga_565[] = { };
+
+/* 555 configs */
+static const struct ov2640_reg qqcif_555[] = { };
+static const struct ov2640_reg qqvga_555[] = { };
+static const struct ov2640_reg qcif_555[] = { };
+static const struct ov2640_reg qvga_555[] = { };
+static const struct ov2640_reg cif_555[] = { };
+static const struct ov2640_reg vga_555[] = { };
+static const struct ov2640_reg svga_555[] = { };
+static const struct ov2640_reg sxga_555[] = { };
+
+static const struct ov2640_reg *
+	ov2640_reg_init[NUM_PIXEL_FORMATS][NUM_IMAGE_SIZES] = {
+		{ qqcif_yuv, qqvga_yuv, qcif_yuv, qvga_yuv, cif_yuv, vga_yuv, svga_yuv, sxga_yuv },
+		{ qqcif_565, qqvga_565, qcif_565, qvga_565, cif_565, vga_565, svga_565, sxga_565 },
+		{ qqcif_555, qqvga_555, qcif_555, qvga_555, cif_555, vga_555, svga_555, sxga_555 },
+	};
+//static struct i2c_driver ov2640_driver;
+
+/*
+ * Write a value to a register in an OV2640 sensor device.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int
+ov2640_write_reg(struct i2c_client *client, u8 reg, u8 val)
+{
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[2];
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	msg->addr = client->addr;
+	msg->flags = 0;
+	msg->len = 2;
+	msg->buf = data;
+	data[0] = reg;
+	data[1] = val;
+	err = i2c_transfer(client->adapter, msg, 1);
+	if (err >= 0)
+		return 0;
+	return err;
+}
+/*
+ * Read a value from a register in an OV2640 sensor device.
+ * The value is returned in 'val'.
+ * Returns zero if successful, or non-zero otherwise.
+ */
+static int
+ov2640_read_reg(struct i2c_client *client, u8 reg, u8 *val)
+{
+	int err;
+	struct i2c_msg msg[1];
+	unsigned char data[1];
+
+	if (!client->adapter)
+		return -ENODEV;
+
+	msg->addr = client->addr;
+	msg->flags = 0;
+	msg->len = 1;
+	msg->buf = data;
+	*data = reg;
+	err = i2c_transfer(client->adapter, msg, 1);
+	if (err >= 0) {
+		msg->flags = I2C_M_RD;
+		err = i2c_transfer(client->adapter, msg, 1);
+	}
+	if (err >= 0) {
+		*val = *data;
+		return 0;
+	}
+	return err;
+}
+
+
+/* fct use to initialize all the registers */
+static int
+ov2640_write_regs(struct ov2640 *is, const struct ov2640_reg reglist[])
+{
+	int err;
+	const struct ov2640_reg *next = reglist;
+
+	while (!((next->reg == OV2640_REG_TERM)
+		&& (next->val == OV2640_VAL_TERM))) {
+		err = ov2640_write_reg(is->client, next->reg, next->val);
+		udelay(100);
+		if (err)
+			return err;
+		next++;
+	}
+	return 0;
+}
+
+#ifdef DEBUG
+/* fct use to dump all the registers */
+static int
+ov2640_dump_regs(struct ov2640 *is, const struct ov2640_reg reglist[])
+{
+	int err, i;
+	u8 val;
+
+	for (i = 0; i < 255; i++) {
+		err = ov2640_read_reg(is->client, (unsigned char)i, &val);
+		pr_debug("ov2640: dump reg: reg %x, value %x\n", i, val);
+		udelay(100);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+#endif
+
+/*
+ * Find the best match for a requested image capture size.  The best match
+ * is chosen as the nearest match that has the same number or fewer pixels
+ * as the requested size, or the smallest image size if the requested size
+ * has fewer pixels than the smallest image.
+ */
+static enum image_size
+ov2640_find_size(unsigned int width, unsigned int height)
+{
+	enum image_size isize;
+	unsigned long pixels = width*height;
+
+	for (isize = QQCIF; isize < SXGA; isize++) {
+		if (ov2640_sizes[isize + 1].height *
+			ov2640_sizes[isize + 1].width > pixels)
+			return isize;
+	}
+	return SXGA;
+}
+
+
+/*
+ * Configure the OV2640 for a specified image size, pixel format, and frame
+ * period.
+ * Returns zero if successful, or non-zero otherwise.
+ * The actual frame period is returned in fper.
+ */
+static int ov2640_configure(struct atmel_isi_camera *cam,
+			   struct atmel_isi_format *fmt)
+{
+	struct ov2640 *is = to_ov2640(cam);
+	int err;
+	enum pixel_format pfmt = YUV;
+	enum image_size isize;
+
+	if (!fmt) {
+		/* default SVGA */
+		isize = SVGA;
+		pfmt = YUV;
+	} else {
+		switch (fmt->pix.pixelformat) {
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_RGB565X:
+			pfmt = RGB565;
+			break;
+		case V4L2_PIX_FMT_RGB555:
+		case V4L2_PIX_FMT_RGB555X:
+			pfmt = RGB555;
+			break;
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_UYVY:
+		default:
+			pfmt = YUV;
+		}
+		isize = ov2640_find_size(fmt->pix.width, fmt->pix.height);
+	}
+
+	/* configure image size and pixel format */
+	/* static for the time being */
+	err = ov2640_write_regs(is, ov2640_reg_init[pfmt][isize]);
+	if (err) {
+		printk(KERN_DEBUG "ov2640 config failed\n");
+		return err;
+	}
+
+	return 0;
+}
+
+
+static int ov2640_get_format(struct atmel_isi_camera *cam,
+			   struct atmel_isi_format *fmt)
+{
+	int err = 0;
+
+	return err;
+}
+
+static int ov2640_set_format(struct atmel_isi_camera *cam,
+			   struct atmel_isi_format *fmt)
+{
+	struct ov2640 *is = to_ov2640(cam);
+	int err;
+
+	mutex_lock(&is->mutex);
+
+	err = ov2640_configure(&is->cam, fmt);
+	if (err)
+		goto out;
+
+	pr_debug("%s: set_format %ux%u\n", cam->name,
+		 fmt->pix.width, fmt->pix.height);
+
+out:
+	mutex_unlock(&is->mutex);
+	return err;
+}
+
+static int ov2640_start_capture(struct atmel_isi_camera *cam, struct atmel_isi_format *fmt)
+{
+	struct ov2640 *is = to_ov2640(cam);
+	int err = 0;
+
+	mutex_lock(&is->mutex);
+
+	/* Set the color bar test mode: to test wether the sensor is
+	 * properly configure or not.
+	 */
+	/*err = ov2640_write_reg(&is->client, 0xFF, 0x01);
+	err = ov2640_write_reg(&is->client, OV2640_COM7, OV2640_COLORBAR);*/
+
+	mutex_unlock(&is->mutex);
+	return err;
+}
+
+static int ov2640_stop_capture(struct atmel_isi_camera *cam)
+{
+	struct ov2640 *is = to_ov2640(cam);
+
+	mutex_lock(&is->mutex);
+
+	/* Need to do something here? */
+
+	mutex_unlock(&is->mutex);
+
+	return 0;
+}
+
+static void ov2640_reset(struct ov2640 *is)
+{
+	int err;
+
+	err = ov2640_write_reg(is->client, 0XFF, 0x01);
+	/* Reset Pin = COM7 bit 7*/
+	err = ov2640_write_reg(is->client, OV2640_COM7, OV2640_RESET);
+	if (err)
+		pr_debug("ov2640_reset failed\n");
+}
+
+static int ov2640_init_hardware(struct ov2640 *is)
+{
+	int err = 0;
+	u8 midh, midl, pidh;
+
+	/* Try to identify the camera */
+	if (ov2640_read_reg(is->client, OV2640_MIDH, &midh))
+		return -ENODEV;
+	if (ov2640_read_reg(is->client, OV2640_MIDL, &midl))
+		return -ENODEV;
+	if (ov2640_read_reg(is->client, OV2640_PIDH, &pidh))
+		return -ENODEV;
+
+	pr_debug("midh = 0x%08x, midl = 0x%08x, pidh = 0x%08x\n", midh, midl, pidh);
+
+	if ((midh != OV2640_MIDH_MAGIC)
+		|| (midl != OV2640_MIDL_MAGIC)
+		|| (pidh != OV2640_PID_MAGIC))
+		/*
+		 * We didn't read the values we expected, so
+		 * this must not be an OV2640.
+		 */
+		return -ENODEV;
+
+	/* Default config is YUV?? */
+	err =  ov2640_configure(&is->cam, NULL);
+	if (err) {
+		pr_debug("init config failed for ov2640\n");
+		return err;
+	}
+
+	/* Hey, that was easy. */
+	return err;
+}
+
+
+static int ov2640_probe(struct i2c_client *client,
+			      const struct i2c_device_id *id)
+{
+	//struct i2c_client *client;
+	struct ov2640 *is;
+	int err;
+
+	//pr_debug("ov2640: detecting client on address 0x%x\n", address);
+
+	/* Check if the adapter supports the needed features */
+	//if (!i2c_check_functionality(adapter,
+	//			     (I2C_FUNC_SMBUS_READ_BYTE_DATA
+	//			      | I2C_FUNC_SMBUS_WRITE_BYTE_DATA
+	//			      | I2C_FUNC_SMBUS_READ_WORD_DATA
+	//			      | I2C_FUNC_SMBUS_WRITE_WORD_DATA)))
+	//	return 0;
+
+	is = kzalloc(sizeof(struct ov2640), GFP_KERNEL);
+	if (!is)
+		return -ENOMEM;
+
+	//client = &is->client;
+	//client->addr = address;
+	//client->adapter = adapter;
+	//client->driver = &ov2640_driver;
+	//strcpy(client->name, "ov2640");
+
+	is->client = client;
+
+	is->cam.name = client->name;
+	is->cam.hsync_act_low = 1;
+	is->cam.vsync_act_low = 0;
+	is->cam.pclk_act_falling = 0;
+	is->cam.has_emb_sync = 0;
+	is->cam.get_format = ov2640_get_format;
+	is->cam.set_format = ov2640_set_format;
+	is->cam.start_capture = ov2640_start_capture;
+	is->cam.stop_capture = ov2640_stop_capture;
+
+	mutex_init(&is->mutex);
+
+	is->mclk = clk_get(NULL, mclk_name);
+	if (IS_ERR(is->mclk)) {
+		err = PTR_ERR(is->mclk);
+		goto err_clk;
+	}
+	clk_enable(is->mclk);
+
+	//err = i2c_attach_client(client);
+	//if (err)
+	//	goto err_attach;
+
+	i2c_set_clientdata(client, is);
+
+	err = ov2640_init_hardware(is);
+
+	if (err)
+		goto err_init_hw;
+
+	/* We're up and running. Notify the ISI driver */
+	err = atmel_isi_register_camera(&is->cam);
+	if (err)
+		goto err_register;
+
+	//pr_debug("OV2640 Image Sensor at %s:0x%02x\n",
+	//       adapter->name, address);
+
+	return 0;
+
+err_register:
+err_init_hw:
+	ov2640_reset(is);
+err_clk:
+	kfree(is);
+	return err;
+}
+
+//static int ov2640_attach_adapter(struct i2c_adapter *adapter)
+//{
+//	int err;
+//	pr_debug("ov2640: starting probe for adapter %s (%u)\n",
+//		 adapter->name, adapter->id);
+//
+//	err = i2c_probe(adapter, &addr_data, ov2640_detect_client);
+//
+//	return err;
+//}
+
+static int ov2640_remove(struct i2c_client *client)
+{
+	struct ov2640 *is = i2c_get_clientdata(client);
+	//int err;
+
+	atmel_isi_unregister_camera(&is->cam);
+
+	ov2640_reset(is);
+
+	//err = i2c_detach_client(client);
+	//if (err)
+	//	return err;
+
+	clk_disable(is->mclk);
+	clk_put(is->mclk);
+	kfree(is);
+
+	return 0;
+}
+
+struct i2c_device_id ov2640_idtable[] = {
+	{"ov2640 I2C Codec", OV2640_I2C_ADDR},
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, ov2640_idtable);
+
+static struct i2c_driver ov2640_driver = {
+	.driver = {
+		.name	= "ov2640 I2C Codec",
+		.owner = THIS_MODULE,
+	},
+//	.id		= I2C_DRIVERID_OV2640,
+//	.attach_adapter	= &ov2640_attach_adapter,
+//	.detach_client	= &ov2640_detach_client,
+	.probe		= &ov2640_probe,
+	.remove		= &ov2640_remove,
+	.id_table	= ov2640_idtable,
+	.command = NULL,
+};
+
+
+static struct clk *mclk;
+
+static int __init ov2640_init(void)
+{
+	int err;
+
+	/*
+	 * Set up the master clock, if available. If clk_get() fails,
+	 * this hopefully means that the board generates a suitable
+	 * master clock some other way, which is fine by us.
+	 *
+	 * We need to do this before probing the i2c bus, as the
+	 * camera won't ack any messages when it doesn't have a clock.
+	 */
+
+	mclk = clk_get(NULL, mclk_name);
+	if (!IS_ERR(mclk)) {
+		clk_enable(mclk);
+		pr_debug("isi_clk enable\n");
+	} else {
+		mclk = NULL;
+		pr_debug("no isi clock enable\n");
+	}
+
+	err = i2c_add_driver(&ov2640_driver);
+	if (err) {
+		pr_debug("Failed to register ov2640\n");
+		return err;
+	}
+	return 0;
+}
+module_init(ov2640_init);
+
+static void __exit ov2640_exit(void)
+{
+	if (mclk) {
+		clk_disable(mclk);
+		clk_put(mclk);
+	}
+
+	i2c_del_driver(&ov2640_driver);
+}
+module_exit(ov2640_exit);
+
+MODULE_AUTHOR("Sedji Gaouaou <sedji.gaouaou@atmel.com>");
+MODULE_DESCRIPTION("Omnivision ov955 Image Sensor driver");
+MODULE_LICENSE("GPL");
Index: linux-2.6.35/drivers/media/video/ov2640.h
===================================================================
--- linux-2.6.35/drivers/media/video/ov2640.h	(revision 0)
+++ linux-2.6.35/drivers/media/video/ov2640.h	(revision 150)
@@ -0,0 +1,128 @@
+/*
+ * drivers/media/video/ov2640.h
+ *
+ * Register definitions for the OmniVision OV2640 CameraChip.
+ *
+ * Author: Andy Lowe (source@mvista.com)
+ *
+ * Copyright (C) 2004 MontaVista Software, Inc.
+ * Copyright (C) 2004 Texas Instruments.
+ *
+ * This file is licensed under the terms of the GNU General Public License
+ * version 2. This program is licensed "as is" without any warranty of any
+ * kind, whether express or implied.
+ */
+
+#ifndef OV2640_H
+#define OV2640_H
+
+#define OV2640_I2C_ADDR		0x30
+
+/* define register offsets for the OV2640 sensor chip */
+#define OV2640_GAIN		0x00
+#define OV2640_COM1		0x03
+#define OV2640_REG04		0x04
+#define OV2640_REG08		0x08
+#define OV2640_COM2		0x09
+#define OV2640_PIDH		0x0A
+#define OV2640_PIDL		0x0B
+#define OV2640_COM3		0x0C
+#define OV2640_AEC		0x10
+#define OV2640_CLKRC		0x11
+#define OV2640_COM7		0x12
+#define OV2640_COM8		0x13
+#define OV2640_COM9		0x14
+#define OV2640_COM10		0x15
+#define OV2640_HREFST		0x17
+#define OV2640_HREFEND		0x18
+#define OV2640_VSTRT		0x19
+#define OV2640_VEND		0x1A
+#define OV2640_MIDH		0x1C
+#define OV2640_MIDL		0x1D
+#define OV2640_AEW		0x24
+#define OV2640_AEB		0x25
+#define OV2640_W		0x26
+#define OV2640_REG2A		0x2A
+#define OV2640_FRARL		0x2B
+#define OV2640_ADDVSL		0x2D
+#define OV2640_ADDVSH		0x2E
+#define OV2640_YAVG		0x2F
+#define OV2640_REG32		0x32
+#define OV2640_ARCOM2		0x32
+#define OV2640_REG45		0x45
+#define OV2640_FLL		0x46
+#define OV2640_FLH		0x47
+#define OV2640_COM19		0x48
+#define OV2640_ZOOMS		0x49
+#define OV2640_COM22		0x4B
+#define OV2640_COM25		0x4E
+#define OV2640_BD50		0x4F
+#define OV2640_BD60		0x50
+#define OV2640_REG5D		0x5D
+#define OV2640_REG5E		0x5E
+#define OV2640_REG5F		0x5F
+#define OV2640_REG60		0x60
+#define OV2640_HISTO_LOW	0x61
+#define OV2640_HISTO_HIGH	0x62
+
+#define OV2640_NUM_REGS		(OV2640_HISTO_HIGH + 1)
+
+#define OV2640_PID_MAGIC	0x26	/* high byte of product ID number */
+#define OV2640_MIDH_MAGIC	0x7F	/* high byte of mfg ID */
+#define OV2640_MIDL_MAGIC	0xA2	/* low byte of mfg ID */
+
+#define OV2640_REG_TERM 0xFF	/* terminating list entry for reg */
+#define OV2640_VAL_TERM 0xFF	/* terminating list entry for val */
+
+/*
+ * The nominal xclk input frequency of the OV2640 is 24MHz, maximum
+ * frequency is 48MHz, and minimum frequency is 10MHz.
+ */
+#define OV2640_XCLK_MIN 10000000
+#define OV2640_XCLK_MAX 48000000
+#define OV2640_XCLK_NOM 24000000
+
+/* Reset value in register COM7*/
+#define OV2640_RESET	0x80
+#define OV2640_COLORBAR	0x02
+/* define a structure for ov2640 register initialization values */
+struct ov2640_reg {
+	unsigned char reg;
+	unsigned char val;
+};
+
+enum image_size { QQCIF, QQVGA, QCIF, QVGA, CIF, VGA, SVGA, SXGA };
+enum pixel_format { YUV, RGB565, RGB555 };
+
+#define NUM_IMAGE_SIZES 8
+#define NUM_PIXEL_FORMATS 3
+
+struct capture_size {
+	unsigned long width;
+	unsigned long height;
+};
+
+struct ov2640_platform_data {
+	/* Set power state, zero is off, non-zero is on. */
+	int (*power_set)(int power);
+	/* Default registers written after power-on or reset. */
+	const struct ov2640_reg *default_regs;
+	int (*ifparm)(struct v4l2_ifparm *p);
+};
+
+/*
+ * Array of image sizes supported by OV2640.  These must be ordered from
+ * smallest image size to largest.
+ */
+static const struct capture_size ov2640_sizes[] = {
+	{   88,  72 },	/* QQCIF */
+	{  160, 120 },	/* QQVGA */
+	{  176, 144 },	/* QCIF */
+	{  320, 240 },	/* QVGA */
+	{  352, 288 },	/* CIF */
+	{  640, 480 },	/* VGA */
+	{  800, 600 },	/* SVGA */
+	{ 1280, 960 },	/* SXGA */
+};
+
+#endif /* ifndef OV2640_H */
Index: linux-2.6.35/drivers/media/video/Makefile
===================================================================
--- linux-2.6.35/drivers/media/video/Makefile	(revision 149)
+++ linux-2.6.35/drivers/media/video/Makefile	(revision 150)
@@ -70,6 +70,7 @@
 obj-$(CONFIG_VIDEO_UPD64031A) += upd64031a.o
 obj-$(CONFIG_VIDEO_UPD64083) += upd64083.o
 obj-$(CONFIG_VIDEO_OV7670) 	+= ov7670.o
+obj-$(CONFIG_VIDEO_OV2640)	+= ov2640_atmel.o
 obj-$(CONFIG_VIDEO_TCM825X) += tcm825x.o
 obj-$(CONFIG_VIDEO_TVEEPROM) += tveeprom.o
 obj-$(CONFIG_VIDEO_MT9V011) += mt9v011.o
@@ -110,6 +111,7 @@
 obj-$(CONFIG_VIDEO_MXB) += mxb.o
 obj-$(CONFIG_VIDEO_HEXIUM_ORION) += hexium_orion.o
 obj-$(CONFIG_VIDEO_HEXIUM_GEMINI) += hexium_gemini.o
+obj-$(CONFIG_VIDEO_ATMEL_ISI) += atmel-isi.o
 
 obj-$(CONFIG_VIDEOBUF_GEN) += videobuf-core.o
 obj-$(CONFIG_VIDEOBUF_DMA_SG) += videobuf-dma-sg.o
Index: linux-2.6.35/drivers/media/video/atmel-isi.c
===================================================================
--- linux-2.6.35/drivers/media/video/atmel-isi.c	(revision 0)
+++ linux-2.6.35/drivers/media/video/atmel-isi.c	(revision 150)
@@ -0,0 +1,2026 @@
+/*
+ * Copyright (c) 2007 Atmel Corporation
+ *
+ * Based on the bttv driver for Bt848 with respective copyright holders
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#define DEBUG			12
+#define VERBOSE		12
+#define VERBOSE_DEBUG		12
+
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/dma-mapping.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioctl.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/version.h>
+#include <linux/videodev2.h>
+#include <linux/wait.h>
+
+#include <linux/kfifo.h>
+#include <linux/time.h>
+
+#include <linux/io.h>
+
+#include <media/v4l2-common.h>
+#include <media/v4l2-ioctl.h>
+
+#include <mach/board.h>
+#include <mach/cpu.h>
+
+#include <media/atmel-isi.h>
+
+#define ATMEL_ISI_VERSION	KERNEL_VERSION(0, 1, 0)
+#define ISI_CODEC 1
+
+/* Default ISI capture buffer size */
+#define ISI_CAPTURE_BUFFER_SIZE	(800 * 600 * 2)
+/* Default ISI video frame size ie qvga */
+#define ISI_VIDEO_BUFFER_SIZE	(320 * 240 * 2)
+/* Default number of ISI video buffers */
+
+#define ISI_VIDEO_BUFFERS 4/*(if qvga we can use 4 buffers)*/
+/* Maximum number of video buffers */
+#define ISI_VIDEO_BUFFERS_MAX (8 * 4)
+/* Interrupt mask for a single capture */
+#define ISI_CAPTURE_MASK (ISI_BIT(SOF) | ISI_BIT(FO_C_EMP))
+#define ISI_V2_CAPTURE_MASK (ISI_BIT(V2_VSYNC) | ISI_BIT(V2_CXFR_DONE) | ISI_BIT(V2_PXFR_DONE))
+/* ISI capture buffer size */
+static int capture_buffer_size = ISI_CAPTURE_BUFFER_SIZE;
+/* Number of buffers used for streaming video */
+static int video_buffers = ISI_VIDEO_BUFFERS;
+static int video_buffer_size = ISI_VIDEO_BUFFER_SIZE;
+
+static int input_format = ATMEL_ISI_PIXFMT_CbYCrY;
+static u8 has_emb_sync;
+static u8 emb_crc_sync;
+static u8 hsync_act_low;
+static u8 vsync_act_low;
+static u8 pclk_act_falling;
+static u8 isi_full_mode;
+static u8  gs_mode;
+/* Preview path horizontal size */
+static int prev_hsize = 320;
+/* Preview path vertical size */
+static int prev_vsize = 240;
+/* Scaling factor of the preview path */
+static int prev_decimation_factor = 16;
+
+/* Input image horizontal size */
+static int image_hsize = 320;
+/* Input image vertical size */
+static int image_vsize = 240;
+
+static struct timeval start_time;
+/* Frame rate scaler
+ * 1 = capture every second frame
+ * 2 = capture every third frame
+ * ...
+ * */
+static int frame_rate_scaler;
+
+/* Set this value if we want to pretend a specific V4L2 output format
+ *  This format is for the capturing interface
+ */
+static int capture_v4l2_fmt = V4L2_PIX_FMT_YUYV;
+
+/* Set this value if we want to pretend a specific V4L2 output format
+ *  This format is for the streaming interface
+ */
+static int streaming_v4l2_fmt = V4L2_PIX_FMT_YUYV;
+
+/* Declare static vars that will be used as parameters */
+static int video_nr = -1;	/* 0 <-> dev/video0, 1 <-> dev/video1, -1 <-> first free */
+
+MODULE_PARM_DESC(video_buffers, "Number of frame buffers used for streaming");
+module_param(video_buffers, int, 0664);
+MODULE_PARM_DESC(capture_buffer_size, "Capture buffer size");
+module_param(capture_buffer_size, int, 0664);
+MODULE_PARM_DESC(image_hsize, "Horizontal size of input image");
+module_param(image_hsize, int, 0664);
+MODULE_PARM_DESC(image_vsize, "Vertical size of input image");
+module_param(image_vsize, int, 0664);
+MODULE_PARM_DESC(frame_rate_scaler, "Frame rate scaler");
+module_param(frame_rate_scaler, int, 0664);
+MODULE_PARM_DESC(prev_hsize, "Horizontal image size of preview path output");
+module_param(prev_hsize, int, 0664);
+MODULE_PARM_DESC(prev_vsize, "Vertical image size of preview path output");
+module_param(prev_vsize, int, 0664);
+MODULE_PARM_DESC(prev_decimation_factor, "Preview path decimaion factor");
+module_param(prev_decimation_factor, int, 0664);
+module_param(video_nr,          int, 0444);
+
+/* Single frame capturing states */
+enum {
+	STATE_IDLE = 0,
+	STATE_CAPTURE_READY,
+	STATE_CAPTURE_WAIT_SOF,
+	STATE_CAPTURE_IN_PROGRESS,
+	STATE_CAPTURE_DONE,
+	STATE_CAPTURE_ERROR,
+};
+
+/* Frame buffer states
+ *  FRAME_UNUSED Frame(buffer) is not used by the ISI module -> an application
+ *  can usually read out data in this state
+ *  FRAME_QUEUED An application has queued the buffer in the incoming queue
+ *  FRAME_DONE The ISI module has filled the buffer with data and placed is on
+ *  the outgoing queue
+ *  FRAME_ERROR Not used at the moment
+ *  */
+enum frame_status {
+	FRAME_UNUSED,
+	FRAME_QUEUED,
+	FRAME_DONE,
+	FRAME_ERROR,
+};
+/* Frame buffer descriptor
+ *  Used by the ISI module as a linked list for the DMA controller.
+ */
+struct fbd {
+	/* Physical address of the frame buffer */
+	dma_addr_t fb_address;
+#if defined(CONFIG_ARCH_AT91SAM9G45) || defined(CONFIG_ARCH_AT91SAM9M10) || defined(CONFIG_ARCH_AT91SAM9X5)
+	/* DMA Control Register(new: only in HISI2) */
+	u32 dma_ctrl;
+#endif
+	/* Physical address of the next fbd */
+	dma_addr_t next_fbd_address;
+};
+
+/* Frame buffer data
+ */
+struct frame_buffer {
+	/*  Frame buffer descriptor
+	 *  Used by the ISI DMA controller to provide linked list DMA operation
+	 */
+	struct fbd fb_desc;
+	/* Pointer to the start of the frame buffer */
+	void *frame_buffer;
+	/* Timestamp of the captured frame */
+	struct timeval timestamp;
+	/* Frame number of the frame  */
+	unsigned long sequence;
+	/* Buffer number*/
+	int index;
+	/* Bytes used in the buffer for data, needed as buffers are always
+	 *  aligned to pages and thus may be bigger than the amount of data*/
+	int bytes_used;
+	/* Mmap count
+	 *  Counter to measure how often this buffer is mmapped
+	 */
+	int mmap_count;
+	/* Buffer status */
+	enum frame_status status;
+};
+
+struct atmel_isi {
+	/* ISI module spin lock. Protects against concurrent access of variables
+	 * that are shared with the ISR */
+	spinlock_t			lock;
+	void __iomem			*regs;
+	/* Pointer to the start of the fbd list */
+	dma_addr_t			fbd_list_start;
+	/* Frame buffers */
+	struct frame_buffer		video_buffer[ISI_VIDEO_BUFFERS_MAX];
+	/* Frame buffer currently used by the ISI module */
+	struct frame_buffer		*current_buffer;
+	/* Size of a frame buffer */
+	size_t				capture_buffer_size;
+	/* Streaming status
+	 *  If set ISI is in streaming mode */
+	int				streaming;
+	/* Queue for incoming buffers
+	 *  The buffer number (index) is stored in the fifo as reference
+	 */
+	int				head, tail;
+	/* State of the ISI module in capturing mode */
+	int				state;
+	/* Pointer to ISI buffer */
+	void				*capture_buf;
+	/* Physical address of the capture buffer */
+	dma_addr_t			capture_phys;
+	/* Size of the ISI buffer */
+	size_t				capture_buf_size;
+	/* Capture/streaming wait queue */
+	wait_queue_head_t		capture_wq;
+
+	struct atmel_isi_camera		*camera;
+	struct atmel_isi_format		format;
+	struct atmel_isi_format		streaming_format;
+
+	struct mutex			mutex;
+	/* User counter for the streaming interface */
+	int				stream_users;
+	/* User counter of the capture interface */
+	int				capture_users;
+	/* Video device for capturing (Codec path) */
+	struct video_device		cdev;
+	/* Video device for streaming (Preview path) */
+	struct video_device		vdev;
+	struct completion		reset_complete;
+	struct clk			*pclk;
+	struct clk			*hclk;
+	struct platform_device		*pdev;
+	unsigned int			irq;
+};
+
+#define to_atmel_isi(vdev) container_of(vdev, struct atmel_isi, vdev)
+
+struct atmel_isi_fh {
+	struct atmel_isi		*isi;
+	unsigned int			read_off;
+};
+
+/*-----------------------------------------------------------------------------
+ * Interface to the actual camera.
+ */
+static LIST_HEAD(camera_list);
+static DEFINE_MUTEX(camera_list_mutex);
+
+static void atmel_isi_release_camera(struct atmel_isi *isi,
+				     struct atmel_isi_camera *cam)
+{
+	mutex_lock(&camera_list_mutex);
+	cam->isi = NULL;
+	isi->camera = NULL;
+	module_put(cam->owner);
+	mutex_unlock(&camera_list_mutex);
+}
+
+int atmel_isi_register_camera(struct atmel_isi_camera *cam)
+{
+	pr_debug("atmel_isi: register camera %s\n", cam->name);
+
+	mutex_lock(&camera_list_mutex);
+	list_add_tail(&cam->list, &camera_list);
+	mutex_unlock(&camera_list_mutex);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(atmel_isi_register_camera);
+
+void atmel_isi_unregister_camera(struct atmel_isi_camera *cam)
+{
+	pr_debug("atmel_isi: unregister camera %s\n", cam->name);
+
+	mutex_lock(&camera_list_mutex);
+	if (cam->isi)
+		cam->isi->camera = NULL;
+	list_del(&cam->list);
+	mutex_unlock(&camera_list_mutex);
+}
+EXPORT_SYMBOL_GPL(atmel_isi_unregister_camera);
+
+static struct atmel_isi_camera *atmel_isi_grab_camera(struct atmel_isi *isi)
+{
+	struct atmel_isi_camera *entry, *cam = NULL;
+
+	mutex_lock(&camera_list_mutex);
+	list_for_each_entry(entry, &camera_list, list) {
+		/* Just grab the first camera available */
+		if (!entry->isi) {
+			if (!try_module_get(entry->owner))
+				continue;
+
+			cam = entry;
+			cam->isi = isi;
+			pr_debug("%s: got camera: %s\n",
+				 isi->vdev.name, cam->name);
+			break;
+		}
+	}
+	mutex_unlock(&camera_list_mutex);
+
+	return cam;
+}
+
+static int atmel_isi_set_camera_input(struct atmel_isi *isi)
+{
+	struct atmel_isi_camera *cam = isi->camera;
+	int ret;
+
+	ret = cam->set_format(cam, &isi->format);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+static void atmel_isi_set_default_format(struct atmel_isi *isi)
+{
+
+	isi->format.pix.width = (u32)min((u32)2048l, (u32)image_hsize);
+	isi->format.pix.height = (u32)min((u32)2048l, (u32)image_vsize);
+
+	/* Set capture format if we have explicitely specified one */
+	if (capture_v4l2_fmt)
+		isi->format.pix.pixelformat = capture_v4l2_fmt;
+	else
+		/* Codec path output format */
+		isi->format.pix.pixelformat = V4L2_PIX_FMT_YVYU;
+
+	/* The ISI module codec path tries to output YUV 4:2:2
+	 * Therefore two pixels will be in a 32bit word */
+	isi->format.pix.bytesperline = ALIGN(isi->format.pix.width * 2, 4);
+	isi->format.pix.sizeimage = isi->format.pix.bytesperline *
+		isi->format.pix.height;
+
+	pr_debug("set default format: width=%d height=%d\n",
+		isi->format.pix.width, isi->format.pix.height);
+
+#ifdef ISI_CODEC
+	isi->streaming_format.pix.width = isi->format.pix.width;
+	isi->streaming_format.pix.height = isi->format.pix.height;
+	isi->streaming_format.pix.bytesperline = isi->format.pix.bytesperline;
+	isi->streaming_format.pix.sizeimage = isi->format.pix.sizeimage;
+#else
+	isi->streaming_format.pix.width = min(640U, prev_hsize);
+	isi->streaming_format.pix.height = min(480U, prev_vsize);
+
+	/* The ISI module preview path outputs either RGB 5:5:5
+	 * or grayscale mode. Normally 2 pixels are stored in one word.
+	 * But since the grayscale mode offers the possibility to store 1 pixel
+	 * in one word we have to adjust the size here.
+	 */
+	if (input_format == ATMEL_ISI_PIXFMT_GREY
+		&& gs_mode == ISI_GS_1PIX_PER_WORD) {
+
+		isi->streaming_format.pix.bytesperline =
+			ALIGN(isi->streaming_format.pix.width * 4, 4);
+	} else {
+		isi->streaming_format.pix.bytesperline =
+			ALIGN(isi->streaming_format.pix.width * 2, 4);
+	}
+
+	isi->streaming_format.pix.sizeimage =
+		isi->streaming_format.pix.bytesperline *
+		isi->streaming_format.pix.height;
+#endif
+	/* Set streaming format if we have explicitely specified one */
+	if (streaming_v4l2_fmt) {
+		isi->streaming_format.pix.pixelformat = streaming_v4l2_fmt;
+	} else {
+		/* Preview path output format
+		 * Would be logically V4L2_PIX_FMT_BGR555X
+		 * but this format does not exist in the specification
+		 * So for now we pretend V4L2_PIX_FMT_RGB555X
+		 * Also the Greyscale format does not fit on top of the V4L2
+		 * format but for now we just return it.
+		 */
+		if (input_format == ATMEL_ISI_PIXFMT_GREY)
+			isi->streaming_format.pix.pixelformat = V4L2_PIX_FMT_GREY;
+		else
+			isi->streaming_format.pix.pixelformat = V4L2_PIX_FMT_RGB555X;
+	}
+
+	if (input_format) {
+		isi->format.input_format = input_format;
+		/* Not needed but for completeness*/
+		isi->streaming_format.input_format = input_format;
+	}
+
+}
+
+static int atmel_isi_init_hardware(struct atmel_isi *isi)
+{
+	u32 cfg2, cfg1, cr, ctrl;
+
+	cr = 0;
+	switch (isi->format.input_format) {
+	case ATMEL_ISI_PIXFMT_GREY:
+		cr = ISI_BIT(GRAYSCALE);
+		break;
+	case ATMEL_ISI_PIXFMT_YCrYCb:
+		cr = ISI_BF(V2_YCC_SWAP, 0);
+		break;
+	case ATMEL_ISI_PIXFMT_YCbYCr:
+		cr = ISI_BF(V2_YCC_SWAP, 1);
+		break;
+	case ATMEL_ISI_PIXFMT_CrYCbY:
+		cr = ISI_BF(V2_YCC_SWAP, 2);
+		break;
+	case ATMEL_ISI_PIXFMT_CbYCrY:
+		cr = ISI_BF(YCC_SWAP, 3);
+		break;
+	case ATMEL_ISI_PIXFMT_RGB24:
+		cr = ISI_BIT(V2_COL_SPACE) | ISI_BF(V2_RGB_CFG, 0);
+		break;
+	case ATMEL_ISI_PIXFMT_BGR24:
+		cr = ISI_BIT(V2_COL_SPACE) | ISI_BF(V2_RGB_CFG, 1);
+		break;
+	case ATMEL_ISI_PIXFMT_RGB16:
+		cr = (ISI_BIT(V2_COL_SPACE) | ISI_BIT(V2_RGB_MODE)
+		       | ISI_BF(V2_RGB_CFG, 0));
+		break;
+	case ATMEL_ISI_PIXFMT_BGR16:
+		cr = (ISI_BIT(V2_COL_SPACE) | ISI_BIT(V2_RGB_MODE)
+		       | ISI_BF(V2_RGB_CFG, 1));
+		break;
+	case ATMEL_ISI_PIXFMT_GRB16:
+		cr = (ISI_BIT(V2_COL_SPACE) | ISI_BIT(V2_RGB_MODE)
+		       | ISI_BF(V2_RGB_CFG, 2));
+		break;
+	case ATMEL_ISI_PIXFMT_GBR16:
+		cr = (ISI_BIT(V2_COL_SPACE) | ISI_BIT(V2_RGB_MODE)
+		       | ISI_BF(V2_RGB_CFG, 3));
+		break;
+	case ATMEL_ISI_PIXFMT_RGB24_REV:
+		cr = (ISI_BIT(V2_COL_SPACE) | ISI_BIT(V2_RGB_SWAP)
+		       | ISI_BF(V2_RGB_CFG, 0));
+		break;
+	case ATMEL_ISI_PIXFMT_BGR24_REV:
+		cr = (ISI_BIT(V2_COL_SPACE) | ISI_BIT(V2_RGB_SWAP)
+		       | ISI_BF(V2_RGB_CFG, 1));
+		break;
+	case ATMEL_ISI_PIXFMT_RGB16_REV:
+		cr = (ISI_BIT(V2_COL_SPACE) | ISI_BIT(V2_RGB_SWAP)
+		       | ISI_BIT(V2_RGB_MODE) | ISI_BF(V2_RGB_CFG, 0));
+		break;
+	case ATMEL_ISI_PIXFMT_BGR16_REV:
+		cr = (ISI_BIT(V2_COL_SPACE) | ISI_BIT(V2_RGB_SWAP)
+		       | ISI_BIT(V2_RGB_MODE) | ISI_BF(V2_RGB_CFG, 1));
+		break;
+	case ATMEL_ISI_PIXFMT_GRB16_REV:
+		cr = (ISI_BIT(V2_COL_SPACE) | ISI_BIT(V2_RGB_SWAP)
+		       | ISI_BIT(V2_RGB_MODE) | ISI_BF(V2_RGB_CFG, 2));
+		break;
+	case ATMEL_ISI_PIXFMT_GBR16_REV:
+		cr = (ISI_BIT(V2_COL_SPACE) | ISI_BIT(V2_RGB_SWAP)
+		       | ISI_BIT(V2_RGB_MODE) | ISI_BF(V2_RGB_CFG, 3));
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	cfg1 = ISI_BF(V2_EMB_SYNC, (has_emb_sync))
+		| ISI_BF(V2_HSYNC_POL, hsync_act_low)
+		| ISI_BF(V2_VSYNC_POL, vsync_act_low)
+		| ISI_BF(V2_PIXCLK_POL, pclk_act_falling)
+		| ISI_BF(V2_FULL, isi_full_mode);
+
+	ctrl = ISI_BIT(DIS);
+
+	isi_writel(isi, V2_CFG1, cfg1);
+	isi_writel(isi, V2_CTRL, ctrl);
+	/* Check if module properly disable */
+	while (isi_readl(isi, V2_STATUS) & ISI_BIT(V2_DIS_DONE))
+		msleep(1);
+
+#ifndef ISI_CODEC
+	/* These values depend on the sensor output image size */
+	isi_writel(isi, V2_PDECF, prev_decimation_factor);/* 1/16 * 16 = 1*/
+	isi_writel(isi, V2_PSIZE , ISI_BF(V2_PREV_HSIZE, prev_hsize - 1)
+		| ISI_BF(V2_PREV_VSIZE, prev_vsize - 1));
+#endif
+	cfg2 = isi_readl(isi, V2_CFG2);
+	cfg2 |= cr;
+	cfg2 = ISI_BFINS(V2_IM_VSIZE, isi->format.pix.height - 1, cfg2);
+	cfg2 = ISI_BFINS(V2_IM_HSIZE, isi->format.pix.width - 1, cfg2);
+
+	isi_writel(isi, V2_CFG2, cfg2);
+
+	pr_debug("set_format:\n cfg1=0x%08x\n cfg2=0x%08x\n",
+		 isi_readl(isi, V2_CFG1), isi_readl(isi, V2_CFG2));
+	pr_debug("psize=0x%08x\n", isi_readl(isi, V2_PSIZE));
+
+	return 0;
+}
+
+static int atmel_isi_start_capture(struct atmel_isi *isi)
+{
+	u32 cr;
+	u32 sr = 0;
+	int ret;
+
+	spin_lock_irq(&isi->lock);
+	isi->state = STATE_IDLE;
+
+	sr = isi_readl(isi, V2_STATUS); /* clear any pending SOF interrupt */
+	isi_writel(isi, V2_INTEN, ISI_BIT(V2_VSYNC)); /* <=> SOF in previous ISI */
+	isi_writel(isi, V2_CTRL, isi_readl(isi, V2_CTRL) | ISI_BIT(V2_EN));
+
+	spin_unlock_irq(&isi->lock);
+
+	pr_debug("isi: waiting for SOF\n");
+
+	ret = wait_event_interruptible(isi->capture_wq,
+				       isi->state != STATE_IDLE);
+	if (ret)
+		return ret;
+
+	if (isi->state != STATE_CAPTURE_READY)
+		return -EIO;
+
+	/*
+	 * Do a codec request. Next SOF indicates start of capture,
+	 * the one after that indicates end of capture.
+	 */
+	pr_debug("isi: starting capture\n");
+
+	/* Enable */
+	isi_writel(isi, V2_DMA_CHER, ISI_BIT(V2_DMA_C_CH_EN));
+	isi_writel(isi, V2_DMA_C_ADDR, isi->capture_phys);
+
+	spin_lock_irq(&isi->lock);
+	isi->state = STATE_CAPTURE_WAIT_SOF;
+	/* Check if already in a frame */
+	while (isi_readl(isi, V2_STATUS) & ISI_BIT(V2_CDC))
+		msleep(1);
+	cr = isi_readl(isi, V2_CTRL);
+	cr |= ISI_BIT(V2_CDC);
+	isi_writel(isi, V2_CTRL, cr);
+	isi_writel(isi, V2_INTEN, ISI_V2_CAPTURE_MASK);
+
+	spin_unlock_irq(&isi->lock);
+
+	return 0;
+}
+
+static void atmel_isi_capture_done(struct atmel_isi *isi,
+				   int state)
+{
+	u32 cr;
+
+	cr = isi_readl(isi, V2_CTRL);
+	cr &= ~ISI_BIT(V2_CDC);
+	isi_writel(isi, V2_CTRL, cr);
+
+	isi->state = state;
+	wake_up_interruptible(&isi->capture_wq);
+	isi_writel(isi, V2_INTDIS, ISI_V2_CAPTURE_MASK);
+}
+
+static irqreturn_t atmel_isi_handle_streaming(struct atmel_isi *isi,
+							int sequence)
+{
+	return IRQ_HANDLED;
+}
+
+/* isi interrupt service routine */
+static irqreturn_t isi_interrupt(int irq, void *dev_id)
+{
+	struct atmel_isi *isi = dev_id;
+	u32 status, mask, pending;
+	irqreturn_t ret = IRQ_NONE;
+	static int sequence;
+
+	spin_lock(&isi->lock);
+
+	status = isi_readl(isi, V2_STATUS);
+	mask = isi_readl(isi, V2_INTMASK);
+	pending = status & mask;
+
+	if (isi->streaming) {
+		if (likely(pending & (ISI_BIT(V2_CXFR_DONE)))) {
+			sequence++;
+			ret = atmel_isi_handle_streaming(isi, sequence);
+		}
+	} else {
+		while (pending) {
+			if (pending & (ISI_BIT(V2_C_OVR) | ISI_BIT(V2_FR_OVR))) {
+				atmel_isi_capture_done(isi, STATE_CAPTURE_ERROR);
+				pr_debug("%s: FIFO overrun (status=0x%x)\n",
+					 isi->vdev.name, status);
+			} else if (pending & (ISI_BIT(V2_VSYNC) | ISI_BIT(V2_CDC))) {
+				switch (isi->state) {
+				case STATE_IDLE:
+					isi->state = STATE_CAPTURE_READY;
+					wake_up_interruptible(&isi->capture_wq);
+					break;
+				case STATE_CAPTURE_READY:
+					break;
+				case STATE_CAPTURE_WAIT_SOF:
+					isi->state = STATE_CAPTURE_IN_PROGRESS;
+					break;
+				}
+			}
+			if (pending & (ISI_BIT(V2_CXFR_DONE) | ISI_BIT(V2_PXFR_DONE))) {
+				if (isi->state == STATE_CAPTURE_IN_PROGRESS)
+					atmel_isi_capture_done(isi, STATE_CAPTURE_DONE);
+			}
+
+			if (pending & ISI_BIT(V2_SRST)) {
+				complete(&isi->reset_complete);
+				isi_writel(isi, V2_INTDIS, ISI_BIT(V2_SRST));
+			}
+
+			status = isi_readl(isi, V2_STATUS);
+			mask = isi_readl(isi, V2_INTMASK);
+			pending = status & mask;
+			ret = IRQ_HANDLED;
+		}
+	}
+	spin_unlock(&isi->lock);
+
+	return ret;
+}
+/* ------------------------------------------------------------------------
+ *  IOCTL videoc handling
+ *  ----------------------------------------------------------------------*/
+
+/* --------Capture ioctls ------------------------------------------------*/
+/* Device capabilities callback function.
+ */
+static int atmel_isi_capture_querycap(struct file *file, void *priv,
+			      struct v4l2_capability *cap)
+{
+	strcpy(cap->driver, "atmel-isi");
+	strcpy(cap->card, "Atmel Image Sensor Interface");
+	cap->version = ATMEL_ISI_VERSION;
+	/* V4L2_CAP_VIDEO_CAPTURE -> This is a capture device
+	 * V4L2_CAP_READWRITE -> read/write interface used
+	 */
+	cap->capabilities = (V4L2_CAP_VIDEO_CAPTURE
+			     | V4L2_CAP_READWRITE
+			     );
+	return 0;
+}
+
+/*  Input enumeration callback function.
+ *  Enumerates available input devices.
+ *  This can be called many times from the V4L2-layer by
+ *  incrementing the index to get all avaliable input devices.
+ */
+static int atmel_isi_capture_enum_input(struct file *file, void *priv,
+				struct v4l2_input *input)
+{
+	struct atmel_isi_fh *fh = priv;
+	struct atmel_isi *isi = fh->isi;
+
+	/* Just one input (ISI) is available */
+	if (input->index != 0)
+		return -EINVAL;
+
+	/* Set input name as camera name */
+	strlcpy(input->name, isi->camera->name, sizeof(input->name));
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+
+	/* Set to this value just because this should be set to a
+	 * defined value
+	 */
+	input->std = V4L2_STD_PAL;
+
+	return 0;
+}
+/* Selects an input device.
+ *  One input device (ISI) currently supported.
+ */
+static int atmel_isi_capture_s_input(struct file *file, void *priv,
+			     unsigned int index)
+{
+	if (index != 0)
+		return -EINVAL;
+	return 0;
+}
+
+/* Gets current input device.
+ */
+static int atmel_isi_capture_g_input(struct file *file, void *priv,
+			     unsigned int *index)
+{
+	*index = 0;
+	return 0;
+}
+
+/* Format callback function
+ * Returns a v4l2_fmtdesc structure with according values to a
+ * index.
+ * This function is called from user space until it returns
+ * -EINVAL.
+ */
+static int atmel_isi_capture_enum_fmt_cap(struct file *file, void *priv,
+				  struct v4l2_fmtdesc *fmt)
+{
+	if (fmt->index != 0)
+		return -EINVAL;
+
+	/* if we want to pretend another ISI output
+	 * this is usefull if we input an other input format from a camera
+	 * than specified in the ISI -> makes it possible to swap bytes
+	 * in the ISI output format but messes up the preview path output
+	 */
+	if (capture_v4l2_fmt) {
+		fmt->pixelformat = capture_v4l2_fmt;
+	} else {
+		/* This is the format the ISI tries to output */
+		strcpy(fmt->description, "YCbYCr (YUYV) 4:2:2");
+		fmt->pixelformat = V4L2_PIX_FMT_YUYV;
+	}
+
+	return 0;
+}
+
+static int atmel_isi_capture_try_fmt_cap(struct file *file, void *priv,
+			struct v4l2_format *vfmt)
+{
+	struct atmel_isi_fh *fh = priv;
+	struct atmel_isi *isi = fh->isi;
+	/* Just return the current format for now */
+	memcpy(&vfmt->fmt.pix, &isi->format.pix,
+		sizeof(struct v4l2_pix_format));
+
+	return 0;
+}
+
+/* Gets current hardware configuration
+ *  For capture devices the pixel format settings are
+ *  important.
+ */
+static int atmel_isi_capture_g_fmt_cap(struct file *file, void *priv,
+			       struct v4l2_format *vfmt)
+{
+	struct atmel_isi_fh *fh = priv;
+	struct atmel_isi *isi = fh->isi;
+
+	/* Return current pixel format */
+	memcpy(&vfmt->fmt.pix, &isi->format.pix,
+	       sizeof(struct v4l2_pix_format));
+
+	return 0;
+}
+
+static int atmel_isi_capture_s_fmt_cap(struct file *file, void *priv,
+			       struct v4l2_format *vfmt)
+{
+	struct atmel_isi_fh *fh = priv;
+	struct atmel_isi *isi = fh->isi;
+	struct atmel_isi_camera *cam = isi->camera;
+	struct atmel_isi_format *tmp;
+	int ret = 0;
+
+	/* We have a fixed format so just copy the current format
+	 * back
+	 */
+	memcpy(&vfmt->fmt.pix, &isi->format.pix,
+		sizeof(struct v4l2_pix_format));
+
+	return ret;
+}
+
+/* ------------ Preview path ioctls ------------------------------*/
+/* Device capabilities callback function.
+ */
+static int atmel_isi_streaming_querycap(struct file *file, void *priv,
+			      struct v4l2_capability *cap)
+{
+	strcpy(cap->driver, "atmel-isi");
+	strcpy(cap->card, "Atmel Image Sensor Interface");
+	cap->version = ATMEL_ISI_VERSION;
+	/* V4L2_CAP_VIDEO_CAPTURE -> This is a capture device
+	 * V4L2_CAP_READWRITE -> read/write interface used
+	 * V4L2_CAP_STREAMING -> ioctl + mmap interface used
+	 */
+	cap->capabilities = (V4L2_CAP_VIDEO_CAPTURE
+			     | V4L2_CAP_READWRITE
+			     | V4L2_CAP_STREAMING
+			     );
+	return 0;
+}
+/* Input enumeration callback function.
+ *  Enumerates available input devices.
+ *  This can be called many times from the V4L2-layer by
+ *  incrementing the index to get all avaliable input devices.
+ */
+static int atmel_isi_streaming_enum_input(struct file *file, void *priv,
+				struct v4l2_input *input)
+{
+	struct atmel_isi_fh *fh = priv;
+	struct atmel_isi *isi = fh->isi;
+
+	/* Just one input (ISI) is available */
+	if (input->index != 0)
+		return -EINVAL;
+
+	/* Set input name as camera name */
+	strlcpy(input->name, isi->camera->name, sizeof(input->name));
+	input->type = V4L2_INPUT_TYPE_CAMERA;
+
+	/* Set to this value just because this should be set to a
+	 * defined value
+	 */
+	input->std = V4L2_STD_PAL;
+
+	return 0;
+}
+/* Selects an input device.
+ *  One input device (ISI) currently supported.
+ */
+static int atmel_isi_streaming_s_input(struct file *file, void *priv,
+			     unsigned int index)
+{
+	if (index != 0)
+		return -EINVAL;
+
+	return 0;
+}
+/* Gets current input device.
+ */
+static int atmel_isi_streaming_g_input(struct file *file, void *priv,
+			     unsigned int *index)
+{
+	*index = 0;
+	return 0;
+}
+static int atmel_isi_streaming_g_std(struct file *file, void *priv, v4l2_std_id *norm)
+{
+	pr_debug("atmel isi: g_std\n");
+	*norm = V4L2_STD_UNKNOWN;
+	return 0;
+}
+/* Format callback function
+ * Returns a v4l2_fmtdesc structure with according values to a
+ * index.
+ * This function is called from user space until it returns
+ * -EINVAL.
+ */
+static int atmel_isi_streaming_enum_fmt_cap(struct file *file, void *priv,
+				  struct v4l2_fmtdesc *fmt)
+{
+	struct atmel_isi_fh *fh = priv;
+	struct atmel_isi *isi = fh->isi;
+
+	if (fmt->index != 0)
+		return -EINVAL;
+
+	/* TODO: Return all possible formats
+	* This depends on ISI and camera.
+	* A enum_fmt function or a data structure should be
+	* added to the camera driver.
+	* For now just one format supported
+	*/
+	if (streaming_v4l2_fmt)
+		strcpy(fmt->description, "Pretended format");
+	else
+		strcpy(fmt->description, "Normal format");
+
+	/* The pretended and normal format are already set earlier */
+	fmt->pixelformat = isi->streaming_format.pix.pixelformat;
+
+	return 0;
+}
+static int atmel_isi_streaming_try_fmt_cap(struct file *file, void *priv,
+			struct v4l2_format *vfmt)
+{
+	struct atmel_isi_fh *fh = priv;
+	struct atmel_isi *isi = fh->isi;
+
+	/* FIXME For now we just return the current format*/
+	memcpy(&vfmt->fmt.pix, &isi->streaming_format.pix,
+		sizeof(struct v4l2_pix_format));
+	return 0;
+}
+/* Gets current hardware configuration
+ *  For capture devices the pixel format settings are
+ *  important.
+ */
+static int atmel_isi_streaming_g_fmt_cap(struct file *file, void *priv,
+			       struct v4l2_format *vfmt)
+{
+	struct atmel_isi_fh *fh = priv;
+	struct atmel_isi *isi = fh->isi;
+
+	/*Copy current pixel format structure to user space*/
+	memcpy(&vfmt->fmt.pix, &isi->streaming_format.pix,
+	       sizeof(struct v4l2_pix_format));
+
+	return 0;
+}
+static int atmel_isi_streaming_s_fmt_cap(struct file *file, void *priv,
+			       struct v4l2_format *vfmt)
+{
+	struct atmel_isi_fh *fh = priv;
+	struct atmel_isi *isi = fh->isi;
+	int ret = 0;
+
+	if (vfmt->fmt.pix.pixelformat != V4L2_PIX_FMT_YUYV) {
+		/* Just return the current format as we do not support
+		* format switching */
+		pr_debug("S_FMT: format not supported(only YUV)\n");
+		memcpy(&vfmt->fmt.pix, &isi->streaming_format.pix,
+			sizeof(struct v4l2_pix_format));
+	} else {
+		/* Set the sensor accordingly */
+		memcpy(&isi->format.pix, &vfmt->fmt.pix,
+			sizeof(struct v4l2_pix_format));
+		atmel_isi_set_camera_input(isi);
+	}
+
+	return ret;
+}
+/* Checks if control is supported in driver
+ * No controls currently supported yet
+ */
+static int atmel_isi_streaming_queryctrl(struct file *file, void *priv,
+			   struct v4l2_queryctrl *qc)
+{
+	switch (qc->id) {
+	case V4L2_CID_BRIGHTNESS:
+		strcpy(qc->name, "Brightness");
+		qc->minimum = 0;
+		qc->maximum = 100;
+		qc->step = 1;
+		qc->default_value = 50;
+		qc->flags = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+static int atmel_isi_streaming_g_ctrl(struct file *file, void *priv,
+			struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		ctrl->value = 0;
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+static int atmel_isi_streaming_s_ctrl(struct file *file, void *priv,
+			struct v4l2_control *ctrl)
+{
+	switch (ctrl->id) {
+	case V4L2_CID_BRIGHTNESS:
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+static int atmel_isi_reqbufs(struct file *file, void *private_data,
+			struct v4l2_requestbuffers *req)
+{
+	/* Only memory mapped buffers supported*/
+	if (req->memory != V4L2_MEMORY_MMAP) {
+		pr_debug("atmel_isi: buffer format not supported\n");
+		return -EINVAL;
+	}
+	pr_debug("atmel_isi: Requested %d buffers. Using %d buffers\n",
+		req->count, video_buffers);
+	/* buffer number is fixed for now as it is difficult to get
+	 * that memory at runtime */
+	req->count = video_buffers;
+	memset(&req->reserved, 0, sizeof(req->reserved));
+	return 0;
+}
+
+static int atmel_isi_querybuf(struct file *file, void *private_data,
+			struct v4l2_buffer *buf)
+{
+	struct atmel_isi_fh *fh = private_data;
+	struct atmel_isi *isi = fh->isi;
+	struct frame_buffer *buffer;
+
+	if (unlikely(buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -EINVAL;
+	if (unlikely(buf->index >= video_buffers))
+		return -EINVAL;
+
+	buffer = &(isi->video_buffer[buf->index]);
+
+	buf->type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
+	buf->length = video_buffer_size;
+	buf->memory = V4L2_MEMORY_MMAP;
+
+	/* set index as mmap reference to the buffer */
+	buf->m.offset = buf->index << PAGE_SHIFT;
+
+	switch (buffer->status) {
+	case FRAME_UNUSED:
+	case FRAME_ERROR:
+	case FRAME_QUEUED:
+		buf->flags |= V4L2_BUF_FLAG_QUEUED;
+		buf->bytesused = buffer->bytes_used;
+		break;
+	case FRAME_DONE:
+		buf->flags |= V4L2_BUF_FLAG_DONE;
+		buf->bytesused = buffer->bytes_used;
+		buf->sequence = buffer->sequence;
+		buf->timestamp = buffer->timestamp;
+		break;
+	}
+
+	buf->field = V4L2_FIELD_NONE; /* no interlacing stuff */
+
+	if (buffer->mmap_count)
+		buf->flags |= V4L2_BUF_FLAG_MAPPED;
+	else
+		buf->flags &= ~V4L2_BUF_FLAG_MAPPED;
+
+	pr_debug("atmel_isi: querybuf index:%d offset:%d\n",
+		buf->index, buf->m.offset);
+
+	return 0;
+}
+
+static int atmel_isi_capture_qbuf(struct file *file, void *private_data,
+			struct v4l2_buffer *buf)
+{
+	struct atmel_isi_fh *fh = private_data;
+	struct atmel_isi *isi = fh->isi;
+	struct frame_buffer *buffer, *next_buffer;
+	u32 old_ctrl;
+
+	if (unlikely(buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -EINVAL;
+
+	if (unlikely(buf->index >= video_buffers || buf->index < 0)) {
+		pr_debug("Buffer index is not valid index=%d\n", buf->index);
+		return -EINVAL;
+	}
+
+	if (unlikely(buf->memory != V4L2_MEMORY_MMAP)) {
+		pr_debug("Buffer is not of MEMORY_MMAP type\n");
+		return -EINVAL;
+	}
+
+	buffer = &(isi->video_buffer[isi->tail]);
+	isi->tail++;
+	if (isi->tail == (video_buffers))
+		isi->tail = 0;
+	next_buffer = &(isi->video_buffer[isi->tail]);
+
+	/* disable fetch on next buff */
+	next_buffer->fb_desc.dma_ctrl &= ~ISI_BIT(V2_DMA_FETCH);
+	buffer->fb_desc.dma_ctrl |= ISI_BIT(V2_DMA_FETCH);
+
+	/* Restart the ISI transfert if suspended */
+	old_ctrl = isi_readl(isi, V2_DMA_C_CTRL);
+	isi_writel(isi, V2_DMA_C_CTRL, ISI_BIT(V2_DMA_FETCH) | old_ctrl);
+	isi_writel(isi, V2_DMA_CHER, ISI_BIT(V2_DMA_C_CH_EN));
+
+	mutex_lock(&isi->mutex);
+	buf->flags |= V4L2_BUF_FLAG_QUEUED;
+	buf->flags &= ~V4L2_BUF_FLAG_DONE;
+	buffer->status = FRAME_QUEUED;
+
+	mutex_unlock(&isi->mutex);
+
+	return 0;
+}
+
+static int atmel_isi_stream_qbuf(struct file *file, void *private_data,
+			struct v4l2_buffer *buf)
+{
+	struct atmel_isi_fh *fh = private_data;
+	struct atmel_isi *isi = fh->isi;
+	struct frame_buffer *buffer, *next_buffer;
+	u32 old_ctrl;
+
+	if (unlikely(buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -EINVAL;
+
+	if (unlikely(buf->index >= video_buffers || buf->index < 0)) {
+		pr_debug("Buffer index is not valid index=%d\n", buf->index);
+		return -EINVAL;
+	}
+
+	if (unlikely(buf->memory != V4L2_MEMORY_MMAP)) {
+		pr_debug("Buffer is not of MEMORY_MMAP type\n");
+		return -EINVAL;
+	}
+
+	buffer = &(isi->video_buffer[isi->tail]);
+	isi->tail++;
+	if (isi->tail == (video_buffers))
+		isi->tail = 0;
+	next_buffer = &(isi->video_buffer[isi->tail]);
+
+	/* disable fetch on next buff */
+	next_buffer->fb_desc.dma_ctrl &= ~ISI_BIT(V2_DMA_FETCH);
+	buffer->fb_desc.dma_ctrl |= ISI_BIT(V2_DMA_FETCH);
+
+	/* Restart the ISI transfert if suspended */
+	old_ctrl = isi_readl(isi, V2_DMA_C_CTRL);
+	isi_writel(isi, V2_DMA_C_CTRL, ISI_BIT(V2_DMA_FETCH) | old_ctrl);
+	isi_writel(isi, V2_DMA_CHER, ISI_BIT(V2_DMA_C_CH_EN));
+
+	mutex_lock(&isi->mutex);
+	buf->flags |= V4L2_BUF_FLAG_QUEUED;
+	buf->flags &= ~V4L2_BUF_FLAG_DONE;
+	buffer->status = FRAME_QUEUED;
+
+	mutex_unlock(&isi->mutex);
+
+	return 0;
+}
+
+static int atmel_isi_dqbuf(struct file *file, void *private_data,
+			struct v4l2_buffer *buf)
+{
+	struct atmel_isi_fh *fh = private_data;
+	struct atmel_isi *isi = fh->isi;
+	struct frame_buffer *buffer;
+	static int sequence;
+
+	if (unlikely(buf->type != V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -EINVAL;
+
+	buffer = &(isi->video_buffer[isi->head]);
+	/* TEST if C_DONE == 1 ie isi transfer */
+
+	if (/*(isi->streaming == 0) && */(buffer->fb_desc.dma_ctrl & ISI_BIT(V2_DMA_DONE)) == 0) {
+		pr_debug("In dqbuf: Buffer not ready\n");
+		return -EAGAIN;
+	} else {
+		buffer->status = FRAME_DONE;
+	}
+
+	buffer->fb_desc.dma_ctrl &= ~ISI_BIT(V2_DMA_DONE) ;
+
+	if (unlikely(buffer->status == FRAME_QUEUED)) {
+		if (isi->streaming == 0)
+			return 0;
+		pr_debug("isi: error, dequeued buffer not ready\n");
+		return -EINVAL;
+	}
+
+	mutex_lock(&isi->mutex);
+	buf->index = isi->head;
+	buf->bytesused = buffer->bytes_used;
+	do_gettimeofday(&buf->timestamp);
+	buf->timestamp.tv_sec -= start_time.tv_sec;
+	buf->timestamp.tv_usec -= start_time.tv_usec;
+	buf->sequence = sequence++;
+	buf->m.offset = (isi->head) << PAGE_SHIFT;
+	buffer->status = FRAME_UNUSED;
+	buf->flags = V4L2_BUF_FLAG_MAPPED | V4L2_BUF_FLAG_DONE;
+	buf->length = video_buffer_size;
+	buf->field = V4L2_FIELD_NONE;
+	buf->memory = V4L2_MEMORY_MMAP;
+	mutex_unlock(&isi->mutex);
+
+	isi->head++;
+	if ((isi->head) == (video_buffers))
+		isi->head = 0;
+
+	return 0;
+}
+
+static int atmel_isi_streamon(struct file *file, void *private_data,
+			enum v4l2_buf_type type)
+{
+	struct atmel_isi_fh *fh = private_data;
+	struct atmel_isi *isi = fh->isi;
+	int i;
+	struct frame_buffer *buffer;
+	u32 cfg1, ctrl;
+
+	if (unlikely(type != V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -EINVAL;
+
+	/* reset ISI transfert desc */
+	for (i = 0; i < (video_buffers - 1); i++)
+		isi->video_buffer[i].fb_desc.dma_ctrl = ISI_BIT(V2_DMA_FETCH) | ISI_BIT(V2_DMA_WB);
+
+	/* ISI will stop at this point(last buffer of the queue) */
+	isi->video_buffer[i].fb_desc.dma_ctrl = ISI_BIT(V2_DMA_WB);
+
+	buffer = &(isi->video_buffer[isi->head]);
+
+	spin_lock_irq(&isi->lock);
+	isi->streaming = 1;
+
+	ctrl = isi_readl(isi, V2_CTRL);
+	cfg1 = isi_readl(isi, V2_CFG1);
+	/* Disable irq: cxfr for the codec path, pxfr for the preview path */
+	isi_writel(isi, V2_INTDIS, ISI_BIT(V2_CXFR_DONE) | ISI_BIT(V2_PXFR_DONE));
+
+	/* Enable codec path */
+	ctrl |= ISI_BIT(V2_CDC);
+	/* Check if already in a frame */
+	while (isi_readl(isi, V2_STATUS) & ISI_BIT(V2_CDC))
+		msleep(1);
+	/* Write the address of the first frame buffer in the C_ADDR reg
+	* write the address of the first descriptor(link list of buffer)
+	* in the C_DSCR reg, and enable dma channel.
+	*/
+	isi_writel(isi, V2_DMA_C_DSCR, (__pa(&(buffer->fb_desc))));
+	isi_writel(isi, V2_DMA_C_CTRL, ISI_BIT(V2_DMA_FETCH) | ISI_BIT(V2_DMA_DONE));
+	isi_writel(isi, V2_DMA_CHER, ISI_BIT(V2_DMA_C_CH_EN));
+
+	/* Enable linked list */
+	cfg1 |= ISI_BF(V2_FRATE, frame_rate_scaler) | ISI_BIT(V2_DISCR);
+
+	/* Enable ISI module*/
+	ctrl |= ISI_BIT(V2_ENABLE);
+	isi_writel(isi, V2_CTRL, ctrl);
+	isi_writel(isi, V2_CFG1, cfg1);
+
+	/* To properly set the timestamp we need to record the time at start
+	 * up*/
+	do_gettimeofday(&start_time);
+
+	/* Dump registers */
+	pr_debug("atmel_isi: Stream on\n");
+	pr_debug("cfg1 register= 0x%x\n", isi_readl(isi, V2_CFG1));
+	pr_debug("cfg2 register= 0x%x\n", isi_readl(isi, V2_CFG2));
+	pr_debug("control register= 0x%x\n", isi_readl(isi, V2_CTRL));
+	pr_debug("status register=0x%x\n", isi_readl(isi, V2_STATUS));
+	pr_debug("interrupt mask register= 0x%x\n", isi_readl(isi, V2_INTMASK));
+	pr_debug("DMA status register=0x%08x\n", isi_readl(isi, V2_DMA_CHSR));
+
+	spin_unlock_irq(&isi->lock);
+
+	if (isi->camera)
+		isi->camera->start_capture(isi->camera, &isi->format);
+
+	return 0;
+}
+
+static int atmel_isi_capture_streamon(struct file *file, void *private_data,
+			enum v4l2_buf_type type)
+{
+	struct atmel_isi_fh *fh = private_data;
+	struct atmel_isi *isi = fh->isi;
+	int i;
+	struct frame_buffer *buffer;
+	u32 cfg1, ctrl;
+
+	if (unlikely(type != V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -EINVAL;
+
+	/* reset ISI transfert desc */
+	for (i = 0; i < (video_buffers - 1); i++)
+		isi->video_buffer[i].fb_desc.dma_ctrl = ISI_BIT(V2_DMA_FETCH) | ISI_BIT(V2_DMA_WB);
+
+	/* ISI will stop at this point(last buffer of the queue) */
+	isi->video_buffer[i].fb_desc.dma_ctrl = ISI_BIT(V2_DMA_WB);
+
+	buffer = &(isi->video_buffer[isi->head]);
+
+	spin_lock_irq(&isi->lock);
+	isi->streaming = 0;
+
+	ctrl = isi_readl(isi, V2_CTRL);
+	cfg1 = isi_readl(isi, V2_CFG1);
+	/* Disable irq: cxfr for the codec path, pxfr for the preview path */
+	isi_writel(isi, V2_INTDIS, ISI_BIT(V2_CXFR_DONE) | ISI_BIT(V2_PXFR_DONE));
+
+	/* Write the address of the first frame buffer in the C_ADDR reg
+	* write the address of the first descriptor(link list of buffer)
+	* in theC_DSCR reg, and enable dma channel.
+	*/
+	isi_writel(isi, V2_DMA_C_DSCR, (__pa(&(buffer->fb_desc))));
+	isi_writel(isi, V2_DMA_C_CTRL, ISI_BIT(V2_DMA_FETCH) | ISI_BIT(V2_DMA_DONE));
+	isi_writel(isi, V2_DMA_CHER, ISI_BIT(V2_DMA_C_CH_EN));
+
+	/* Enable linked list */
+	cfg1 |= ISI_BF(V2_FRATE, frame_rate_scaler) | ISI_BIT(V2_DISCR);
+
+	/* Enable ISI module*/
+	ctrl |= ISI_BIT(V2_ENABLE);
+	isi_writel(isi, V2_CTRL, ctrl);
+	isi_writel(isi, V2_CFG1, cfg1);
+
+	/* Dump registers */
+	pr_debug("atmel_isi: Stream on\n");
+	pr_debug("cfg1 register= 0x%x\n", isi_readl(isi, V2_CFG1));
+	pr_debug("cfg2 register= 0x%x\n", isi_readl(isi, V2_CFG2));
+	pr_debug("control register= 0x%x\n", isi_readl(isi, V2_CTRL));
+	pr_debug("status register=0x%x\n", isi_readl(isi, V2_STATUS));
+	pr_debug("interrupt mask register= 0x%x\n", isi_readl(isi, V2_INTMASK));
+	pr_debug("DMA status register=0x%08x\n", isi_readl(isi, V2_DMA_CHSR));
+
+	spin_unlock_irq(&isi->lock);
+
+	if (isi->camera)
+		isi->camera->start_capture(isi->camera, &isi->format);
+
+	return 0;
+}
+
+static int atmel_isi_streamoff(struct file *file, void *private_data,
+			enum v4l2_buf_type type)
+{
+	struct atmel_isi_fh *fh = private_data;
+	struct atmel_isi *isi = fh->isi;
+	int reqnr;
+
+	if (unlikely(type != V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -EINVAL;
+
+	spin_lock_irq(&isi->lock);
+	isi->streaming = 0;
+#ifdef ISI_CODEC
+	/* Disble codec path */
+	isi_writel(isi, V2_CTRL, isi_readl(isi, V2_CTRL) & (~ISI_BIT(V2_CDC)));
+#endif
+	/* Disable interrupts */
+	isi_writel(isi, V2_INTDIS, ISI_BIT(V2_CXFR_DONE) | ISI_BIT(V2_PXFR_DONE));
+	/* Disable ISI module*/
+	isi_writel(isi, V2_CTRL, isi_readl(isi, V2_CTRL) | ISI_BIT(V2_DIS));
+
+	spin_unlock_irq(&isi->lock);
+
+	if (isi->camera)
+		isi->camera->stop_capture(isi->camera);
+
+	for (reqnr = 0;  reqnr < video_buffers; reqnr++)
+		isi->video_buffer[reqnr].status = FRAME_UNUSED;
+
+	return 0;
+}
+static int atmel_isi_g_parm(struct file *file, void *f,
+				struct v4l2_streamparm *parm)
+{
+	int err = 0;
+	if (parm->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+
+	return err;
+}
+/*----------------------------------------------------------------------------*/
+
+static int atmel_isi_init(struct atmel_isi *isi)
+{
+	unsigned long timeout;
+
+	/*
+	 * Reset the controller and wait for completion.
+	 * The reset will only succeed if we have a
+	 * pixel clock from the camera.
+	 */
+	init_completion(&isi->reset_complete);
+
+	isi_writel(isi, V2_INTEN, ISI_BIT(V2_SRST));
+	isi_writel(isi, V2_CTRL, ISI_BIT(V2_SRST));
+
+
+	timeout = wait_for_completion_timeout(&isi->reset_complete,
+		msecs_to_jiffies(100));
+	if (timeout == 0)
+		return -ETIMEDOUT;
+
+	isi_writel(isi, V2_INTDIS, ~0UL);
+
+	atmel_isi_set_default_format(isi);
+
+	/* If no camera is active try to find one*/
+	if (!isi->camera) {
+		isi->camera = atmel_isi_grab_camera(isi);
+
+		/*If a camera was found and it offers a configuration
+		 * interface we will use it.
+		 */
+		if (isi->camera && isi->camera->set_format)
+			atmel_isi_set_camera_input(isi);
+		else
+			printk(KERN_INFO "Pb no camera found!!!\n");
+
+	}
+	atmel_isi_init_hardware(isi);
+
+	return 0;
+}
+
+static int atmel_isi_capture_close(struct file *file)
+{
+	struct atmel_isi_fh *fh = file->private_data;
+	struct atmel_isi *isi = fh->isi;
+	u32 cr;
+
+	mutex_lock(&isi->mutex);
+
+	isi->capture_users--;
+	kfree(fh);
+
+	/* Stop camera and ISI  if driver has no users */
+	if (!isi->stream_users) {
+		if (isi->camera)
+			isi->camera->stop_capture(isi->camera);
+
+		spin_lock_irq(&isi->lock);
+
+		cr = isi_readl(isi, V2_CTRL);
+		cr |= ISI_BIT(V2_DIS);
+		isi_writel(isi, V2_CTRL, cr);
+
+		spin_unlock_irq(&isi->lock);
+	}
+	mutex_unlock(&isi->mutex);
+
+	return 0;
+}
+
+static int atmel_isi_capture_open(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atmel_isi *isi = container_of(vdev, struct atmel_isi, cdev);
+	struct atmel_isi_fh *fh;
+	int ret = -EBUSY;
+
+	pr_debug("%s: opened\n", vdev->name);
+
+	mutex_lock(&isi->mutex);
+
+
+	if (isi->capture_users) {
+		pr_debug("%s: open(): device busy\n", vdev->name);
+		goto out;
+	}
+
+	/* If the streaming interface has no users too we do a
+	 * init of the hardware and software configuration.
+	 */
+	if (isi->stream_users == 0) {
+		ret = atmel_isi_init(isi);
+		if (ret)
+			goto out;
+	}
+
+	ret = -ENOMEM;
+	fh = kzalloc(sizeof(struct atmel_isi_fh), GFP_KERNEL);
+	if (!fh) {
+		pr_debug("%s: open(): out of memory\n", vdev->name);
+		goto out;
+	}
+
+
+	fh->isi = isi;
+	file->private_data = fh;
+	isi->capture_users++;
+
+	ret = 0;
+
+out:
+	mutex_unlock(&isi->mutex);
+	return ret;
+}
+
+static ssize_t atmel_isi_capture_read(struct file *file, char __user *data,
+			      size_t count, loff_t *ppos)
+{
+	struct atmel_isi_fh *fh = file->private_data;
+	struct atmel_isi *isi = fh->isi;
+	int state;
+	int ret;
+
+	state = STATE_IDLE;
+
+	pr_debug("isi: read %zu bytes read_off=%u state=%u sizeimage=%u\n",
+		count, fh->read_off, state, isi->format.pix.sizeimage);
+
+	if (isi->camera)
+		isi->camera->start_capture(isi->camera, &isi->format);
+
+	atmel_isi_start_capture(isi);
+
+	ret = wait_event_interruptible(isi->capture_wq,
+			(isi->state == STATE_CAPTURE_DONE)
+			|| (isi->state == STATE_CAPTURE_ERROR));
+
+	if (ret)
+		return ret;
+
+	if (isi->state == STATE_CAPTURE_ERROR) {
+		isi->state = STATE_IDLE;
+		return -EIO;
+	}
+
+	fh->read_off = 0;
+
+	count = min(count, (size_t)isi->format.pix.sizeimage - fh->read_off);
+	ret = copy_to_user(data, isi->capture_buf + fh->read_off, count);
+	if (ret)
+		return -EFAULT;
+
+	fh->read_off += count;
+	if (fh->read_off >= isi->format.pix.sizeimage)
+		isi->state = STATE_IDLE;
+
+	return count;
+}
+
+static void atmel_isi_capture_release(struct video_device *vdev)
+{
+	pr_debug("%s: release\n", vdev->name);
+}
+/* ----------------- Streaming interface -------------------------------------*/
+static void atmel_isi_vm_open(struct vm_area_struct *vma)
+{
+	struct frame_buffer *buffer =
+		(struct frame_buffer *) vma->vm_private_data;
+	buffer->mmap_count++;
+	pr_debug("atmel_isi: vm_open count=%d\n", buffer->mmap_count);
+}
+
+static void atmel_isi_vm_close(struct vm_area_struct *vma)
+{
+	struct frame_buffer *buffer =
+		(struct frame_buffer *) vma->vm_private_data;
+	pr_debug("atmel_isi: vm_close count=%d\n", buffer->mmap_count);
+	buffer->mmap_count--;
+	if (buffer->mmap_count < 0)
+		printk(KERN_ERR "atmel_isi: mmap_count went negative\n");
+}
+
+
+static struct vm_operations_struct atmel_isi_vm_ops = {
+	.open = atmel_isi_vm_open,
+	.close = atmel_isi_vm_close,
+};
+
+static int atmel_isi_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	unsigned long pfn;
+	int ret;
+	struct atmel_isi_fh *fh = file->private_data;
+	struct atmel_isi *isi = fh->isi;
+	struct frame_buffer *buffer = &(isi->video_buffer[vma->vm_pgoff]);
+	unsigned long size = vma->vm_end - vma->vm_start;
+
+	pr_debug("atmel_isi: mmap called pgoff=%ld size=%ld\n",
+		vma->vm_pgoff, size);
+
+	if (size > video_buffer_size) {
+		pr_debug("atmel_isi: mmap requested buffer is to large\n");
+		return -EINVAL;
+	}
+	if (vma->vm_pgoff > video_buffers) {
+		pr_debug("atmel_isi: invalid mmap page offset\n");
+		return -EINVAL;
+	}
+	pfn = isi->video_buffer[vma->vm_pgoff].fb_desc.fb_address >> PAGE_SHIFT;
+
+	ret = remap_pfn_range(vma, vma->vm_start, pfn,
+		vma->vm_end - vma->vm_start, vma->vm_page_prot);
+	if (ret)
+		return ret;
+
+	vma->vm_ops = &atmel_isi_vm_ops;
+	vma->vm_flags |= VM_DONTEXPAND;	/* fixed size */
+	vma->vm_flags |= VM_RESERVED;	/* do not swap out */
+	vma->vm_flags |= VM_DONTCOPY;
+	vma->vm_flags |= VM_SHARED;
+	vma->vm_private_data = (void *) buffer;
+	atmel_isi_vm_open(vma);
+
+	pr_debug("atmel_isi: vma start=0x%08lx, size=%ld phys=%ld\n",
+		(unsigned long)vma->vm_start,
+		(unsigned long)vma->vm_end - (unsigned long)vma->vm_start,
+		pfn << PAGE_SHIFT);
+	return 0;
+}
+
+static int atmel_isi_stream_close(struct file *file)
+{
+	struct atmel_isi_fh *fh = file->private_data;
+	struct atmel_isi *isi = fh->isi;
+	u32 cr;
+
+	mutex_lock(&isi->mutex);
+
+	isi->stream_users--;
+	kfree(fh);
+
+	/* Stop camera and ISI if driver has no users */
+	if (!isi->capture_users) {
+		if (isi->camera)
+			isi->camera->stop_capture(isi->camera);
+
+		spin_lock_irq(&isi->lock);
+		cr = isi_readl(isi, V2_CTRL);
+		cr |= ISI_BIT(V2_DIS);
+		isi_writel(isi, V2_CTRL, cr);
+		spin_unlock_irq(&isi->lock);
+	}
+
+	mutex_unlock(&isi->mutex);
+
+	return 0;
+}
+
+static int atmel_isi_stream_open(struct file *file)
+{
+	struct video_device *vdev = video_devdata(file);
+	struct atmel_isi *isi = to_atmel_isi(vdev);
+	struct atmel_isi_fh *fh;
+	int ret = -EBUSY;
+
+	mutex_lock(&isi->mutex);
+	/* Just one user is allowed for the streaming device*/
+	if (isi->stream_users) {
+		pr_debug("%s: open(): device busy\n", vdev->name);
+		goto out;
+	}
+
+	/* If the capture interface is unused too we do a
+	 * init of hardware/software configuration
+	 */
+	if (isi->capture_users == 0) {
+		ret = atmel_isi_init(isi);
+		if (ret)
+			goto out;
+	}
+
+	ret = -ENOMEM;
+	fh = kzalloc(sizeof(struct atmel_isi_fh), GFP_KERNEL);
+	if (!fh) {
+		pr_debug("%s: open(): out of memory\n", vdev->name);
+		goto out;
+	}
+
+	fh->isi = isi;
+	file->private_data = fh;
+	isi->stream_users++;
+
+	ret = 0;
+
+out:
+	mutex_unlock(&isi->mutex);
+	return ret;
+}
+
+static void atmel_isi_stream_release(struct video_device *vdev)
+{
+	struct atmel_isi *isi = to_atmel_isi(vdev);
+	pr_debug("%s: release\n", vdev->name);
+	kfree(isi);
+}
+/* -----------------------------------------------------------------------*/
+/* Streaming v4l2 device file operations */
+static struct v4l2_file_operations atmel_isi_streaming_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= video_ioctl2,
+	.open		= atmel_isi_stream_open,
+	.release	= atmel_isi_stream_close,
+	.mmap		= atmel_isi_mmap,
+};
+/* Capture v4l2 device file operations */
+static struct v4l2_file_operations atmel_isi_capture_fops = {
+	.owner		= THIS_MODULE,
+	.open		= atmel_isi_capture_open,
+	.release	= atmel_isi_capture_close,
+	.read		= atmel_isi_capture_read,
+	.ioctl		= video_ioctl2,
+	.mmap		= atmel_isi_mmap,
+};
+
+static int __exit atmel_isi_remove(struct platform_device *pdev)
+{
+	struct atmel_isi *isi = platform_get_drvdata(pdev);
+	int i;
+
+	if (isi->camera)
+		isi->camera->stop_capture(isi->camera);
+
+	if (isi->camera)
+		atmel_isi_release_camera(isi, isi->camera);
+	video_unregister_device(&isi->cdev);
+	video_unregister_device(&isi->vdev);
+
+	platform_set_drvdata(pdev, NULL);
+
+	/* release capture buffer */
+	dma_free_coherent(&pdev->dev, capture_buffer_size,
+			  isi->capture_buf, isi->capture_phys);
+
+	/* release frame buffers */
+	for (i = 0; i < video_buffers; i++) {
+		dma_free_coherent(&pdev->dev,
+			video_buffer_size,
+			isi->video_buffer[i].frame_buffer,
+			isi->video_buffer[i].fb_desc.fb_address);
+	}
+
+	free_irq(isi->irq, isi);
+	iounmap(isi->regs);
+	clk_disable(isi->hclk);
+	clk_disable(isi->pclk);
+	clk_put(isi->hclk);
+	clk_put(isi->pclk);
+
+	/*
+	 * Don't free isi here -- it will be taken care of by the
+	 * release() callback.
+	 */
+
+	return 0;
+}
+
+
+static const struct v4l2_ioctl_ops atmel_isi_capture_ioctl_ops = {
+	.vidioc_querycap                = atmel_isi_capture_querycap,
+	.vidioc_enum_fmt_vid_cap        = atmel_isi_capture_enum_fmt_cap,
+	.vidioc_g_fmt_vid_cap           = atmel_isi_capture_g_fmt_cap,
+	.vidioc_try_fmt_vid_cap         = atmel_isi_capture_try_fmt_cap,
+	.vidioc_s_fmt_vid_cap           = atmel_isi_capture_s_fmt_cap,
+	.vidioc_reqbufs                 = atmel_isi_reqbufs,
+	.vidioc_querybuf                = atmel_isi_querybuf,
+	.vidioc_qbuf                    = atmel_isi_capture_qbuf,
+	.vidioc_dqbuf                   = atmel_isi_dqbuf,
+	.vidioc_enum_input              = atmel_isi_capture_enum_input,
+	.vidioc_g_input                 = atmel_isi_capture_g_input,
+	.vidioc_s_input                 = atmel_isi_capture_s_input,
+	.vidioc_streamon                = atmel_isi_capture_streamon,
+	.vidioc_streamoff               = atmel_isi_streamoff,
+};
+
+static struct video_device atmel_isi_capture_template = {
+	.fops         = &atmel_isi_capture_fops,
+	.minor        = -1,
+	.ioctl_ops    = &atmel_isi_capture_ioctl_ops,
+	.current_norm = V4L2_STD_PAL,
+};
+static const struct v4l2_ioctl_ops atmel_isi_streaming_ioctl_ops = {
+	.vidioc_querycap                = atmel_isi_streaming_querycap,
+	.vidioc_enum_fmt_vid_cap        = atmel_isi_streaming_enum_fmt_cap,
+	.vidioc_g_fmt_vid_cap           = atmel_isi_streaming_g_fmt_cap,
+	.vidioc_try_fmt_vid_cap         = atmel_isi_streaming_try_fmt_cap,
+	.vidioc_s_fmt_vid_cap           = atmel_isi_streaming_s_fmt_cap,
+	.vidioc_reqbufs                 = atmel_isi_reqbufs,
+	.vidioc_querybuf                = atmel_isi_querybuf,
+	.vidioc_qbuf                    = atmel_isi_stream_qbuf,
+	.vidioc_dqbuf                   = atmel_isi_dqbuf,
+	.vidioc_enum_input              = atmel_isi_streaming_enum_input,
+	.vidioc_g_input                 = atmel_isi_streaming_g_input,
+	.vidioc_s_input                 = atmel_isi_streaming_s_input,
+	.vidioc_g_std			= atmel_isi_streaming_g_std,
+	.vidioc_queryctrl               = atmel_isi_streaming_queryctrl,
+	.vidioc_g_ctrl                  = atmel_isi_streaming_g_ctrl,
+	.vidioc_s_ctrl                  = atmel_isi_streaming_s_ctrl,
+	.vidioc_streamon                = atmel_isi_streamon,
+	.vidioc_streamoff               = atmel_isi_streamoff,
+	.vidioc_g_parm                  = atmel_isi_g_parm,
+};
+
+static struct video_device atmel_isi_streaming_template = {
+	.fops         = &atmel_isi_streaming_fops,
+	.minor        = -1,
+	.ioctl_ops    = &atmel_isi_streaming_ioctl_ops,
+	.current_norm = V4L2_STD_PAL,
+};
+
+static int __init atmel_isi_probe(struct platform_device *pdev)
+{
+	unsigned int irq;
+	struct atmel_isi *isi;
+	struct clk *pclk;
+	struct resource *regs;
+	int ret;
+	int i;
+	int video_bytes_used = video_buffer_size;
+	struct device *dev = &pdev->dev;
+	struct isi_platform_data *pdata;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!regs)
+		return -ENXIO;
+
+	pclk = clk_get(&pdev->dev, "isi_clk");
+	if (IS_ERR(pclk))
+		return PTR_ERR(pclk);
+
+	clk_enable(pclk);
+
+	isi = kzalloc(sizeof(struct atmel_isi), GFP_KERNEL);
+	if (!isi) {
+		ret = -ENOMEM;
+		dev_err(&pdev->dev, "can't allocate interface!\n");
+		goto err_alloc_isi;
+	}
+
+	isi->pclk = pclk;
+
+	spin_lock_init(&isi->lock);
+	mutex_init(&isi->mutex);
+	init_waitqueue_head(&isi->capture_wq);
+
+	/* Initialize v4l2 capture device */
+	isi->cdev = atmel_isi_capture_template;
+	isi->cdev.release = atmel_isi_capture_release;
+	strcpy(isi->cdev.name, "atmel_isi_capture");
+#ifdef DEBUG
+	isi->cdev.debug = V4L2_DEBUG_IOCTL | V4L2_DEBUG_IOCTL_ARG;
+#endif
+	/* Initialize v4l2 streaming device */
+	isi->vdev = atmel_isi_streaming_template;
+	isi->vdev.release = atmel_isi_stream_release;
+	strcpy(isi->vdev.name, "atmel_isi_streaming");
+#ifdef DEBUG
+	isi->vdev.debug = V4L2_DEBUG_IOCTL | V4L2_DEBUG_IOCTL_ARG;
+#endif
+	isi->regs = ioremap(regs->start, regs->end - regs->start + 1);
+	if (!isi->regs) {
+		ret = -ENOMEM;
+		goto err_ioremap;
+	}
+
+	if (dev->platform_data) {
+		pdata = (struct isi_platform_data *) dev->platform_data;
+		dev_info(&pdev->dev, "Reading configuration\n");
+		image_hsize = pdata->image_hsize;
+		image_vsize = pdata->image_vsize;
+
+		if (pdata->prev_hsize)
+			prev_hsize = pdata->prev_hsize;
+		if (pdata->prev_vsize)
+			prev_vsize = pdata->prev_vsize;
+		gs_mode = pdata->gs_mode;
+		if (pdata->pixfmt)
+			input_format = pdata->pixfmt;
+		else
+			input_format = ATMEL_ISI_PIXFMT_YCbYCr;
+
+		frame_rate_scaler = pdata->frate;
+		if (pdata->capture_v4l2_fmt)
+			capture_v4l2_fmt = pdata->capture_v4l2_fmt;
+		if (pdata->streaming_v4l2_fmt)
+			streaming_v4l2_fmt = pdata->streaming_v4l2_fmt;
+		if (pdata->cr1_flags & ISI_HSYNC_ACT_LOW)
+			hsync_act_low = 1;
+		if (pdata->cr1_flags & ISI_VSYNC_ACT_LOW)
+			vsync_act_low = 1;
+		if (pdata->cr1_flags & ISI_PXCLK_ACT_FALLING)
+			pclk_act_falling = 1;
+		if (pdata->cr1_flags & ISI_EMB_SYNC)
+			has_emb_sync = 1;
+		if (pdata->cr1_flags & ISI_CRC_SYNC)
+			emb_crc_sync = 1;
+		if (pdata->cr1_flags & ISI_FULL)
+			isi_full_mode = 1;
+	} else {
+		dev_info(&pdev->dev, "No config available using default values\n");
+	}
+
+	/* Only grayscale mode with gs_mode=1 uses 4 bytes for one
+	 * pixel. Oll other modes use 2 bytes per pixel.*/
+	if (gs_mode)
+		video_buffer_size = prev_hsize * prev_vsize * 4;
+	else
+		video_buffer_size = prev_hsize * prev_vsize * 2;
+
+	video_bytes_used = video_buffer_size;
+
+	/* Round up buffer sizes to the next page if needed */
+	video_buffer_size = PAGE_ALIGN(video_buffer_size);
+	capture_buffer_size = PAGE_ALIGN(capture_buffer_size);
+
+	isi_writel(isi, V2_CTRL, ISI_BIT(V2_DIS));
+	/* Check if module disable */
+	while (isi_readl(isi, V2_STATUS) & ISI_BIT(V2_DIS))
+		msleep(1);
+
+	irq = platform_get_irq(pdev, 0);
+	ret = request_irq(irq, isi_interrupt, 0, "isi", isi);
+	if (ret) {
+		dev_err(&pdev->dev, "unable to request irq %d\n", irq);
+		goto err_req_irq;
+	}
+	isi->irq = irq;
+
+	/* Allocate ISI capture buffer */
+	isi->capture_buf = dma_alloc_coherent(&pdev->dev,
+					      capture_buffer_size,
+					      &isi->capture_phys,
+					      GFP_KERNEL);
+	if (!isi->capture_buf) {
+		ret = -ENOMEM;
+		dev_err(&pdev->dev, "failed to allocate capture buffer\n");
+		goto err_alloc_cbuf;
+	}
+
+	/* Allocate and initialize video buffers */
+	for (i = 0; i < video_buffers; i++) {
+		memset(&isi->video_buffer[i], 0, sizeof(struct frame_buffer));
+		isi->video_buffer[i].frame_buffer =
+			dma_alloc_coherent(&pdev->dev,
+				video_buffer_size,
+				(dma_addr_t *)
+				&(isi->video_buffer[i].fb_desc.fb_address),
+				GFP_KERNEL);
+		if (!isi->video_buffer[i].frame_buffer) {
+			ret = -ENOMEM;
+			dev_err(&pdev->dev,
+				"failed to allocate video buffer\n");
+			goto err_alloc_vbuf;
+		}
+
+		isi->video_buffer[i].bytes_used = video_bytes_used;
+		isi->video_buffer[i].status = FRAME_UNUSED;
+		isi->video_buffer[i].index = i;
+
+	}
+	isi->fbd_list_start = __pa(&isi->video_buffer[0].fb_desc);
+	for (i = 0; i < (video_buffers - 1); i++) {
+		isi->video_buffer[i].fb_desc.next_fbd_address =
+			__pa(&isi->video_buffer[i+1].fb_desc);
+
+		/* Put some color into the buffers */
+		memset(isi->video_buffer[i].frame_buffer, (i*4)%0xFF,
+			video_buffer_size);
+	}
+
+	/* FIXME
+	 * isi->video_buffer[i].fb_desc.next_fbd_address =
+	 *	isi->fbd_list_start;
+	 */
+	isi->video_buffer[i].fb_desc.next_fbd_address = __pa(&isi->video_buffer[0].fb_desc);
+
+	/* Set head & tail of the TD */
+	isi->head = 0;
+	isi->tail = video_buffers - 1;
+
+	for (i = 0; i < video_buffers; i++) {
+		dev_info(&pdev->dev, "video buffer: %d bytes at %p (phys %08lx)\n",
+		video_buffer_size,
+		isi->video_buffer[i].frame_buffer,
+		(unsigned long) isi->video_buffer[i].fb_desc.fb_address);
+	}
+
+	dev_info(&pdev->dev,
+		 "capture buffer: %d bytes at %p (phys 0x%08x)\n",
+		 capture_buffer_size, isi->capture_buf,
+		 isi->capture_phys);
+
+	ret = video_register_device(&isi->cdev, VFL_TYPE_GRABBER, video_nr);
+	if (ret) {
+		dev_err(&pdev->dev, "Registering capturing device failed\n");
+		video_device_release(&isi->cdev);
+		kfree(dev);
+		printk(KERN_INFO "failed to register capture\n");
+		goto err_register1;
+	}
+
+	ret = video_register_device(&isi->vdev, VFL_TYPE_GRABBER, video_nr);
+	if (ret) {
+		dev_err(&pdev->dev, "Registering streaming device failed\n");
+		video_device_release(&isi->vdev);
+		kfree(dev);
+		printk(KERN_INFO "failed to register streaming\n");
+		goto err_register2;
+	}
+	platform_set_drvdata(pdev, isi);
+
+	dev_info(&pdev->dev, "Atmel ISI V4L2 device at 0x%08lx\n",
+		 (unsigned long)regs->start);
+
+	return 0;
+
+err_register2:
+	video_unregister_device(&isi->cdev);
+err_register1:
+err_alloc_vbuf:
+	while (i--)
+		dma_free_coherent(&pdev->dev, video_buffer_size,
+				isi->video_buffer[i].frame_buffer,
+				isi->video_buffer[i].fb_desc.fb_address);
+	dma_free_coherent(&pdev->dev, capture_buffer_size,
+				isi->capture_buf,
+				isi->capture_phys);
+err_alloc_cbuf:
+	free_irq(isi->irq, isi);
+err_req_irq:
+	iounmap(isi->regs);
+err_ioremap:
+	kfree(isi);
+err_alloc_isi:
+	clk_disable(pclk);
+
+	return ret;
+
+}
+
+static struct platform_driver atmel_isi_driver = {
+	.probe		= atmel_isi_probe,
+	.remove		= __exit_p(atmel_isi_remove),
+	.driver		= {
+		.name = "atmel_isi",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init atmel_isi_init_module(void)
+{
+	return  platform_driver_probe(&atmel_isi_driver, &atmel_isi_probe);
+}
+
+
+static void __exit atmel_isi_exit(void)
+{
+	platform_driver_unregister(&atmel_isi_driver);
+}
+
+
+module_init(atmel_isi_init_module);
+module_exit(atmel_isi_exit);
+
+MODULE_AUTHOR("Lars Haring <lharing@atmel.com>");
+MODULE_DESCRIPTION("The V4L2 driver for atmel Linux");
+MODULE_LICENSE("GPL");
+MODULE_SUPPORTED_DEVICE("video");
Index: linux-2.6.35/drivers/mtd/devices/m25p80.c
===================================================================
--- linux-2.6.35/drivers/mtd/devices/m25p80.c	(revision 149)
+++ linux-2.6.35/drivers/mtd/devices/m25p80.c	(revision 150)
@@ -632,12 +632,13 @@
 	{ "at25fs040",  INFO(0x1f6604, 0, 64 * 1024,   8, SECT_4K) },
 
 	{ "at25df041a", INFO(0x1f4401, 0, 64 * 1024,   8, SECT_4K) },
+	{ "at25df321",  INFO(0x1f4701, 0, 64 * 1024,  64, SECT_4K) },
 	{ "at25df641",  INFO(0x1f4800, 0, 64 * 1024, 128, SECT_4K) },
 
 	{ "at26f004",   INFO(0x1f0400, 0, 64 * 1024,  8, SECT_4K) },
 	{ "at26df081a", INFO(0x1f4501, 0, 64 * 1024, 16, SECT_4K) },
 	{ "at26df161a", INFO(0x1f4601, 0, 64 * 1024, 32, SECT_4K) },
-	{ "at26df321",  INFO(0x1f4701, 0, 64 * 1024, 64, SECT_4K) },
+	{ "at26df321",  INFO(0x1f4700, 0, 64 * 1024, 64, SECT_4K) },
 
 	/* Macronix */
 	{ "mx25l4005a",  INFO(0xc22013, 0, 64 * 1024,   8, SECT_4K) },
Index: linux-2.6.35/drivers/mtd/nand/Kconfig
===================================================================
--- linux-2.6.35/drivers/mtd/nand/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/mtd/nand/Kconfig	(revision 150)
@@ -372,6 +372,23 @@
 
 	  If unsure, say Y
 
+config MTD_NAND_ATMEL_PMECC_HW
+	bool "Programmable Hardware ECC (BCH code)"
+	depends on ARCH_AT91SAM9X5
+	help
+	  Use Programmable Hardware ECC controller.
+
+	  The PMECC Controller is a programmable binary BCH (Bose, Chaudhuri
+	  and Hocquenghem) encoder/decoder. This controller can be used to
+	  generate redundancy information for both SLC and MLC NAND Flash
+	  devices.
+
+	  NB : hardware and software ECC schemes are incompatible.
+	  If you switch from one to another, you'll have to erase your
+	  mtd partition.
+
+	  If unsure, say Y
+
 config MTD_NAND_ATMEL_ECC_SOFT
 	bool "Software ECC"
 	help
Index: linux-2.6.35/drivers/mtd/nand/atmel_nand.c
===================================================================
--- linux-2.6.35/drivers/mtd/nand/atmel_nand.c	(revision 149)
+++ linux-2.6.35/drivers/mtd/nand/atmel_nand.c	(revision 150)
@@ -15,6 +15,8 @@
  *     		(u-boot-1.1.5/board/atmel/at91sam9263ek/nand.c)
  *     (C) Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
  *
+ *  Add PMECC support for AT91SAM9X5 Series
+ *     (C) Copyright 2011 ATMEL, Hong Xu
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
@@ -36,8 +38,10 @@
 #include <mach/board.h>
 #include <mach/cpu.h>
 
-#ifdef CONFIG_MTD_NAND_ATMEL_ECC_HW
+#if defined(CONFIG_MTD_NAND_ATMEL_ECC_HW)
 #define hard_ecc	1
+#elif defined(CONFIG_MTD_NAND_ATMEL_PMECC_HW)
+#define hard_ecc	1
 #else
 #define hard_ecc	0
 #endif
@@ -48,6 +52,11 @@
 #define no_ecc		0
 #endif
 
+static int use_dma = 1;
+module_param(use_dma, int, 0);
+
+#define NB_ERROR_MAX  25
+
 static int on_flash_bbt = 0;
 module_param(on_flash_bbt, int, 0);
 
@@ -57,8 +66,38 @@
 #define ecc_writel(add, reg, value)			\
 	__raw_writel((value), add + ATMEL_ECC_##reg)
 
-#include "atmel_nand_ecc.h"	/* Hardware ECC registers */
+/* Register access macros for PMECC */
+#define pmecc_readl(addr, reg) \
+	__raw_readl((addr) + ATMEL_PMECC_##reg)
 
+#define pmecc_writel(addr, reg, value) \
+	__raw_writel((value), (addr) + ATMEL_PMECC_##reg)
+
+#define pmecc_readb_ecc(addr, sector, n) \
+	__raw_readb((addr) + ATMEL_PMECC_ECCx + ((sector) * 0x40) + (n))
+
+#define pmecc_readl_rem(addr, sector, n) \
+	__raw_readl((addr) + ATMEL_PMECC_REMx + ((sector) * 0x40) + (n))
+
+#define pmerrloc_readl(addr, reg) \
+	__raw_readl((addr) + ATMEL_PMERRLOC_##reg)
+
+#define pmerrloc_writel(addr, reg, value) \
+	__raw_writel((value), (addr) + ATMEL_PMERRLOC_##reg)
+
+#define pmerrloc_writel_sigma(addr, n, value) \
+	__raw_writel((value), (addr) + ATMEL_PMERRLOC_SIGMAx + ((n) * 4))
+
+#define pmerrloc_readl_sigma(addr, n) \
+	__raw_readl((addr) + ATMEL_PMERRLOC_SIGMAx + ((n) * 4))
+
+#define pmerrloc_readl_el(addr, n) \
+	__raw_readl((addr) + ATMEL_PMERRLOC_ELx + ((n) * 4))
+
+/* Include Hardware ECC registers */
+#include "atmel_nand_ecc.h"
+
+#if defined(CONFIG_MTD_NAND_ATMEL_ECC_HW)
 /* oob layout for large page size
  * bad block info is on bytes 0 and 1
  * the bytes have to be consecutives to avoid
@@ -84,16 +123,60 @@
 		{6, 10}
 	},
 };
+#endif
 
 struct atmel_nand_host {
 	struct nand_chip	nand_chip;
 	struct mtd_info		mtd;
 	void __iomem		*io_base;
+	dma_addr_t		io_phys;
 	struct atmel_nand_data	*board;
 	struct device		*dev;
 	void __iomem		*ecc;
+
+	struct completion	comp;
+	struct dma_chan		*dma_chan;
+
+#if defined(CONFIG_MTD_NAND_ATMEL_PMECC_HW)
+	void __iomem		*pmerrloc_base;
+	void __iomem		*rom_base;
+	/* defines the error correcting capability */
+	int tt;
+	/* The number of ecc bytes for one sector */
+	int ecc_bytes_per_sector;
+	/* degree of the remainders, GF(2**mm) */
+	int mm;
+	/* length of codeword, nn=2**mm -1 */
+	int nn;
+	/* sector number per page */
+	int sector_number;
+	/* sector size in bytes */
+	int sector_size;
+
+	/* PMECC lookup table for alpha_to and index_of */
+	int16_t *alpha_to;
+	int16_t *index_of;
+
+	int16_t partial_syn[100];
+	int16_t si[100];
+	/* Sigma table */
+	int16_t smu[NB_ERROR_MAX + 2][2 * NB_ERROR_MAX + 1];
+	/** polynomal order */
+	int16_t lmu[NB_ERROR_MAX + 1];
+	uint8_t ecc_table[42 * 8];
+#endif
 };
 
+#if defined(CONFIG_MTD_NAND_ATMEL_PMECC_HW)
+#include "atmel_nand_pmecc.c"
+#endif
+
+static int cpu_has_dma(void)
+{
+	return cpu_is_at91sam9rl() || cpu_is_at91sam9g45()
+	       || cpu_is_at91sam9x5();
+}
+
 /*
  * Enable NAND.
  */
@@ -147,37 +230,142 @@
                 !!host->board->rdy_pin_active_low;
 }
 
-/*
- * Minimal-overhead PIO for data access.
- */
-static void atmel_read_buf(struct mtd_info *mtd, u8 *buf, int len)
+static void dma_complete_func(void *completion)
 {
-	struct nand_chip	*nand_chip = mtd->priv;
-
-	__raw_readsb(nand_chip->IO_ADDR_R, buf, len);
+	complete(completion);
 }
 
-static void atmel_read_buf16(struct mtd_info *mtd, u8 *buf, int len)
+static int atmel_nand_dma_op(struct mtd_info *mtd, void *buf, int len,
+			       int is_read)
 {
-	struct nand_chip	*nand_chip = mtd->priv;
+	struct dma_device *dma_dev;
+	enum dma_ctrl_flags flags;
+	dma_addr_t dma_src_addr, dma_dst_addr, phys_addr;
+	struct dma_async_tx_descriptor *tx = NULL;
+	dma_cookie_t cookie;
+	struct nand_chip *chip = mtd->priv;
+	struct atmel_nand_host *host = chip->priv;
+	void *p = buf;
+	int err = -EIO;
+	enum dma_data_direction dir = is_read ? DMA_FROM_DEVICE : DMA_TO_DEVICE;
 
-	__raw_readsw(nand_chip->IO_ADDR_R, buf, len / 2);
+	if (buf >= high_memory) {
+		struct page *pg;
+
+		if (((size_t)buf & PAGE_MASK) !=
+		    ((size_t)(buf + len - 1) & PAGE_MASK)) {
+			dev_warn(host->dev, "Buffer not fit in one page\n");
+			goto err_buf;
+		}
+
+		pg = vmalloc_to_page(buf);
+		if (pg == 0) {
+			dev_err(host->dev, "Failed to vmalloc_to_page\n");
+			goto err_buf;
+		}
+		p = page_address(pg) + ((size_t)buf & ~PAGE_MASK);
+	}
+
+	dma_dev = host->dma_chan->device;
+
+	flags = DMA_CTRL_ACK | DMA_PREP_INTERRUPT | DMA_COMPL_SKIP_SRC_UNMAP |
+		DMA_COMPL_SKIP_DEST_UNMAP;
+
+	phys_addr = dma_map_single(dma_dev->dev, p, len, dir);
+	if (dma_mapping_error(dma_dev->dev, phys_addr)) {
+		dev_err(host->dev, "Failed to dma_map_single\n");
+		goto err_buf;
+	}
+
+	if (is_read) {
+		dma_src_addr = host->io_phys;
+		dma_dst_addr = phys_addr;
+	} else {
+		dma_src_addr = phys_addr;
+		dma_dst_addr = host->io_phys;
+	}
+
+	tx = dma_dev->device_prep_dma_memcpy(host->dma_chan, dma_dst_addr,
+					     dma_src_addr, len, flags);
+	if (!tx) {
+		dev_err(host->dev, "Failed to prepare DMA memcpy\n");
+		goto err_dma;
+	}
+
+	init_completion(&host->comp);
+	tx->callback = dma_complete_func;
+	tx->callback_param = &host->comp;
+
+	cookie = tx->tx_submit(tx);
+	if (dma_submit_error(cookie)) {
+		dev_err(host->dev, "Failed to do DMA tx_submit\n");
+		goto err_dma;
+	}
+
+	dma_async_issue_pending(host->dma_chan);
+	wait_for_completion(&host->comp);
+
+	err = 0;
+
+err_dma:
+	dma_unmap_single(dma_dev->dev, phys_addr, len, dir);
+err_buf:
+	if (err != 0)
+		dev_warn(host->dev, "Fall back to CPU I/O\n");
+	return err;
 }
 
-static void atmel_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
+static void atmel_read_buf(struct mtd_info *mtd, u8 *buf, int len)
 {
-	struct nand_chip	*nand_chip = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
+	u32 align;
+	u8 *pbuf;
 
-	__raw_writesb(nand_chip->IO_ADDR_W, buf, len);
+	if (use_dma && len > mtd->oobsize)
+		if (atmel_nand_dma_op(mtd, buf, len, 1) == 0)
+			return;
+
+	/* if no DMA operation possible, use PIO */
+	pbuf = buf;
+	align = 0x03 & ((unsigned)pbuf);
+
+	if (align) {
+		u32 align_len = 4 - align;
+
+		/* non aligned buffer: re-align to next word boundary */
+		ioread8_rep(chip->IO_ADDR_R, pbuf, align_len);
+		pbuf += align_len;
+		len -= align_len;
+	}
+	memcpy((void *)pbuf, chip->IO_ADDR_R, len);
 }
 
-static void atmel_write_buf16(struct mtd_info *mtd, const u8 *buf, int len)
+static void atmel_write_buf(struct mtd_info *mtd, const u8 *buf, int len)
 {
-	struct nand_chip	*nand_chip = mtd->priv;
+	struct nand_chip *chip = mtd->priv;
+	u32 align;
+	const u8 *pbuf;
 
-	__raw_writesw(nand_chip->IO_ADDR_W, buf, len / 2);
+	if (use_dma && len > mtd->oobsize)
+		if (atmel_nand_dma_op(mtd, (void *)buf, len, 0) == 0)
+			return;
+
+	/* if no DMA operation possible, use PIO */
+	pbuf = buf;
+	align = 0x03 & ((unsigned)pbuf);
+
+	if (align) {
+		u32 align_len = 4 - align;
+
+		/* non aligned buffer: re-align to next word boundary */
+		iowrite8_rep(chip->IO_ADDR_W, pbuf, align_len);
+		pbuf += align_len;
+		len -= align_len;
+	}
+	memcpy(chip->IO_ADDR_W, (void *)pbuf, len);
 }
 
+#if defined(CONFIG_MTD_NAND_ATMEL_ECC_HW)
 /*
  * Calculate HW ECC
  *
@@ -364,6 +552,84 @@
 	}
 }
 
+static int __init atmel_nand_init_params(struct platform_device *pdev,
+					 struct atmel_nand_host *host)
+{
+	struct resource *regs;
+	struct nand_chip *nand_chip;
+	struct mtd_info *mtd;
+
+	nand_chip = &host->nand_chip;
+	mtd = &host->mtd;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!regs && hard_ecc) {
+		dev_err(host->dev, "atmel_nand: can't get I/O resource "
+				"regs\nFalling back on software ECC\n");
+	}
+
+	nand_chip->ecc.mode = NAND_ECC_SOFT;	/* enable ECC */
+	if (no_ecc)
+		nand_chip->ecc.mode = NAND_ECC_NONE;
+	if (hard_ecc && regs) {
+		host->ecc = ioremap(regs->start, regs->end - regs->start + 1);
+		if (host->ecc == NULL) {
+			printk(KERN_ERR "atmel_nand: ioremap failed\n");
+			goto err_ecc_ioremap;
+		}
+
+		nand_chip->ecc.mode = NAND_ECC_HW;
+		nand_chip->ecc.calculate = atmel_nand_calculate;
+		nand_chip->ecc.correct = atmel_nand_correct;
+		nand_chip->ecc.hwctl = atmel_nand_hwctl;
+		nand_chip->ecc.read_page = atmel_nand_read_page;
+		nand_chip->ecc.bytes = 4;
+	}
+
+	if (nand_chip->ecc.mode == NAND_ECC_HW) {
+		/* ECC is calculated for the whole page (1 step) */
+		nand_chip->ecc.size = mtd->writesize;
+
+		/* set ECC page size and oob layout */
+		switch (mtd->writesize) {
+		case 512:
+			nand_chip->ecc.layout = &atmel_oobinfo_small;
+			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_528);
+			break;
+		case 1024:
+			nand_chip->ecc.layout = &atmel_oobinfo_large;
+			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_1056);
+			break;
+		case 2048:
+			nand_chip->ecc.layout = &atmel_oobinfo_large;
+			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_2112);
+			break;
+		case 4096:
+			nand_chip->ecc.layout = &atmel_oobinfo_large;
+			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_4224);
+			break;
+		default:
+			/* page size not handled by HW ECC */
+			/* switching back to soft ECC */
+			nand_chip->ecc.mode = NAND_ECC_SOFT;
+			nand_chip->ecc.calculate = NULL;
+			nand_chip->ecc.correct = NULL;
+			nand_chip->ecc.hwctl = NULL;
+			nand_chip->ecc.read_page = NULL;
+			nand_chip->ecc.postpad = 0;
+			nand_chip->ecc.prepad = 0;
+			nand_chip->ecc.bytes = 0;
+			break;
+		}
+	}
+
+	return 0;
+
+err_ecc_ioremap:
+	return -EIO;
+}
+#endif
+
 #ifdef CONFIG_MTD_PARTITIONS
 static const char *part_probes[] = { "cmdlinepart", NULL };
 #endif
@@ -376,9 +642,8 @@
 	struct atmel_nand_host *host;
 	struct mtd_info *mtd;
 	struct nand_chip *nand_chip;
-	struct resource *regs;
 	struct resource *mem;
-	int res;
+	int res = 0;
 
 #ifdef CONFIG_MTD_PARTITIONS
 	struct mtd_partition *partitions = NULL;
@@ -398,6 +663,8 @@
 		return -ENOMEM;
 	}
 
+	host->io_phys = (dma_addr_t)mem->start;
+
 	host->io_base = ioremap(mem->start, mem->end - mem->start + 1);
 	if (host->io_base == NULL) {
 		printk(KERN_ERR "atmel_nand: ioremap failed\n");
@@ -422,41 +689,18 @@
 	if (host->board->rdy_pin)
 		nand_chip->dev_ready = atmel_nand_device_ready;
 
-	regs = platform_get_resource(pdev, IORESOURCE_MEM, 1);
-	if (!regs && hard_ecc) {
-		printk(KERN_ERR "atmel_nand: can't get I/O resource "
-				"regs\nFalling back on software ECC\n");
-	}
-
 	nand_chip->ecc.mode = NAND_ECC_SOFT;	/* enable ECC */
 	if (no_ecc)
 		nand_chip->ecc.mode = NAND_ECC_NONE;
-	if (hard_ecc && regs) {
-		host->ecc = ioremap(regs->start, regs->end - regs->start + 1);
-		if (host->ecc == NULL) {
-			printk(KERN_ERR "atmel_nand: ioremap failed\n");
-			res = -EIO;
-			goto err_ecc_ioremap;
-		}
-		nand_chip->ecc.mode = NAND_ECC_HW;
-		nand_chip->ecc.calculate = atmel_nand_calculate;
-		nand_chip->ecc.correct = atmel_nand_correct;
-		nand_chip->ecc.hwctl = atmel_nand_hwctl;
-		nand_chip->ecc.read_page = atmel_nand_read_page;
-		nand_chip->ecc.bytes = 4;
-	}
 
 	nand_chip->chip_delay = 20;		/* 20us command delay time */
 
-	if (host->board->bus_width_16) {	/* 16-bit bus width */
+	if (host->board->bus_width_16)	/* 16-bit bus width */
 		nand_chip->options |= NAND_BUSWIDTH_16;
-		nand_chip->read_buf = atmel_read_buf16;
-		nand_chip->write_buf = atmel_write_buf16;
-	} else {
-		nand_chip->read_buf = atmel_read_buf;
-		nand_chip->write_buf = atmel_write_buf;
-	}
 
+	nand_chip->read_buf = atmel_read_buf;
+	nand_chip->write_buf = atmel_write_buf;
+
 	platform_set_drvdata(pdev, host);
 	atmel_nand_enable(host);
 
@@ -473,49 +717,39 @@
 		nand_chip->options |= NAND_USE_FLASH_BBT;
 	}
 
+	if (cpu_has_dma() && use_dma) {
+		dma_cap_mask_t mask;
+
+		dma_cap_zero(mask);
+		dma_cap_set(DMA_MEMCPY, mask);
+		host->dma_chan = dma_request_channel(mask, 0, NULL);
+		if (!host->dma_chan) {
+			dev_err(host->dev, "Failed to request DMA channel\n");
+			use_dma = 0;
+		}
+	} else {
+		use_dma = 0;
+	}
+	if (use_dma)
+		dev_info(host->dev, "Using %s for DMA transfers.\n",
+					dma_chan_name(host->dma_chan));
+	else
+		dev_info(host->dev, "No DMA support for NAND access.\n");
+
 	/* first scan to find the device and get the page size */
 	if (nand_scan_ident(mtd, 1, NULL)) {
 		res = -ENXIO;
 		goto err_scan_ident;
 	}
 
-	if (nand_chip->ecc.mode == NAND_ECC_HW) {
-		/* ECC is calculated for the whole page (1 step) */
-		nand_chip->ecc.size = mtd->writesize;
+#if defined(CONFIG_MTD_NAND_ATMEL_ECC_HW)
+	res = atmel_nand_init_params(pdev, host);
+#elif defined(CONFIG_MTD_NAND_ATMEL_PMECC_HW)
+	res = atmel_pmecc_init_params(pdev, host);
+#endif
+	if (res != 0)
+		goto err;
 
-		/* set ECC page size and oob layout */
-		switch (mtd->writesize) {
-		case 512:
-			nand_chip->ecc.layout = &atmel_oobinfo_small;
-			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_528);
-			break;
-		case 1024:
-			nand_chip->ecc.layout = &atmel_oobinfo_large;
-			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_1056);
-			break;
-		case 2048:
-			nand_chip->ecc.layout = &atmel_oobinfo_large;
-			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_2112);
-			break;
-		case 4096:
-			nand_chip->ecc.layout = &atmel_oobinfo_large;
-			ecc_writel(host->ecc, MR, ATMEL_ECC_PAGESIZE_4224);
-			break;
-		default:
-			/* page size not handled by HW ECC */
-			/* switching back to soft ECC */
-			nand_chip->ecc.mode = NAND_ECC_SOFT;
-			nand_chip->ecc.calculate = NULL;
-			nand_chip->ecc.correct = NULL;
-			nand_chip->ecc.hwctl = NULL;
-			nand_chip->ecc.read_page = NULL;
-			nand_chip->ecc.postpad = 0;
-			nand_chip->ecc.prepad = 0;
-			nand_chip->ecc.bytes = 0;
-			break;
-		}
-	}
-
 	/* second phase scan */
 	if (nand_scan_tail(mtd)) {
 		res = -ENXIO;
@@ -546,6 +780,7 @@
 	if (!res)
 		return res;
 
+err:
 #ifdef CONFIG_MTD_PARTITIONS
 err_no_partitions:
 #endif
@@ -555,9 +790,8 @@
 err_no_card:
 	atmel_nand_disable(host);
 	platform_set_drvdata(pdev, NULL);
-	if (host->ecc)
-		iounmap(host->ecc);
-err_ecc_ioremap:
+	if (host->dma_chan)
+		dma_release_channel(host->dma_chan);
 	iounmap(host->io_base);
 err_nand_ioremap:
 	kfree(host);
@@ -576,8 +810,22 @@
 
 	atmel_nand_disable(host);
 
+#if defined(CONFIG_MTD_NAND_ATMEL_PMECC_HW)
+	if (cpu_has_pmecc())
+			pmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);
+	if (host->pmerrloc_base) {
+		pmerrloc_writel(host->pmerrloc_base, ELDIS, 0xffffffff);
+		iounmap(host->pmerrloc_base);
+	}
+	if (host->rom_base)
+		iounmap(host->rom_base);
+#endif
 	if (host->ecc)
 		iounmap(host->ecc);
+
+	if (host->dma_chan)
+		dma_release_channel(host->dma_chan);
+
 	iounmap(host->io_base);
 	kfree(host);
 
Index: linux-2.6.35/drivers/mtd/nand/atmel_nand_pmecc.c
===================================================================
--- linux-2.6.35/drivers/mtd/nand/atmel_nand_pmecc.c	(revision 0)
+++ linux-2.6.35/drivers/mtd/nand/atmel_nand_pmecc.c	(revision 150)
@@ -0,0 +1,674 @@
+/*
+ * (C) Copyright 2011 ATMEL, Hong Xu
+ *
+ * PMECC related definitions and routines
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+static struct nand_ecclayout pmecc_oobinfo_2048 = {
+	.eccbytes = 16,
+	.eccpos = { 48, 49, 50, 51, 52, 53, 54, 55,
+		    56, 57, 58, 59, 60, 61, 62, 63
+		  },
+	.oobfree = {
+		{2, 46},
+	},
+};
+
+static int cpu_has_pmecc(void)
+{
+	return cpu_is_at91sam9x5();
+}
+
+static int16_t *pmecc_get_alpha_to(struct atmel_nand_host *host)
+{
+	int16_t *p;
+
+	if (cpu_is_at91sam9x5()) {
+		if (host->sector_size == 512) {
+			p = (int16_t *)((u32)host->rom_base +
+				PMECC_LOOKUP_TABLE_OFFSET_512);
+			return p + PMECC_LOOKUP_TABLE_SIZE_512;
+		} else {
+			p = (int16_t *)((u32)host->rom_base +
+				PMECC_LOOKUP_TABLE_OFFSET_1024);
+			return p + PMECC_LOOKUP_TABLE_SIZE_1024;
+		}
+	}
+
+	return NULL;
+}
+
+static int16_t *pmecc_get_index_of(struct atmel_nand_host *host)
+{
+	int16_t *p = (int16_t *)host->rom_base;
+
+	if (cpu_is_at91sam9x5()) {
+		if (host->sector_size == 512)
+			p = (int16_t *)((u32)host->rom_base +
+				PMECC_LOOKUP_TABLE_OFFSET_512);
+		else
+			p = (int16_t *)((u32)host->rom_base +
+				PMECC_LOOKUP_TABLE_OFFSET_1024);
+
+		return p;
+	}
+
+	return NULL;
+}
+
+static void pmecc_gen_syndrome(struct mtd_info *mtd, int sector)
+{
+	int i;
+	uint32_t value;
+	struct nand_chip *nand_chip = mtd->priv;
+	struct atmel_nand_host *host = nand_chip->priv;
+
+	/* Fill odd syndromes */
+	for (i = 0; i < host->tt; i++) {
+		value = pmecc_readl_rem(host->ecc, sector, i / 2);
+		if (i % 2 == 0)
+			host->partial_syn[(2 * i) + 1] = value & 0xffff;
+		else
+			host->partial_syn[(2 * i) + 1] = (value & 0xffff0000)
+							  >> 16;
+	}
+}
+
+static void pmecc_substitute(struct mtd_info *mtd)
+{
+	int i, j;
+	struct nand_chip *nand_chip = mtd->priv;
+	struct atmel_nand_host *host = nand_chip->priv;
+	int16_t *si;
+	int16_t *partial_syn = host->partial_syn;
+	int16_t *alpha_to = host->alpha_to;
+	int16_t *index_of = host->index_of;
+
+	/* si[] is a table that holds the current syndrome value,
+	 * an element of that table belongs to the field
+	 */
+	si = host->si;
+
+	for (i = 1; i < 2 * NB_ERROR_MAX; i++)
+		si[i] = 0;
+
+	/* Computation 2t syndromes based on S(x) */
+	/* Odd syndromes */
+	for (i = 1; i <= 2 * host->tt - 1; i = i + 2) {
+		si[i] = 0;
+		for (j = 0; j < host->mm; j++) {
+			if (partial_syn[i] & ((unsigned short)0x1 << j))
+				si[i] = alpha_to[(i * j)] ^ si[i];
+		}
+	}
+	/* Even syndrome = (Odd syndrome) ** 2 */
+	for (i = 2; i <= 2 * host->tt; i = i + 2) {
+		j = i / 2;
+		if (si[j] == 0)
+			si[i] = 0;
+		else
+			si[i] = alpha_to[(2 * index_of[si[j]]) % host->nn];
+	}
+
+	return;
+}
+
+static void pmecc_get_sigma(struct mtd_info *mtd)
+{
+	int i, j, k;
+	struct nand_chip *nand_chip = mtd->priv;
+	struct atmel_nand_host *host = nand_chip->priv;
+	uint32_t dmu_0_count, tmp;
+	int16_t *lmu = host->lmu;
+	int16_t *si = host->si;
+	int16_t tt = host->tt;
+	int16_t *index_of = host->index_of;
+
+	/* mu          */
+	int mu[NB_ERROR_MAX + 1];
+
+	/* discrepancy */
+	int dmu[NB_ERROR_MAX + 1];
+
+	/* delta order   */
+	int delta[NB_ERROR_MAX + 1];
+
+	/* index of largest delta */
+	int ro;
+	int largest;
+	int diff;
+
+	dmu_0_count = 0;
+
+	/* First Row */
+
+	/* Mu */
+	mu[0] = -1;
+
+	/* Actually -1/2 */
+	/* Sigma(x) set to 1 */
+	for (i = 0; i < 2 * NB_ERROR_MAX + 1; i++)
+		host->smu[0][i] = 0;
+
+	host->smu[0][0] = 1;
+
+	/* discrepancy set to 1 */
+	dmu[0] = 1;
+	/* polynom order set to 0 */
+	lmu[0] = 0;
+	/* delta set to -1 */
+	delta[0]  = (mu[0] * 2 - lmu[0]) >> 1;
+
+	/* Second Row */
+
+	/* Mu */
+	mu[1]  = 0;
+	/* Sigma(x) set to 1 */
+	for (i = 0; i < (2 * NB_ERROR_MAX + 1); i++)
+		host->smu[1][i] = 0;
+
+	host->smu[1][0] = 1;
+
+	/* discrepancy set to S1 */
+	dmu[1] = si[1];
+
+	/* polynom order set to 0 */
+	lmu[1] = 0;
+
+	/* delta set to 0 */
+	delta[1]  = (mu[1] * 2 - lmu[1]) >> 1;
+
+	/* Init the Sigma(x) last row */
+	for (i = 0; i < (2 * NB_ERROR_MAX + 1); i++)
+		host->smu[tt + 1][i] = 0;
+
+	for (i = 1; i <= tt; i++) {
+		mu[i+1] = i << 1;
+		/* Begin Computing Sigma (Mu+1) and L(mu) */
+		/* check if discrepancy is set to 0 */
+		if (dmu[i] == 0) {
+			dmu_0_count++;
+
+			if ((tt - (lmu[i] >> 1) - 1) & 0x1)
+				tmp = ((tt - (lmu[i] >> 1) - 1) / 2) + 2;
+			else
+				tmp = ((tt - (lmu[i] >> 1) - 1) / 2) + 1;
+
+			if (dmu_0_count == tmp) {
+				for (j = 0; j <= (lmu[i] >> 1) + 1; j++)
+					host->smu[tt + 1][j] = host->smu[i][j];
+
+				lmu[tt + 1] = lmu[i];
+				return;
+			}
+
+			/* copy polynom */
+			for (j = 0; j <= lmu[i] >> 1; j++)
+				host->smu[i + 1][j] = host->smu[i][j];
+
+			/* copy previous polynom order to the next */
+			lmu[i + 1] = lmu[i];
+		} else {
+			ro = 0;
+			largest = -1;
+			/* find largest delta with dmu != 0 */
+			for (j = 0; j < i; j++) {
+				if ((dmu[j]) && (delta[j] > largest)) {
+					largest = delta[j];
+					ro = j;
+				}
+			}
+
+			/* compute difference */
+			diff = (mu[i] - mu[ro]);
+
+			/* Compute degree of the new smu polynomial */
+			if ((lmu[i] >> 1) > ((lmu[ro] >> 1) + diff))
+				lmu[i + 1] = lmu[i];
+			else
+				lmu[i + 1] = ((lmu[ro] >> 1) + diff) * 2;
+
+			/* Init smu[i+1] with 0 */
+			for (k = 0; k < (2 * NB_ERROR_MAX + 1); k++)
+				host->smu[i+1][k] = 0;
+
+			/* Compute smu[i+1] */
+			for (k = 0; k <= lmu[ro] >> 1; k++) {
+				if (!(host->smu[ro][k] && dmu[i]))
+					continue;
+
+				tmp = host->index_of[dmu[i]] + (host->nn -
+				       host->index_of[dmu[ro]]) +
+				      host->index_of[host->smu[ro][k]];
+				host->smu[i + 1][k + diff] =
+					host->alpha_to[tmp % host->nn];
+			}
+
+			for (k = 0; k <= lmu[i] >> 1; k++)
+				host->smu[i + 1][k] ^= host->smu[i][k];
+		}
+
+		/* End Computing Sigma (Mu+1) and L(mu) */
+		/* In either case compute delta */
+		delta[i + 1]  = (mu[i + 1] * 2 - lmu[i + 1]) >> 1;
+
+		/* Do not compute discrepancy for the last iteration */
+		if (i >= tt)
+			continue;
+
+		for (k = 0 ; k <= (lmu[i + 1] >> 1); k++) {
+			tmp = 2 * (i - 1);
+			if (k == 0)
+				dmu[i + 1] = si[tmp + 3];
+			else if (host->smu[i+1][k] && si[tmp + 3 - k]) {
+				tmp = index_of[host->smu[i + 1][k]] +
+				      index_of[si[2 * (i - 1) + 3 - k]];
+				tmp %= host->nn;
+				dmu[i + 1] = host->alpha_to[tmp] ^ dmu[i + 1];
+			}
+		}
+	}
+
+	return;
+}
+
+
+static int pmecc_err_location(struct mtd_info *mtd)
+{
+	int i;
+	/* number of error */
+	int err_nbr;
+	/* number of roots */
+	int roots_nbr;
+	int gf_dimension;
+	uint32_t val;
+	struct nand_chip *nand_chip = mtd->priv;
+	struct atmel_nand_host *host = nand_chip->priv;
+
+	if (host->sector_size == 512)
+		gf_dimension = GF_DIMENSION_13;
+	else
+		gf_dimension = GF_DIMENSION_14;
+
+	/* Disable PMECC Error Location IP */
+	pmerrloc_writel(host->pmerrloc_base, ELDIS, 0xffffffff);
+	err_nbr = 0;
+
+	for (i = 0; i <= host->lmu[host->tt + 1] >> 1; i++) {
+		pmerrloc_writel_sigma(host->pmerrloc_base, i,
+				      host->smu[host->tt + 1][i]);
+		err_nbr++;
+	}
+
+	val = pmerrloc_readl(host->pmerrloc_base, ELCFG);
+	val |= ((err_nbr - 1) << 16);
+	pmerrloc_writel(host->pmerrloc_base, ELCFG, val);
+
+	pmerrloc_writel(host->pmerrloc_base, ELEN,
+			host->sector_size * 8 + gf_dimension * host->tt);
+
+	while (!(pmerrloc_readl(host->pmerrloc_base, ELISR)
+		 & PMERRLOC_CALC_DONE))
+		cpu_relax();
+
+	roots_nbr = (pmerrloc_readl(host->pmerrloc_base, ELISR)
+		      & PMERRLOC_ERR_NUM_MASK) >> 8;
+
+	/* Number of roots == degree of smu hence <= tt */
+	if (roots_nbr == host->lmu[host->tt + 1] >> 1)
+		return err_nbr - 1;
+
+	/* Number of roots does not match the degree of smu
+	 * unable to correct error */
+	return -1;
+}
+
+static void pmecc_correct_data(struct mtd_info *mtd, uint8_t *buf,
+		int extra_bytes, int err_nbr)
+{
+	int i = 0;
+	int byte_pos, bit_pos;
+	int sector_size, ecc_size;
+	uint32_t tmp;
+	struct nand_chip *nand_chip = mtd->priv;
+	struct atmel_nand_host *host = nand_chip->priv;
+
+	sector_size = host->sector_size;
+	/* Get number of ECC bytes */
+	ecc_size = nand_chip->ecc.bytes;
+
+	while (err_nbr) {
+		byte_pos = (pmerrloc_readl_el(host->pmerrloc_base, i) - 1) / 8;
+		bit_pos = (pmerrloc_readl_el(host->pmerrloc_base, i) - 1) % 8;
+		dev_dbg(host->dev, "bad : %02x: byte_pos: %d, bit_pos: %d\n",
+			*(buf + byte_pos), byte_pos, bit_pos);
+
+		if (byte_pos < (sector_size + extra_bytes)) {
+			tmp = sector_size + pmecc_readl(host->ecc, SADDR);
+			if (byte_pos < tmp) {
+				if (*(buf + byte_pos) & (1 << bit_pos))
+					*(buf + byte_pos) &=
+						(0xFF ^ (1 << bit_pos));
+				else
+					*(buf + byte_pos) |= (1 << bit_pos);
+			} else {
+				if (*(buf + byte_pos + ecc_size) &
+				     (1 << bit_pos))
+					*(buf + byte_pos + ecc_size) &=
+						(0xFF ^ (1 << bit_pos));
+				else
+					*(buf + byte_pos + ecc_size) |=
+						(1 << bit_pos);
+			}
+		}
+		dev_dbg(host->dev, "corr: %02x\n", *(buf + byte_pos));
+		i++;
+		err_nbr--;
+	}
+
+	return;
+}
+
+static int pmecc_correction(struct mtd_info *mtd, u32 pmecc_stat, uint8_t *buf,
+	u8 *ecc)
+{
+	int i, err_nbr;
+	uint8_t *buf_pos;
+	struct nand_chip *nand_chip = mtd->priv;
+	int eccbytes = nand_chip->ecc.bytes;
+	struct atmel_nand_host *host = nand_chip->priv;
+
+	for (i = 0; i < eccbytes; i++)
+		if (ecc[i] != 0xff)
+			break;
+	/* Erased page, return OK */
+	if (i == eccbytes)
+		return 0;
+
+	pmerrloc_writel(host->pmerrloc_base, ELCFG,
+			(host->sector_size == 512) ? 0 : 1);
+
+	i = 0;
+	while (i < host->sector_number) {
+		err_nbr = 0;
+		if (pmecc_stat & 0x1) {
+			buf_pos = buf + i * host->sector_size;
+
+			pmecc_gen_syndrome(mtd, i);
+			pmecc_substitute(mtd);
+			pmecc_get_sigma(mtd);
+
+			err_nbr = pmecc_err_location(mtd);
+			if (err_nbr == -1) {
+				dev_err(host->dev, "Too many error.\n");
+				mtd->ecc_stats.failed++;
+				return -EFAULT;
+			} else {
+				dev_dbg(host->dev,  "Correct bits...\n");
+				pmecc_correct_data(mtd, buf_pos, 0, err_nbr);
+				mtd->ecc_stats.corrected += err_nbr;
+			}
+		}
+		i++;
+		pmecc_stat >>= 1;
+	}
+
+	return 0;
+}
+
+static int atmel_nand_pmecc_read_page(struct mtd_info *mtd,
+		struct nand_chip *chip, uint8_t *buf, int32_t page)
+{
+	struct atmel_nand_host *host = chip->priv;
+	int eccsize = chip->ecc.size;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+	int err = 0, stat;
+	int timeout = 10;
+	uint8_t *oob = chip->oob_poi;
+
+	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_RST);
+	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);
+	pmecc_writel(host->ecc, CFG, (pmecc_readl(host->ecc, CFG)
+		     & ~PMECC_CFG_WRITE_OP) | PMECC_CFG_AUTO_ENABLE);
+
+	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_ENABLE);
+
+	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_DATA);
+
+	chip->read_buf(mtd, buf, eccsize);
+	chip->read_buf(mtd, oob, mtd->oobsize);
+
+	while ((pmecc_readl(host->ecc, SR) & PMECC_SR_BUSY) && (timeout-- > 0))
+		cpu_relax();
+
+	stat = pmecc_readl(host->ecc, ISR);
+
+	if (stat != 0) {
+		if (pmecc_correction(mtd, stat, buf, &oob[eccpos[0]]))
+			err = -1;
+	}
+
+	return err;
+}
+
+static void atmel_nand_pmecc_write_page(struct mtd_info *mtd,
+		struct nand_chip *chip, const uint8_t *buf)
+{
+	int i, j;
+	int timeout = 10;
+	struct atmel_nand_host *host = chip->priv;
+	uint32_t *eccpos = chip->ecc.layout->eccpos;
+
+	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_RST);
+	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);
+
+	pmecc_writel(host->ecc, CFG, (pmecc_readl(host->ecc, CFG) |
+		PMECC_CFG_WRITE_OP) & ~PMECC_CFG_AUTO_ENABLE);
+
+	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_ENABLE);
+	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_DATA);
+
+	chip->write_buf(mtd, (u8 *)buf, mtd->writesize);
+
+	while ((pmecc_readl(host->ecc, SR) & PMECC_SR_BUSY) && (timeout-- > 0))
+		cpu_relax();
+
+	for (i = 0; i < host->sector_number; i++) {
+		for (j = 0; j < host->ecc_bytes_per_sector; j++) {
+			int pos;
+
+			pos = i * host->ecc_bytes_per_sector + j;
+			chip->oob_poi[eccpos[pos]] =
+				pmecc_readb_ecc(host->ecc, i, j);
+		}
+	}
+	chip->write_buf(mtd, chip->oob_poi, mtd->oobsize);
+
+	return;
+}
+
+static void atmel_init_pmecc(struct mtd_info *mtd)
+{
+	uint32_t val;
+	struct nand_chip *nand_chip = mtd->priv;
+	struct atmel_nand_host *host = nand_chip->priv;
+	struct nand_ecclayout *ecc_layout;
+
+	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_RST);
+	pmecc_writel(host->ecc, CTRL, PMECC_CTRL_DISABLE);
+
+	switch (host->tt) {
+	case 2:
+		val = PMECC_CFG_BCH_ERR2;
+		break;
+	case 4:
+		val = PMECC_CFG_BCH_ERR4;
+		break;
+	case 8:
+		val = PMECC_CFG_BCH_ERR8;
+		break;
+	case 12:
+		val = PMECC_CFG_BCH_ERR12;
+		break;
+	case 24:
+		val = PMECC_CFG_BCH_ERR24;
+		break;
+	}
+
+	if (host->sector_size == 512)
+		val |= PMECC_CFG_SECTOR512;
+	else if (host->sector_size == 1024)
+		val |= PMECC_CFG_SECTOR1024;
+
+	switch (host->sector_number) {
+	case 1:
+		val |= PMECC_CFG_PAGE_1SECTOR;
+		break;
+	case 2:
+		val |= PMECC_CFG_PAGE_2SECTORS;
+		break;
+	case 4:
+		val |= PMECC_CFG_PAGE_4SECTORS;
+		break;
+	case 8:
+		val |= PMECC_CFG_PAGE_8SECTORS;
+		break;
+	}
+
+	val |= PMECC_CFG_READ_OP | PMECC_CFG_SPARE_DISABLE
+		| PMECC_CFG_AUTO_DISABLE;
+	pmecc_writel(host->ecc, CFG, val);
+
+	ecc_layout = nand_chip->ecc.layout;
+	pmecc_writel(host->ecc, SAREA, mtd->oobsize - 1);
+	pmecc_writel(host->ecc, SADDR, ecc_layout->eccpos[0]);
+	pmecc_writel(host->ecc, EADDR,
+			ecc_layout->eccpos[ecc_layout->eccbytes - 1]);
+	pmecc_writel(host->ecc, CLK, PMECC_CLK_133MHZ);
+	pmecc_writel(host->ecc, IDR, 0xff);
+
+	val = pmecc_readl(host->ecc, CTRL);
+	val |= PMECC_CTRL_ENABLE;
+	pmecc_writel(host->ecc, CTRL, val);
+}
+
+static int __init atmel_pmecc_init_params(struct platform_device *pdev,
+					 struct atmel_nand_host *host)
+{
+	struct resource *regs;
+	struct resource *regs_pmerr, *regs_rom;
+	struct nand_chip *nand_chip;
+	struct mtd_info *mtd;
+	int res;
+
+	printk(KERN_ERR "atmel_pmecc_init_params\n");
+
+	nand_chip = &host->nand_chip;
+	mtd = &host->mtd;
+
+	regs = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!regs && hard_ecc) {
+		dev_warn(host->dev, "Can't get I/O resource regs\nFalling "
+				"back on software ECC\n");
+	}
+
+	nand_chip->ecc.mode = NAND_ECC_SOFT;	/* enable ECC */
+	if (no_ecc)
+		nand_chip->ecc.mode = NAND_ECC_NONE;
+	if (hard_ecc && regs) {
+		host->ecc = ioremap(regs->start, regs->end - regs->start + 1);
+		if (host->ecc == NULL) {
+			printk(KERN_ERR "atmel_nand: ioremap failed\n");
+			res = -EIO;
+			goto err_pmecc_ioremap;
+		}
+
+		regs_pmerr = platform_get_resource(pdev, IORESOURCE_MEM,
+						   2);
+		regs_rom = platform_get_resource(pdev, IORESOURCE_MEM,
+						 3);
+		if (regs_pmerr && regs_rom) {
+			host->pmerrloc_base = ioremap(regs_pmerr->start,
+			regs_pmerr->end - regs_pmerr->start + 1);
+			host->rom_base = ioremap(regs_rom->start,
+				regs_rom->end - regs_rom->start + 1);
+
+			if (host->pmerrloc_base && host->rom_base) {
+				nand_chip->ecc.mode = NAND_ECC_HW;
+				nand_chip->ecc.read_page =
+					atmel_nand_pmecc_read_page;
+				nand_chip->ecc.write_page =
+					atmel_nand_pmecc_write_page;
+			} else {
+				dev_err(host->dev, "Can not get I/O resource"
+				" for HW PMECC controller!\n");
+				goto err_pmloc_remap;
+			}
+		}
+
+		if (nand_chip->ecc.mode != NAND_ECC_HW)
+			printk(KERN_ERR "atmel_nand: Can not get I/O resource"
+				" for HW ECC Rolling back to software ECC\n");
+	}
+
+	if (nand_chip->ecc.mode == NAND_ECC_HW) {
+		/* ECC is calculated for the whole page (1 step) */
+		nand_chip->ecc.size = mtd->writesize;
+
+		/* set ECC page size and oob layout */
+		switch (mtd->writesize) {
+		case 2048:
+			nand_chip->ecc.bytes = 16;
+			nand_chip->ecc.steps = 1;
+			nand_chip->ecc.layout = &pmecc_oobinfo_2048;
+			host->mm = GF_DIMENSION_13;
+			host->nn = (1 << host->mm) - 1;
+			/* 2-bits correction */
+			host->tt = 2;
+			host->sector_size = 512;
+			host->sector_number = mtd->writesize /
+					      host->sector_size;
+			host->ecc_bytes_per_sector = 4;
+			host->alpha_to = pmecc_get_alpha_to(host);
+			host->index_of = pmecc_get_index_of(host);
+			break;
+		case 512:
+		case 1024:
+		case 4096:
+			/* TODO */
+			dev_warn(host->dev, "Only 2048 page size is currently"
+				"supported, Rolling back to software ECC\n");
+		default:
+			/* page size not handled by HW ECC */
+			/* switching back to soft ECC */
+			nand_chip->ecc.mode = NAND_ECC_SOFT;
+			nand_chip->ecc.calculate = NULL;
+			nand_chip->ecc.correct = NULL;
+			nand_chip->ecc.hwctl = NULL;
+			nand_chip->ecc.read_page = NULL;
+			nand_chip->ecc.postpad = 0;
+			nand_chip->ecc.prepad = 0;
+			nand_chip->ecc.bytes = 0;
+			break;
+		}
+	}
+
+	/* Initialize PMECC core if applicable */
+	if ((nand_chip->ecc.mode == NAND_ECC_HW) && cpu_has_pmecc())
+		atmel_init_pmecc(mtd);
+
+	return 0;
+err_pmloc_remap:
+	iounmap(host->ecc);
+	if (host->pmerrloc_base)
+		iounmap(host->pmerrloc_base);
+	if (host->rom_base)
+		iounmap(host->rom_base);
+err_pmecc_ioremap:
+	return -EIO;
+}
Index: linux-2.6.35/drivers/mtd/nand/atmel_nand_ecc.h
===================================================================
--- linux-2.6.35/drivers/mtd/nand/atmel_nand_ecc.h	(revision 149)
+++ linux-2.6.35/drivers/mtd/nand/atmel_nand_ecc.h	(revision 150)
@@ -36,4 +36,88 @@
 #define ATMEL_ECC_NPR		0x10			/* NParity register */
 #define		ATMEL_ECC_NPARITY	(0xffff << 0)		/* NParity */
 
+/* PMECC Register Definitions */
+#define ATMEL_PMECC_CFG			0x000	/* Configuration Register */
+#define		PMECC_CFG_BCH_ERR2		(0 << 0)
+#define		PMECC_CFG_BCH_ERR4		(1 << 0)
+#define		PMECC_CFG_BCH_ERR8		(2 << 0)
+#define		PMECC_CFG_BCH_ERR12		(3 << 0)
+#define		PMECC_CFG_BCH_ERR24		(4 << 0)
+
+#define		PMECC_CFG_SECTOR512		(0 << 4)
+#define		PMECC_CFG_SECTOR1024		(1 << 4)
+
+#define		PMECC_CFG_PAGE_1SECTOR		(0 << 8)
+#define		PMECC_CFG_PAGE_2SECTORS		(1 << 8)
+#define		PMECC_CFG_PAGE_4SECTORS		(2 << 8)
+#define		PMECC_CFG_PAGE_8SECTORS		(3 << 8)
+
+#define		PMECC_CFG_READ_OP		(0 << 12)
+#define		PMECC_CFG_WRITE_OP		(1 << 12)
+
+#define		PMECC_CFG_SPARE_ENABLE		(1 << 16)
+#define		PMECC_CFG_SPARE_DISABLE		(0 << 16)
+
+#define		PMECC_CFG_AUTO_ENABLE		(1 << 20)
+#define		PMECC_CFG_AUTO_DISABLE		(0 << 20)
+
+#define ATMEL_PMECC_SAREA		0x004	/* Spare area size */
+#define ATMEL_PMECC_SADDR		0x008	/* PMECC starting address */
+#define ATMEL_PMECC_EADDR		0x00c	/* PMECC ending address */
+#define ATMEL_PMECC_CLK			0x010	/* PMECC clock control */
+#define		PMECC_CLK_133MHZ		(2 << 0)
+
+#define ATMEL_PMECC_CTRL		0x014	/* PMECC control register */
+#define		PMECC_CTRL_RST			(1 << 0)
+#define		PMECC_CTRL_DATA			(1 << 1)
+#define		PMECC_CTRL_USER			(1 << 2)
+#define		PMECC_CTRL_ENABLE		(1 << 4)
+#define		PMECC_CTRL_DISABLE		(1 << 5)
+
+#define ATMEL_PMECC_SR			0x018	/* PMECC status register */
+#define		PMECC_SR_BUSY			(1 << 0)
+#define		PMECC_SR_ENABLE			(1 << 4)
+
+#define ATMEL_PMECC_IER			0x01c	/* PMECC interrupt enable */
+#define		PMECC_IER_ENABLE		(1 << 0)
+#define ATMEL_PMECC_IDR			0x020	/* PMECC interrupt disable */
+#define		PMECC_IER_DISABLE		(1 << 0)
+#define ATMEL_PMECC_IMR			0x024	/* PMECC interrupt mask */
+#define		PMECC_IER_MASK			(1 << 0)
+#define ATMEL_PMECC_ISR			0x028	/* PMECC interrupt status */
+#define ATMEL_PMECC_ECCx		0x040	/* PMECC ECC x */
+#define ATMEL_PMECC_REMx		0x240	/* PMECC REM x */
+
+/* PMERRLOC Register Definitions */
+#define ATMEL_PMERRLOC_ELCFG		0x000	/* Error location config */
+#define		PMERRLOC_ELCFG_SECTOR_512	(0 << 0)
+#define		PMERRLOC_ELCFG_SECTOR_1024	(1 << 0)
+#define		PMERRLOC_ELCFG_NUM_ERRORS(n)	((n) << 16)
+
+#define ATMEL_PMERRLOC_ELPRIM		0x004	/* Error location primitive */
+#define ATMEL_PMERRLOC_ELEN		0x008	/* Error location enable */
+#define ATMEL_PMERRLOC_ELDIS		0x00c	/* Error location disable */
+#define		PMERRLOC_DISABLE		(1 << 0)
+
+#define ATMEL_PMERRLOC_ELSR		0x010	/* Error location status */
+#define		PMERRLOC_ELSR_BUSY		(1 << 0)
+#define ATMEL_PMERRLOC_ELIER		0x014	/* Error location int enable */
+#define ATMEL_PMERRLOC_ELIDR		0x018	/* Error location int disable */
+#define ATMEL_PMERRLOC_ELIMR		0x01c	/* Error location int mask */
+#define ATMEL_PMERRLOC_ELISR		0x020	/* Error location int status */
+#define		PMERRLOC_ERR_NUM_MASK		(0x1f << 8)
+#define		PMERRLOC_CALC_DONE		(1 << 0)
+#define ATMEL_PMERRLOC_SIGMAx		0x028	/* Error location SIGMA x */
+#define ATMEL_PMERRLOC_ELx		0x08c	/* Error location x */
+
+/* Galois field dimension */
+#define GF_DIMENSION_13			13
+#define GF_DIMENSION_14			14
+
+#define PMECC_LOOKUP_TABLE_SIZE_512	0x2000
+#define PMECC_LOOKUP_TABLE_SIZE_1024	0x4000
+
+#define PMECC_LOOKUP_TABLE_OFFSET_512	0x8000
+#define PMECC_LOOKUP_TABLE_OFFSET_1024	0x10000
+
 #endif
Index: linux-2.6.35/drivers/spi/Kconfig
===================================================================
--- linux-2.6.35/drivers/spi/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/spi/Kconfig	(revision 150)
@@ -60,6 +60,15 @@
 	  This selects a driver for the Atmel SPI Controller, present on
 	  many AT32 (AVR32) and AT91 (ARM) chips.
 
+config SPI_ATMEL_DMA
+	bool "Atmel SPI DMA support"
+	depends on SPI_ATMEL && (ARCH_AT91SAM9G45 || ARCH_AT91SAM9X5) && DMA_ENGINE && EXPERIMENTAL
+	default y
+	help
+	  Say Y here if you want the Atmel SPI driver to use the DMA engine. Data transfers
+	  will be handled by the DMA controller: it will increase throughput and reduce
+	  CPU utilization.
+
 config SPI_BFIN
 	tristate "SPI controller driver for ADI Blackfin5xx"
 	depends on BLACKFIN
Index: linux-2.6.35/drivers/spi/atmel_spi.c
===================================================================
--- linux-2.6.35/drivers/spi/atmel_spi.c	(revision 149)
+++ linux-2.6.35/drivers/spi/atmel_spi.c	(revision 150)
@@ -8,6 +8,10 @@
  * published by the Free Software Foundation.
  */
 
+//#define DEBUG 12
+//#define VERBOSE 12
+//#define VERBOSE_DEBUG 12
+
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/clk.h>
@@ -15,6 +19,7 @@
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
 #include <linux/err.h>
 #include <linux/interrupt.h>
 #include <linux/spi/spi.h>
@@ -24,9 +29,26 @@
 #include <mach/board.h>
 #include <mach/gpio.h>
 #include <mach/cpu.h>
+#include <mach/at_hdmac.h>
 
 #include "atmel_spi.h"
 
+#if defined(CONFIG_SPI_ATMEL_DMA)
+/* use PIO for small transfers, avoiding DMA setup/teardown overhead and
+ * cache operations; better heuristics consider wordsize and bitrate.
+ */
+#define DMA_MIN_BYTES	16
+
+struct atmel_spi_dma {
+	struct dma_chan			*chan_rx;
+	struct dma_chan			*chan_tx;
+	struct scatterlist		sgrx;
+	struct scatterlist		sgtx;
+	struct dma_async_tx_descriptor	*data_desc_rx;
+	struct dma_async_tx_descriptor	*data_desc_tx;
+};
+#endif
+
 /*
  * The core SPI transfer engine just talks to a register bank to set up
  * DMA transfers; transfer queue progress is driven by IRQs.  The clock
@@ -34,7 +56,9 @@
  */
 struct atmel_spi {
 	spinlock_t		lock;
+	unsigned long		flags;
 
+	resource_size_t		phybase;
 	void __iomem		*regs;
 	int			irq;
 	struct clk		*clk;
@@ -43,13 +67,21 @@
 
 	u8			stopping;
 	struct list_head	queue;
+	struct tasklet_struct	tasklet;
 	struct spi_transfer	*current_transfer;
 	unsigned long		current_remaining_bytes;
 	struct spi_transfer	*next_transfer;
 	unsigned long		next_remaining_bytes;
+	int			done_status;
 
+	/* scratch buffer */
 	void			*buffer;
 	dma_addr_t		buffer_dma;
+
+#if defined(CONFIG_SPI_ATMEL_DMA)
+	/* dmaengine data */
+	struct atmel_spi_dma	dma;
+#endif
 };
 
 /* Controller-specific per-slave state */
@@ -168,6 +200,27 @@
 		gpio_set_value(asd->npcs_pin, !active);
 }
 
+static void atmel_spi_lock(struct atmel_spi *as)
+{
+		spin_lock_irqsave(&as->lock, as->flags);
+}
+
+static void atmel_spi_unlock(struct atmel_spi *as)
+{
+		spin_unlock_irqrestore(&as->lock, as->flags);
+}
+
+static inline bool atmel_spi_use_dma(struct spi_transfer *xfer)
+{
+#if defined(CONFIG_SPI_ATMEL_DMA)
+	if (xfer->len < DMA_MIN_BYTES)
+		return false;
+	return true;
+#else
+	return false;
+#endif
+}
+
 static inline int atmel_spi_xfer_is_last(struct spi_message *msg,
 					struct spi_transfer *xfer)
 {
@@ -179,6 +232,258 @@
 	return xfer->delay_usecs == 0 && !xfer->cs_change;
 }
 
+#if defined(CONFIG_SPI_ATMEL_DMA)
+static bool __init filter(struct dma_chan *chan, void *slave)
+{
+	struct	at_dma_slave		*sl = slave;
+
+	if (sl->dma_dev == chan->device->dev) {
+		chan->private = sl;
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static int __init atmel_spi_configure_dma(struct spi_master *master)
+{
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+	struct device		*controller = master->dev.parent;
+	struct at_dma_slave	*sdata;
+
+	sdata = controller->platform_data;
+
+	if (sdata && sdata->dma_dev) {
+		dma_cap_mask_t mask;
+
+		/* setup DMA addresses */
+		sdata->rx_reg = (dma_addr_t)as->phybase + SPI_RDR;
+		sdata->tx_reg = (dma_addr_t)as->phybase + SPI_TDR;
+
+		/* Try to grab two DMA channels */
+		dma_cap_zero(mask);
+		dma_cap_set(DMA_SLAVE, mask);
+		as->dma.chan_tx = dma_request_channel(mask, filter, sdata);
+		if (as->dma.chan_tx)
+			as->dma.chan_rx = dma_request_channel(mask, filter, sdata);
+	}
+	if (!as->dma.chan_rx || !as->dma.chan_tx) {
+		if (as->dma.chan_rx)
+			dma_release_channel(as->dma.chan_rx);
+		if (as->dma.chan_tx)
+			dma_release_channel(as->dma.chan_tx);
+		dev_err(&as->pdev->dev, "DMA channel not available, "
+					"unable to use SPI\n");
+		return -EBUSY;
+	}
+
+	dev_info(&as->pdev->dev, "Using %s (tx) and "
+				" %s (rx) for DMA transfers\n",
+				dma_chan_name(as->dma.chan_tx),
+				dma_chan_name(as->dma.chan_rx));
+
+	return 0;
+}
+
+static void atmel_spi_stop_dma(struct atmel_spi *as)
+{
+	if (as->dma.chan_rx)
+		as->dma.chan_rx->device->device_control(as->dma.chan_rx,
+							DMA_TERMINATE_ALL, 0);
+	if (as->dma.chan_tx)
+		as->dma.chan_tx->device->device_control(as->dma.chan_tx,
+							DMA_TERMINATE_ALL, 0);
+}
+
+static void atmel_spi_release_dma(struct atmel_spi *as)
+{
+	if (as->dma.chan_rx)
+		dma_release_channel(as->dma.chan_rx);
+	if (as->dma.chan_tx)
+		dma_release_channel(as->dma.chan_tx);
+}
+
+/* This function is called by the DMA driver from tasklet context */
+static void dma_callback(void *data)
+{
+	struct spi_master	*master = data;
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+
+	/* trigger SPI tasklet */
+	tasklet_schedule(&as->tasklet);
+}
+
+/*
+ * Next transfer using PIO.
+ * lock is held, spi tasklet is blocked
+ */
+static void atmel_spi_next_xfer_pio(struct spi_master *master,
+				struct spi_transfer *xfer)
+{
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+
+	dev_vdbg(master->dev.parent, "atmel_spi_next_xfer_pio\n");
+
+	as->current_remaining_bytes = xfer->len;
+
+	/* Make sure data is not remaining in RDR */
+	spi_readl(as, RDR);
+	while (spi_readl(as, SR) & SPI_BIT(RDRF)) {
+		spi_readl(as, RDR);
+		cpu_relax();
+	}
+
+	if (xfer->tx_buf)
+		spi_writel(as, TDR, *(u8 *)(xfer->tx_buf));
+	else
+		spi_writel(as, TDR, 0);
+
+	dev_dbg(master->dev.parent,
+		"  start pio xfer %p: len %u tx %p rx %p\n",
+		xfer, xfer->len, xfer->tx_buf, xfer->rx_buf);
+
+	/* Enable relevant interrupts */
+	spi_writel(as, IER, SPI_BIT(RDRF) | SPI_BIT(OVRES));
+}
+
+/*
+ * Submit next transfer for DMA.
+ * lock is held, spi tasklet is blocked
+ */
+static int atmel_spi_next_xfer_dma(struct spi_master *master,
+				struct spi_transfer *xfer)
+{
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+	struct dma_chan		*rxchan = as->dma.chan_rx;
+	struct dma_chan		*txchan = as->dma.chan_tx;
+	struct dma_async_tx_descriptor *rxdesc;
+	struct dma_async_tx_descriptor *txdesc;
+	dma_cookie_t		cookie;
+
+	dev_vdbg(master->dev.parent, "atmel_spi_next_xfer_dma\n");
+
+	/* Check that the channels are available */
+	if (!rxchan || !txchan)
+		return -ENODEV;
+
+	/* release lock for DMA operations */
+	atmel_spi_unlock(as);
+
+	/* prepare the RX dma transfer */
+	sg_init_table(&as->dma.sgrx, 1);
+	sg_dma_len(&as->dma.sgrx) = xfer->len;
+	if (xfer->rx_buf)
+		as->dma.sgrx.dma_address = xfer->rx_dma;
+	else
+		as->dma.sgrx.dma_address = as->buffer_dma;
+
+	/* prepare the TX dma transfer */
+	sg_init_table(&as->dma.sgtx, 1);
+	sg_dma_len(&as->dma.sgtx) = xfer->len;
+	if (xfer->tx_buf) {
+		as->dma.sgtx.dma_address = xfer->tx_dma;
+	} else {
+		as->dma.sgtx.dma_address = as->buffer_dma;
+		memset(as->buffer, 0, xfer->len);
+	}
+
+	/* Send both scatterlists */
+	rxdesc = rxchan->device->device_prep_slave_sg(rxchan,
+					&as->dma.sgrx,
+					1,
+					DMA_FROM_DEVICE,
+					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!rxdesc)
+		goto err_dma;
+
+	txdesc = txchan->device->device_prep_slave_sg(txchan,
+					&as->dma.sgtx,
+					1,
+					DMA_TO_DEVICE,
+					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
+	if (!txdesc)
+		goto err_dma;
+
+	dev_dbg(master->dev.parent,
+		"  start dma xfer %p: len %u tx %p/%08x rx %p/%08x\n",
+		xfer, xfer->len, xfer->tx_buf, xfer->tx_dma,
+		xfer->rx_buf, xfer->rx_dma);
+
+	/* Enable relevant interrupts */
+	spi_writel(as, IER, SPI_BIT(OVRES));
+
+	/* Put the callback on the RX transfer only, that should finish last */
+	rxdesc->callback = dma_callback;
+	rxdesc->callback_param = master;
+
+	/* Submit and fire RX and TX with TX last so we're ready to read! */
+	cookie = rxdesc->tx_submit(rxdesc);
+	if (dma_submit_error(cookie))
+		goto err_dma;
+	cookie = txdesc->tx_submit(txdesc);
+	if (dma_submit_error(cookie))
+		goto err_dma;
+	rxchan->device->device_issue_pending(rxchan);
+	txchan->device->device_issue_pending(txchan);
+
+	/* take back lock */
+	atmel_spi_lock(as);
+	return 0;
+
+err_dma:
+	spi_writel(as, IDR, SPI_BIT(OVRES));
+	atmel_spi_stop_dma(as);
+	atmel_spi_lock(as);
+	return -ENOMEM;
+}
+
+/*
+ * Choose way to submit next transfer and start it.
+ * lock is held, spi tasklet is blocked
+ */
+static void atmel_spi_next_xfer(struct spi_master *master,
+				struct spi_message *msg)
+{
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+	struct spi_transfer	*xfer;
+
+	dev_vdbg(&msg->spi->dev, "atmel_spi_next_xfer\n");
+
+	if (!as->current_transfer)
+		xfer = list_entry(msg->transfers.next,
+				struct spi_transfer, transfer_list);
+	else
+		xfer = list_entry(as->current_transfer->transfer_list.next,
+				struct spi_transfer, transfer_list);
+
+	as->current_transfer = xfer;
+
+	if (atmel_spi_use_dma(xfer)) {
+		if (!atmel_spi_next_xfer_dma(master, xfer))
+			return;
+		else
+			dev_err(&msg->spi->dev, "unable to use DMA, fallback to PIO\n");
+	}
+
+	/* use PIO if xfer is short or error appened using DMA */
+	atmel_spi_next_xfer_pio(master, xfer);
+}
+
+static void atmel_spi_disable_dma_irq(struct atmel_spi *as) {}
+#else
+static void atmel_spi_disable_dma_irq(struct atmel_spi *as)
+{
+	spi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));
+}
+
+static int __init atmel_spi_configure_dma(struct spi_master *master)
+{
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+
+	atmel_spi_disable_dma_irq(as);
+	return 0;
+}
+
 static void atmel_spi_next_xfer_data(struct spi_master *master,
 				struct spi_transfer *xfer,
 				dma_addr_t *tx_dma,
@@ -211,7 +516,7 @@
 }
 
 /*
- * Submit next transfer for DMA.
+ * Submit next transfer for PDC.
  * lock is held, spi irq is blocked
  */
 static void atmel_spi_next_xfer(struct spi_master *master,
@@ -311,6 +616,10 @@
 	spi_writel(as, PTCR, SPI_BIT(TXTEN) | SPI_BIT(RXTEN));
 }
 
+static void atmel_spi_stop_dma(struct atmel_spi *as) {}
+static void atmel_spi_release_dma(struct atmel_spi *as) {}
+#endif
+
 static void atmel_spi_next_message(struct spi_master *master)
 {
 	struct atmel_spi	*as = spi_master_get_devdata(master);
@@ -352,8 +661,12 @@
 
 	xfer->tx_dma = xfer->rx_dma = INVALID_DMA_ADDRESS;
 	if (xfer->tx_buf) {
+		/* tx_buf is a const void* where we need a void * for the dma
+		 * mapping */
+		void *nonconst_tx = (void *)xfer->tx_buf;
+
 		xfer->tx_dma = dma_map_single(dev,
-				(void *) xfer->tx_buf, xfer->len,
+				nonconst_tx, xfer->len,
 				DMA_TO_DEVICE);
 		if (dma_mapping_error(dev, xfer->tx_dma))
 			return -ENOMEM;
@@ -386,39 +699,204 @@
 
 static void
 atmel_spi_msg_done(struct spi_master *master, struct atmel_spi *as,
-		struct spi_message *msg, int status, int stay)
+		struct spi_message *msg, int stay)
 {
-	if (!stay || status < 0)
+	if (!stay || as->done_status < 0)
 		cs_deactivate(as, msg->spi);
 	else
 		as->stay = msg->spi;
 
 	list_del(&msg->queue);
-	msg->status = status;
+	msg->status = as->done_status;
 
 	dev_dbg(master->dev.parent,
 		"xfer complete: %u bytes transferred\n",
 		msg->actual_length);
 
-	spin_unlock(&as->lock);
+	atmel_spi_unlock(as);
 	msg->complete(msg->context);
-	spin_lock(&as->lock);
+	atmel_spi_lock(as);
 
 	as->current_transfer = NULL;
 	as->next_transfer = NULL;
+	as->done_status = 0;
 
 	/* continue if needed */
 	if (list_empty(&as->queue) || as->stopping)
-		spi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));
+		atmel_spi_disable_dma_irq(as);
 	else
 		atmel_spi_next_message(master);
 }
 
+#if defined(CONFIG_SPI_ATMEL_DMA)
+/* Called from IRQ
+ * lock is held
+ *
+ * Must update "current_remaining_bytes" to keep track of data
+ * to transfer.
+ */
+static void
+atmel_spi_pump_pio_data(struct atmel_spi *as, struct spi_transfer *xfer)
+{
+	u8		*txp;
+	u8		*rxp;
+	unsigned long	xfer_pos = xfer->len - as->current_remaining_bytes;
+
+	if (xfer->rx_buf) {
+		rxp = ((u8 *)xfer->rx_buf) + xfer_pos;
+		*rxp = spi_readl(as, RDR);
+	} else {
+		spi_readl(as, RDR);
+	}
+
+	as->current_remaining_bytes--;
+
+	if (as->current_remaining_bytes) {
+		if (xfer->tx_buf) {
+			txp = ((u8 *)xfer->tx_buf) + xfer_pos + 1;
+			spi_writel(as, TDR, *txp);
+		} else {
+			spi_writel(as, TDR, 0);
+		}
+	}
+}
+
+/* Tasklet
+ * Called from DMA callback + pio transfer and overrun IRQ.
+ */
+static void atmel_spi_tasklet_func(unsigned long data)
+{
+	struct spi_master	*master = (struct spi_master *)data;
+	struct atmel_spi	*as = spi_master_get_devdata(master);
+	struct spi_message	*msg;
+	struct spi_transfer	*xfer;
+
+	dev_vdbg(master->dev.parent, "atmel_spi_tasklet_func\n");
+
+	atmel_spi_lock(as);
+
+	xfer = as->current_transfer;
+
+	if (xfer == NULL)
+		/* already been there */
+		goto tasklet_out;
+
+	msg = list_entry(as->queue.next, struct spi_message, queue);
+
+	if (as->done_status < 0) {
+		/* error happened (overrun) */
+		if (atmel_spi_use_dma(xfer))
+			atmel_spi_stop_dma(as);
+	} else {
+		/* only update length if no error */
+		msg->actual_length += xfer->len;
+	}
+
+	if (atmel_spi_use_dma(xfer)) {
+		if (!msg->is_dma_mapped)
+			atmel_spi_dma_unmap_xfer(master, xfer);
+	}
+
+	if (xfer->delay_usecs)
+		udelay(xfer->delay_usecs);
+
+	if (atmel_spi_xfer_is_last(msg, xfer) || as->done_status < 0) {
+		/* report completed (or erroneous) message */
+		atmel_spi_msg_done(master, as, msg, xfer->cs_change);
+	} else {
+		if (xfer->cs_change) {
+			cs_deactivate(as, msg->spi);
+			udelay(1);
+			cs_activate(as, msg->spi);
+		}
+
+		/*
+		 * Not done yet. Submit the next transfer.
+		 *
+		 * FIXME handle protocol options for xfer
+		 */
+		atmel_spi_next_xfer(master, msg);
+	}
+
+tasklet_out:
+	atmel_spi_unlock(as);
+}
+
+
+/* Interrupt with DMA engine management
+ *
+ * No need for locking in this Interrupt handler: done_status is the
+ * only information modified. What we need is the update of this field
+ * before tasklet runs. This is ensured by using barrier.
+ */
 static irqreturn_t
 atmel_spi_interrupt(int irq, void *dev_id)
 {
 	struct spi_master	*master = dev_id;
 	struct atmel_spi	*as = spi_master_get_devdata(master);
+	u32			status, pending, imr;
+	struct spi_transfer	*xfer;
+	int			ret = IRQ_NONE;
+
+	imr = spi_readl(as, IMR);
+	status = spi_readl(as, SR);
+	pending = status & imr;
+
+	if (pending & SPI_BIT(OVRES)) {
+		ret = IRQ_HANDLED;
+		spi_writel(as, IDR, SPI_BIT(OVRES));
+		dev_warn(master->dev.parent, "overrun\n");
+
+		/*
+		 * When we get an overrun, we disregard the current
+		 * transfer. Data will not be copied back from any
+		 * bounce buffer and msg->actual_len will not be
+		 * updated with the last xfer.
+		 *
+		 * We will also not process any remaning transfers in
+		 * the message.
+		 *
+		 * All actions are done in tasklet with done_status indication
+		 */
+		as->done_status = -EIO;
+		smp_wmb();
+
+		/* Clear any overrun happening while cleaning up */
+		spi_readl(as, SR);
+
+		tasklet_schedule(&as->tasklet);
+
+	} else if (pending & SPI_BIT(RDRF)) {
+		atmel_spi_lock(as);
+
+		if (as->current_remaining_bytes) {
+			ret = IRQ_HANDLED;
+			xfer = as->current_transfer;
+			atmel_spi_pump_pio_data(as, xfer);
+			if (!as->current_remaining_bytes) {
+				/* no more data to xfer, kick tasklet */
+				spi_writel(as, IDR, pending);
+				tasklet_schedule(&as->tasklet);
+			}
+		}
+
+		atmel_spi_unlock(as);
+	} else {
+		WARN_ONCE(pending, "IRQ not handled, pending = %x\n", pending);
+		ret = IRQ_HANDLED;
+		spi_writel(as, IDR, pending);
+	}
+
+	return ret;
+}
+#else
+static void atmel_spi_tasklet_func(unsigned long data) {}
+
+static irqreturn_t
+atmel_spi_interrupt(int irq, void *dev_id)
+{
+	struct spi_master	*master = dev_id;
+	struct atmel_spi	*as = spi_master_get_devdata(master);
 	struct spi_message	*msg;
 	struct spi_transfer	*xfer;
 	u32			status, pending, imr;
@@ -483,7 +961,8 @@
 		/* Clear any overrun happening while cleaning up */
 		spi_readl(as, SR);
 
-		atmel_spi_msg_done(master, as, msg, -EIO, 0);
+		as->done_status = -EIO;
+		atmel_spi_msg_done(master, as, msg, 0);
 	} else if (pending & (SPI_BIT(RXBUFF) | SPI_BIT(ENDRX))) {
 		ret = IRQ_HANDLED;
 
@@ -501,7 +980,7 @@
 
 			if (atmel_spi_xfer_is_last(msg, xfer)) {
 				/* report completed message */
-				atmel_spi_msg_done(master, as, msg, 0,
+				atmel_spi_msg_done(master, as, msg,
 						xfer->cs_change);
 			} else {
 				if (xfer->cs_change) {
@@ -530,6 +1009,7 @@
 
 	return ret;
 }
+#endif
 
 static int atmel_spi_setup(struct spi_device *spi)
 {
@@ -627,13 +1107,11 @@
 		spi->controller_state = asd;
 		gpio_direction_output(npcs_pin, !(spi->mode & SPI_CS_HIGH));
 	} else {
-		unsigned long		flags;
-
-		spin_lock_irqsave(&as->lock, flags);
+		atmel_spi_lock(as);
 		if (as->stay == spi)
 			as->stay = NULL;
 		cs_deactivate(as, spi);
-		spin_unlock_irqrestore(&as->lock, flags);
+		atmel_spi_unlock(as);
 	}
 
 	asd->csr = csr;
@@ -652,8 +1130,9 @@
 {
 	struct atmel_spi	*as;
 	struct spi_transfer	*xfer;
-	unsigned long		flags;
 	struct device		*controller = spi->master->dev.parent;
+	u8			bits;
+	struct atmel_spi_device	*asd;
 
 	as = spi_master_get_devdata(spi->master);
 
@@ -672,21 +1151,27 @@
 			return -EINVAL;
 		}
 
+		if (xfer->bits_per_word) {
+			asd = spi->controller_state;
+			bits = (asd->csr >> 4) & 0xf;
+			if (bits != xfer->bits_per_word - 8) {
+				dev_dbg(&spi->dev, "you can't yet change "
+					 "bits_per_word in transfers\n");
+				return -ENOPROTOOPT;
+			}
+		}
+
 		/* FIXME implement these protocol options!! */
-		if (xfer->bits_per_word || xfer->speed_hz) {
+		if (xfer->speed_hz) {
 			dev_dbg(&spi->dev, "no protocol options yet\n");
 			return -ENOPROTOOPT;
 		}
 
 		/*
 		 * DMA map early, for performance (empties dcache ASAP) and
-		 * better fault reporting.  This is a DMA-only driver.
-		 *
-		 * NOTE that if dma_unmap_single() ever starts to do work on
-		 * platforms supported by this driver, we would need to clean
-		 * up mappings for previously-mapped transfers.
+		 * better fault reporting.
 		 */
-		if (!msg->is_dma_mapped) {
+		if (!msg->is_dma_mapped && atmel_spi_use_dma(xfer)) {
 			if (atmel_spi_dma_map_xfer(as, xfer) < 0)
 				return -ENOMEM;
 		}
@@ -705,11 +1190,11 @@
 	msg->status = -EINPROGRESS;
 	msg->actual_length = 0;
 
-	spin_lock_irqsave(&as->lock, flags);
+	atmel_spi_lock(as);
 	list_add_tail(&msg->queue, &as->queue);
 	if (!as->current_transfer)
 		atmel_spi_next_message(spi->master);
-	spin_unlock_irqrestore(&as->lock, flags);
+	atmel_spi_unlock(as);
 
 	return 0;
 }
@@ -719,17 +1204,16 @@
 	struct atmel_spi	*as = spi_master_get_devdata(spi->master);
 	struct atmel_spi_device	*asd = spi->controller_state;
 	unsigned		gpio = (unsigned) spi->controller_data;
-	unsigned long		flags;
 
 	if (!asd)
 		return;
 
-	spin_lock_irqsave(&as->lock, flags);
+	atmel_spi_lock(as);
 	if (as->stay == spi) {
 		as->stay = NULL;
 		cs_deactivate(as, spi);
 	}
-	spin_unlock_irqrestore(&as->lock, flags);
+	atmel_spi_unlock(as);
 
 	spi->controller_state = NULL;
 	gpio_free(gpio);
@@ -788,10 +1272,12 @@
 
 	spin_lock_init(&as->lock);
 	INIT_LIST_HEAD(&as->queue);
+	tasklet_init(&as->tasklet, atmel_spi_tasklet_func, (unsigned long)master);
 	as->pdev = pdev;
 	as->regs = ioremap(regs->start, resource_size(regs));
 	if (!as->regs)
 		goto out_free_buffer;
+	as->phybase = regs->start;
 	as->irq = irq;
 	as->clk = clk;
 
@@ -805,7 +1291,11 @@
 	spi_writel(as, CR, SPI_BIT(SWRST));
 	spi_writel(as, CR, SPI_BIT(SWRST)); /* AT91SAM9263 Rev B workaround */
 	spi_writel(as, MR, SPI_BIT(MSTR) | SPI_BIT(MODFDIS));
-	spi_writel(as, PTCR, SPI_BIT(RXTDIS) | SPI_BIT(TXTDIS));
+
+	ret = atmel_spi_configure_dma(master);
+	if (ret)
+		goto out_reset_hw;
+
 	spi_writel(as, CR, SPI_BIT(SPIEN));
 
 	/* go! */
@@ -814,10 +1304,12 @@
 
 	ret = spi_register_master(master);
 	if (ret)
-		goto out_reset_hw;
+		goto out_free_dma;
 
 	return 0;
 
+out_free_dma:
+	atmel_spi_release_dma(as);
 out_reset_hw:
 	spi_writel(as, CR, SPI_BIT(SWRST));
 	spi_writel(as, CR, SPI_BIT(SWRST)); /* AT91SAM9263 Rev B workaround */
@@ -826,6 +1318,7 @@
 out_unmap_regs:
 	iounmap(as->regs);
 out_free_buffer:
+	tasklet_kill(&as->tasklet);
 	dma_free_coherent(&pdev->dev, BUFFER_SIZE, as->buffer,
 			as->buffer_dma);
 out_free:
@@ -839,10 +1332,13 @@
 	struct spi_master	*master = platform_get_drvdata(pdev);
 	struct atmel_spi	*as = spi_master_get_devdata(master);
 	struct spi_message	*msg;
+	struct spi_transfer	*xfer;
 
 	/* reset the hardware and block queue progress */
 	spin_lock_irq(&as->lock);
 	as->stopping = 1;
+	atmel_spi_stop_dma(as);
+	atmel_spi_release_dma(as);
 	spi_writel(as, CR, SPI_BIT(SWRST));
 	spi_writel(as, CR, SPI_BIT(SWRST)); /* AT91SAM9263 Rev B workaround */
 	spi_readl(as, SR);
@@ -850,13 +1346,15 @@
 
 	/* Terminate remaining queued transfers */
 	list_for_each_entry(msg, &as->queue, queue) {
-		/* REVISIT unmapping the dma is a NOP on ARM and AVR32
-		 * but we shouldn't depend on that...
-		 */
+		list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+			if (!msg->is_dma_mapped && atmel_spi_use_dma(xfer))
+				atmel_spi_dma_unmap_xfer(master, xfer);
+		}
 		msg->status = -ESHUTDOWN;
 		msg->complete(msg->context);
 	}
 
+	tasklet_kill(&as->tasklet);
 	dma_free_coherent(&pdev->dev, BUFFER_SIZE, as->buffer,
 			as->buffer_dma);
 
Index: linux-2.6.35/drivers/input/touchscreen/Kconfig
===================================================================
--- linux-2.6.35/drivers/input/touchscreen/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/input/touchscreen/Kconfig	(revision 150)
@@ -329,7 +329,7 @@
 
 config TOUCHSCREEN_ATMEL_TSADCC
 	tristate "Atmel Touchscreen Interface"
-	depends on ARCH_AT91SAM9RL || ARCH_AT91SAM9G45
+	depends on ARCH_AT91SAM9RL || ARCH_AT91SAM9G45 || ARCH_AT91SAM9X5
 	help
 	  Say Y here if you have a 4-wire touchscreen connected to the
           ADC Controller on your Atmel SoC (such as the AT91SAM9RL).
Index: linux-2.6.35/drivers/input/touchscreen/atmel_tsadcc.c
===================================================================
--- linux-2.6.35/drivers/input/touchscreen/atmel_tsadcc.c	(revision 149)
+++ linux-2.6.35/drivers/input/touchscreen/atmel_tsadcc.c	(revision 150)
@@ -25,77 +25,37 @@
 #include <mach/board.h>
 #include <mach/cpu.h>
 
-/* Register definitions based on AT91SAM9RL64 preliminary draft datasheet */
+#include "atmel_tsadcc.h"
 
-#define ATMEL_TSADCC_CR		0x00	/* Control register */
-#define   ATMEL_TSADCC_SWRST	(1 << 0)	/* Software Reset*/
-#define	  ATMEL_TSADCC_START	(1 << 1)	/* Start conversion */
+#define cpu_has_9x5_adc() (cpu_is_at91sam9x5())
 
-#define ATMEL_TSADCC_MR		0x04	/* Mode register */
-#define	  ATMEL_TSADCC_TSAMOD	(3    <<  0)	/* ADC mode */
-#define	    ATMEL_TSADCC_TSAMOD_ADC_ONLY_MODE	(0x0)	/* ADC Mode */
-#define	    ATMEL_TSADCC_TSAMOD_TS_ONLY_MODE	(0x1)	/* Touch Screen Only Mode */
-#define	  ATMEL_TSADCC_LOWRES	(1    <<  4)	/* Resolution selection */
-#define	  ATMEL_TSADCC_SLEEP	(1    <<  5)	/* Sleep mode */
-#define	  ATMEL_TSADCC_PENDET	(1    <<  6)	/* Pen Detect selection */
-#define	  ATMEL_TSADCC_PRES	(1    <<  7)	/* Pressure Measurement Selection */
-#define	  ATMEL_TSADCC_PRESCAL	(0x3f <<  8)	/* Prescalar Rate Selection */
-#define	  ATMEL_TSADCC_EPRESCAL	(0xff <<  8)	/* Prescalar Rate Selection (Extended) */
-#define	  ATMEL_TSADCC_STARTUP	(0x7f << 16)	/* Start Up time */
-#define	  ATMEL_TSADCC_SHTIM	(0xf  << 24)	/* Sample & Hold time */
-#define	  ATMEL_TSADCC_PENDBC	(0xf  << 28)	/* Pen Detect debouncing time */
+#define ADC_DEFAULT_CLOCK	100000
 
-#define ATMEL_TSADCC_TRGR	0x08	/* Trigger register */
-#define	  ATMEL_TSADCC_TRGMOD	(7      <<  0)	/* Trigger mode */
-#define	    ATMEL_TSADCC_TRGMOD_NONE		(0 << 0)
-#define     ATMEL_TSADCC_TRGMOD_EXT_RISING	(1 << 0)
-#define     ATMEL_TSADCC_TRGMOD_EXT_FALLING	(2 << 0)
-#define     ATMEL_TSADCC_TRGMOD_EXT_ANY		(3 << 0)
-#define     ATMEL_TSADCC_TRGMOD_PENDET		(4 << 0)
-#define     ATMEL_TSADCC_TRGMOD_PERIOD		(5 << 0)
-#define     ATMEL_TSADCC_TRGMOD_CONTINUOUS	(6 << 0)
-#define   ATMEL_TSADCC_TRGPER	(0xffff << 16)	/* Trigger period */
+#define ZTHRESHOLD		3200
 
-#define ATMEL_TSADCC_TSR	0x0C	/* Touch Screen register */
-#define	  ATMEL_TSADCC_TSFREQ	(0xf <<  0)	/* TS Frequency in Interleaved mode */
-#define	  ATMEL_TSADCC_TSSHTIM	(0xf << 24)	/* Sample & Hold time */
+#define ANDROID_CALIBRATION
 
-#define ATMEL_TSADCC_CHER	0x10	/* Channel Enable register */
-#define ATMEL_TSADCC_CHDR	0x14	/* Channel Disable register */
-#define ATMEL_TSADCC_CHSR	0x18	/* Channel Status register */
-#define	  ATMEL_TSADCC_CH(n)	(1 << (n))	/* Channel number */
+#if defined(ANDROID_CALIBRATION)
+int calibrated;	
+int tx1;		
+int ty1;		
+int tz1;		
+int tx2;		
+int ty2;		
+int tz2;		
+int ts;
 
-#define ATMEL_TSADCC_SR		0x1C	/* Status register */
-#define	  ATMEL_TSADCC_EOC(n)	(1 << ((n)+0))	/* End of conversion for channel N */
-#define	  ATMEL_TSADCC_OVRE(n)	(1 << ((n)+8))	/* Overrun error for channel N */
-#define	  ATMEL_TSADCC_DRDY	(1 << 16)	/* Data Ready */
-#define	  ATMEL_TSADCC_GOVRE	(1 << 17)	/* General Overrun Error */
-#define	  ATMEL_TSADCC_ENDRX	(1 << 18)	/* End of RX Buffer */
-#define	  ATMEL_TSADCC_RXBUFF	(1 << 19)	/* TX Buffer full */
-#define	  ATMEL_TSADCC_PENCNT	(1 << 20)	/* Pen contact */
-#define	  ATMEL_TSADCC_NOCNT	(1 << 21)	/* No contact */
+module_param(tx1, int, 0664);
+module_param(ty1, int, 0664);
+module_param(tz1, int, 0664);
+module_param(tx2, int, 0664);
+module_param(ty2, int, 0664);
+module_param(tz2, int, 0664);
+module_param(ts, int, 0664);
+module_param(calibrated, int, 0664);
 
-#define ATMEL_TSADCC_LCDR	0x20	/* Last Converted Data register */
-#define	  ATMEL_TSADCC_DATA	(0x3ff << 0)	/* Channel data */
+#endif
 
-#define ATMEL_TSADCC_IER	0x24	/* Interrupt Enable register */
-#define ATMEL_TSADCC_IDR	0x28	/* Interrupt Disable register */
-#define ATMEL_TSADCC_IMR	0x2C	/* Interrupt Mask register */
-#define ATMEL_TSADCC_CDR0	0x30	/* Channel Data 0 */
-#define ATMEL_TSADCC_CDR1	0x34	/* Channel Data 1 */
-#define ATMEL_TSADCC_CDR2	0x38	/* Channel Data 2 */
-#define ATMEL_TSADCC_CDR3	0x3C	/* Channel Data 3 */
-#define ATMEL_TSADCC_CDR4	0x40	/* Channel Data 4 */
-#define ATMEL_TSADCC_CDR5	0x44	/* Channel Data 5 */
-
-#define ATMEL_TSADCC_XPOS	0x50
-#define ATMEL_TSADCC_Z1DAT	0x54
-#define ATMEL_TSADCC_Z2DAT	0x58
-
-#define PRESCALER_VAL(x)	((x) >> 8)
-
-#define ADC_DEFAULT_CLOCK	100000
-
 struct atmel_tsadcc {
 	struct input_dev	*input;
 	char			phys[32];
@@ -103,7 +63,7 @@
 	int			irq;
 	unsigned int		prev_absx;
 	unsigned int		prev_absy;
-	unsigned char		bufferedmeasure;
+	unsigned int		prev_absz;
 };
 
 static void __iomem		*tsc_base;
@@ -115,59 +75,121 @@
 {
 	struct atmel_tsadcc	*ts_dev = (struct atmel_tsadcc *)dev;
 	struct input_dev	*input_dev = ts_dev->input;
+    struct at91_tsadcc_data *pdata = input_dev->dev.parent->platform_data;
 
 	unsigned int status;
 	unsigned int reg;
+	unsigned int z1, z2;
+	unsigned int Rxp = 1;
+	unsigned int factor = 1000;
 
 	status = atmel_tsadcc_read(ATMEL_TSADCC_SR);
 	status &= atmel_tsadcc_read(ATMEL_TSADCC_IMR);
 
 	if (status & ATMEL_TSADCC_NOCNT) {
 		/* Contact lost */
-		reg = atmel_tsadcc_read(ATMEL_TSADCC_MR) | ATMEL_TSADCC_PENDBC;
-
-		atmel_tsadcc_write(ATMEL_TSADCC_MR, reg);
+		if (cpu_has_9x5_adc()) {
+			/* 9X5 using TSMR to set PENDBC time */
+			reg = atmel_tsadcc_read(ATMEL_TSADCC_TSMR) | ((pdata->pendet_debounce << 28) & ATMEL_TSADCC_PENDBC);
+			atmel_tsadcc_write(ATMEL_TSADCC_TSMR, reg);
+		} else {
+			reg = atmel_tsadcc_read(ATMEL_TSADCC_MR) | ATMEL_TSADCC_PENDBC;
+			atmel_tsadcc_write(ATMEL_TSADCC_MR, reg);
+		}
 		atmel_tsadcc_write(ATMEL_TSADCC_TRGR, ATMEL_TSADCC_TRGMOD_NONE);
 		atmel_tsadcc_write(ATMEL_TSADCC_IDR,
-				   ATMEL_TSADCC_EOC(3) | ATMEL_TSADCC_NOCNT);
+				   ATMEL_TSADCC_CONVERSION_END | ATMEL_TSADCC_NOCNT);
 		atmel_tsadcc_write(ATMEL_TSADCC_IER, ATMEL_TSADCC_PENCNT);
 
 		input_report_key(input_dev, BTN_TOUCH, 0);
-		ts_dev->bufferedmeasure = 0;
 		input_sync(input_dev);
 
 	} else if (status & ATMEL_TSADCC_PENCNT) {
 		/* Pen detected */
-		reg = atmel_tsadcc_read(ATMEL_TSADCC_MR);
-		reg &= ~ATMEL_TSADCC_PENDBC;
+		if (cpu_has_9x5_adc()) {
+			reg = atmel_tsadcc_read(ATMEL_TSADCC_TSMR);
+			reg &= ~ATMEL_TSADCC_PENDBC;
+			atmel_tsadcc_write(ATMEL_TSADCC_TSMR, reg);
+		} else {
+			reg = atmel_tsadcc_read(ATMEL_TSADCC_MR);
+			reg &= ~ATMEL_TSADCC_PENDBC;
+			atmel_tsadcc_write(ATMEL_TSADCC_MR, reg);
+		}
 
 		atmel_tsadcc_write(ATMEL_TSADCC_IDR, ATMEL_TSADCC_PENCNT);
-		atmel_tsadcc_write(ATMEL_TSADCC_MR, reg);
 		atmel_tsadcc_write(ATMEL_TSADCC_IER,
-				   ATMEL_TSADCC_EOC(3) | ATMEL_TSADCC_NOCNT);
+				   ATMEL_TSADCC_CONVERSION_END | ATMEL_TSADCC_NOCNT);
 		atmel_tsadcc_write(ATMEL_TSADCC_TRGR,
-				   ATMEL_TSADCC_TRGMOD_PERIOD | (0x0FFF << 16));
+				   ATMEL_TSADCC_TRGMOD_PERIOD | (0x00D0 << 16));
 
-	} else if (status & ATMEL_TSADCC_EOC(3)) {
+	} else if ((status & ATMEL_TSADCC_CONVERSION_END) == ATMEL_TSADCC_CONVERSION_END) {
 		/* Conversion finished */
+		
+		/* make new measurement */
+ 		if (cpu_has_9x5_adc()) {
+            unsigned int xscale, yscale;
+			
+			/* calculate position */
+			reg = atmel_tsadcc_read(ATMEL_TSADCC_XPOSR);
+			ts_dev->prev_absx = (reg & ATMEL_TSADCC_XPOS) << 10;
+			xscale = (reg & ATMEL_TSADCC_XSCALE) >> 16;
+			ts_dev->prev_absx /= xscale ? xscale: 1;
 
-		if (ts_dev->bufferedmeasure) {
-			/* Last measurement is always discarded, since it can
-			 * be erroneous.
-			 * Always report previous measurement */
+			reg = atmel_tsadcc_read(ATMEL_TSADCC_YPOSR);
+			ts_dev->prev_absy = (reg & ATMEL_TSADCC_YPOS) << 10;
+			yscale = (reg & ATMEL_TSADCC_YSCALE) >> 16;
+			ts_dev->prev_absy /= yscale ? yscale: 1 << 10;
+
+            /* calculate the pressure */
+			reg = atmel_tsadcc_read(ATMEL_TSADCC_PRESSR);
+			z1 = reg & ATMEL_TSADCC_PRESSR_Z1;
+			z2 = (reg & ATMEL_TSADCC_PRESSR_Z2) >> 16;
+
+			if (z1 != 0)
+				ts_dev->prev_absz = Rxp * (ts_dev->prev_absx * factor / 1024) * (z2 * factor / z1 - factor) / factor;
+			else
+				ts_dev->prev_absz = 0;
+
+		} else {
+			ts_dev->prev_absx = atmel_tsadcc_read(ATMEL_TSADCC_CDR3) << 10;
+			ts_dev->prev_absx /= atmel_tsadcc_read(ATMEL_TSADCC_CDR2);
+
+			ts_dev->prev_absy = atmel_tsadcc_read(ATMEL_TSADCC_CDR1) << 10;
+			ts_dev->prev_absy /= atmel_tsadcc_read(ATMEL_TSADCC_CDR0);
+		}
+				/* report measurement to input layer */
+		if (ts_dev->prev_absz < ZTHRESHOLD) {
+			dev_dbg(&input_dev->dev,
+					"x = %d, y = %d, pressure = %d\n",
+					ts_dev->prev_absx, ts_dev->prev_absy,
+					ts_dev->prev_absz);
+#if defined(ANDROID_CALIBRATION)						
+			unsigned int x = (ts_dev->prev_absy - 0);			
+			unsigned int y = (860 - ts_dev->prev_absx); 
+			if(calibrated && ts)			
+				{				
+					int cal_x,cal_y;				
+					cal_x = (x*tx1 + y*ty1 + tz1)/ts ;			
+					cal_y = (x*tx2 + y*ty2 + tz2)/ts ;			
+					x = cal_x ;			
+					y = cal_y ;		
+				}			
+			input_report_abs(input_dev, ABS_X, x);			
+			input_report_abs(input_dev, ABS_Y, y);
+			
+#elif			
 			input_report_abs(input_dev, ABS_X, ts_dev->prev_absx);
 			input_report_abs(input_dev, ABS_Y, ts_dev->prev_absy);
+#endif
+
+			if (cpu_has_9x5_adc())
+				input_report_abs(input_dev, ABS_PRESSURE, ts_dev->prev_absz);
 			input_report_key(input_dev, BTN_TOUCH, 1);
 			input_sync(input_dev);
-		} else
-			ts_dev->bufferedmeasure = 1;
-
-		/* Now make new measurement */
-		ts_dev->prev_absx = atmel_tsadcc_read(ATMEL_TSADCC_CDR3) << 10;
-		ts_dev->prev_absx /= atmel_tsadcc_read(ATMEL_TSADCC_CDR2);
-
-		ts_dev->prev_absy = atmel_tsadcc_read(ATMEL_TSADCC_CDR1) << 10;
-		ts_dev->prev_absy /= atmel_tsadcc_read(ATMEL_TSADCC_CDR0);
+		} else {
+			dev_dbg(&input_dev->dev,
+					"pressure too low: not reporting\n");
+		}
 	}
 
 	return IRQ_HANDLED;
@@ -244,7 +266,6 @@
 	}
 
 	ts_dev->input = input_dev;
-	ts_dev->bufferedmeasure = 0;
 
 	snprintf(ts_dev->phys, sizeof(ts_dev->phys),
 		 "%s/input0", dev_name(&pdev->dev));
@@ -252,10 +273,13 @@
 	input_dev->name = "atmel touch screen controller";
 	input_dev->phys = ts_dev->phys;
 	input_dev->dev.parent = &pdev->dev;
-
+#if defined(ANDROID_CALIBRATION)
+    calibrated = 0;
+#endif
 	__set_bit(EV_ABS, input_dev->evbit);
 	input_set_abs_params(input_dev, ABS_X, 0, 0x3FF, 0, 0);
 	input_set_abs_params(input_dev, ABS_Y, 0, 0x3FF, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, 0xffffff, 0, 0);
 
 	input_set_capability(input_dev, EV_KEY, BTN_TOUCH);
 
@@ -284,19 +308,38 @@
 
 	dev_info(&pdev->dev, "Prescaler is set at: %d\n", prsc);
 
-	reg = ATMEL_TSADCC_TSAMOD_TS_ONLY_MODE		|
-		((0x00 << 5) & ATMEL_TSADCC_SLEEP)	|	/* Normal Mode */
-		((0x01 << 6) & ATMEL_TSADCC_PENDET)	|	/* Enable Pen Detect */
-		(prsc << 8)				|
-		((0x26 << 16) & ATMEL_TSADCC_STARTUP)	|
-		((pdata->pendet_debounce << 28) & ATMEL_TSADCC_PENDBC);
+	if (cpu_has_9x5_adc()) {
+		reg = 	((0x00 << 5) & ATMEL_TSADCC_SLEEP)	|	/* no Sleep Mode */
+			((0x00 << 6) & ATMEL_TSADCC_FWUP)	|	/* no Fast Wake Up needed */
+			(prsc << 8)				|
+            ((0x4 << 16) & ATMEL_TSADCC_STARTUP)	|
+			((pdata->ts_sample_hold_time << 24) & ATMEL_TSADCC_TRACKTIM);
+	} else {
+		reg = ATMEL_TSADCC_TSAMOD_TS_ONLY_MODE		|
+			((0x00 << 5) & ATMEL_TSADCC_SLEEP)	|	/* Normal Mode */
+			((0x01 << 6) & ATMEL_TSADCC_PENDET)	|	/* Enable Pen Detect */
+			(prsc << 8)				|
+			((0x26 << 16) & ATMEL_TSADCC_STARTUP)	|
+			((pdata->pendet_debounce << 28) & ATMEL_TSADCC_PENDBC);
+	}
 
 	atmel_tsadcc_write(ATMEL_TSADCC_CR, ATMEL_TSADCC_SWRST);
 	atmel_tsadcc_write(ATMEL_TSADCC_MR, reg);
 	atmel_tsadcc_write(ATMEL_TSADCC_TRGR, ATMEL_TSADCC_TRGMOD_NONE);
-	atmel_tsadcc_write(ATMEL_TSADCC_TSR,
-		(pdata->ts_sample_hold_time << 24) & ATMEL_TSADCC_TSSHTIM);
 
+	if (cpu_has_9x5_adc()) {
+		atmel_tsadcc_write(ATMEL_TSADCC_TSMR,
+					ATMEL_TSADCC_TSMODE_4WIRE_PRESS	|
+					((pdata->filtering_average << 4) & ATMEL_TSADCC_TSAV) |	/* Touchscreen average */
+					ATMEL_TSADCC_NOTSDMA		|
+					ATMEL_TSADCC_PENDET_ENA		|
+					((pdata->pendet_debounce << 28) & ATMEL_TSADCC_PENDBC) |
+					(0x3 << 8));				/* Touchscreen freq */
+	} else {
+		atmel_tsadcc_write(ATMEL_TSADCC_TSR,
+			(pdata->ts_sample_hold_time << 24) & ATMEL_TSADCC_TSSHTIM);
+	}
+
 	atmel_tsadcc_read(ATMEL_TSADCC_SR);
 	atmel_tsadcc_write(ATMEL_TSADCC_IER, ATMEL_TSADCC_PENCNT);
 
Index: linux-2.6.35/drivers/input/touchscreen/atmel_tsadcc.h
===================================================================
--- linux-2.6.35/drivers/input/touchscreen/atmel_tsadcc.h	(revision 0)
+++ linux-2.6.35/drivers/input/touchscreen/atmel_tsadcc.h	(revision 150)
@@ -0,0 +1,167 @@
+/*
+ *  Header file for AT91/AT32 ADC + touchscreen Controller
+ *
+ *  Data structure and register user interface
+ *
+ *  Copyright (C) 2010 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+#ifndef __ATMEL_TSADCC_H__
+#define __ATMEL_TSADCC_H__
+
+/* Register definitions based on AT91SAM9RL64 preliminary draft datasheet */
+#define ATMEL_TSADCC_CR		0x00	/* Control register */
+#define   ATMEL_TSADCC_SWRST	(1 << 0)	/* Software Reset*/
+#define	  ATMEL_TSADCC_START	(1 << 1)	/* Start conversion */
+
+#define ATMEL_TSADCC_MR		0x04	/* Mode register */
+#define	  ATMEL_TSADCC_TSAMOD	(3    <<  0)	/* ADC mode */
+#define	    ATMEL_TSADCC_TSAMOD_ADC_ONLY_MODE	(0x0)	/* ADC Mode */
+#define	    ATMEL_TSADCC_TSAMOD_TS_ONLY_MODE	(0x1)	/* Touch Screen Only Mode */
+#define	  ATMEL_TSADCC_LOWRES	(1    <<  4)	/* Resolution selection */
+#define	  ATMEL_TSADCC_SLEEP	(1    <<  5)	/* Sleep mode */
+#define	  ATMEL_TSADCC_PENDET	(1    <<  6)	/* Pen Detect selection */
+#define   ATMEL_TSADCC_FWUP	(1    <<  6)	/* Fast Wake Up selection (5series) */
+#define	  ATMEL_TSADCC_PRES	(1    <<  7)	/* Pressure Measurement Selection */
+#define	  ATMEL_TSADCC_PRESCAL	(0x3f <<  8)	/* Prescalar Rate Selection */
+#define	  ATMEL_TSADCC_EPRESCAL	(0xff <<  8)	/* Prescalar Rate Selection (Extended) */
+#define	  ATMEL_TSADCC_STARTUP	(0x7f << 16)	/* Start Up time */
+#define	  ATMEL_TSADCC_SHTIM	(0xf  << 24)	/* Sample & Hold time */
+#define	  ATMEL_TSADCC_PENDBC	(0xf  << 28)	/* Pen Detect debouncing time */
+
+#define ATMEL_TSADCC_TRGR	0x08	/* Trigger register */
+#define	  ATMEL_TSADCC_TRGMOD	(7      <<  0)	/* Trigger mode */
+#define	    ATMEL_TSADCC_TRGMOD_NONE		(0 << 0)
+#define     ATMEL_TSADCC_TRGMOD_EXT_RISING	(1 << 0)
+#define     ATMEL_TSADCC_TRGMOD_EXT_FALLING	(2 << 0)
+#define     ATMEL_TSADCC_TRGMOD_EXT_ANY		(3 << 0)
+#define     ATMEL_TSADCC_TRGMOD_PENDET		(4 << 0)
+#define     ATMEL_TSADCC_TRGMOD_PERIOD		(5 << 0)
+#define     ATMEL_TSADCC_TRGMOD_CONTINUOUS	(6 << 0)
+#define   ATMEL_TSADCC_TRGPER	(0xffff << 16)	/* Trigger period */
+
+#define ATMEL_TSADCC_TSR	0x0C	/* Touch Screen register */
+#define	  ATMEL_TSADCC_TSFREQ	(0xf <<  0)	/* TS Frequency in Interleaved mode */
+#define	  ATMEL_TSADCC_TSSHTIM	(0xf << 24)	/* Sample & Hold time */
+
+#define ATMEL_TSADCC_CHER	0x10	/* Channel Enable register */
+#define ATMEL_TSADCC_CHDR	0x14	/* Channel Disable register */
+#define ATMEL_TSADCC_CHSR	0x18	/* Channel Status register */
+#define	  ATMEL_TSADCC_CH(n)	(1 << (n))	/* Channel number */
+
+#define ATMEL_TSADCC_SR		0x1C	/* Status register */
+#define	  ATMEL_TSADCC_EOC(n)	(1 << ((n)+0))	/* End of conversion for channel N */
+#define	  ATMEL_TSADCC_OVRE(n)	(1 << ((n)+8))	/* Overrun error for channel N */
+#define	  ATMEL_TSADCC_DRDY	(1 << 16)	/* Data Ready */
+#define	  ATMEL_TSADCC_GOVRE	(1 << 17)	/* General Overrun Error */
+#define	  ATMEL_TSADCC_ENDRX	(1 << 18)	/* End of RX Buffer */
+#define	  ATMEL_TSADCC_RXBUFF	(1 << 19)	/* TX Buffer full */
+#define	  ATMEL_TSADCC_PENCNT	(1 << 20)	/* Pen contact */
+#define	  ATMEL_TSADCC_NOCNT	(1 << 21)	/* No contact */
+
+#define ATMEL_TSADCC_LCDR	0x20	/* Last Converted Data register */
+#define	  ATMEL_TSADCC_DATA	(0x3ff << 0)	/* Channel data */
+
+#define ATMEL_TSADCC_IER	0x24	/* Interrupt Enable register */
+#define ATMEL_TSADCC_IDR	0x28	/* Interrupt Disable register */
+#define ATMEL_TSADCC_IMR	0x2C	/* Interrupt Mask register */
+#define ATMEL_TSADCC_CDR0	0x30	/* Channel Data 0 */
+#define ATMEL_TSADCC_CDR1	0x34	/* Channel Data 1 */
+#define ATMEL_TSADCC_CDR2	0x38	/* Channel Data 2 */
+#define ATMEL_TSADCC_CDR3	0x3C	/* Channel Data 3 */
+#define ATMEL_TSADCC_CDR4	0x40	/* Channel Data 4 */
+#define ATMEL_TSADCC_CDR5	0x44	/* Channel Data 5 */
+
+#define ATMEL_TSADCC_XPOS	0x50
+#define ATMEL_TSADCC_Z1DAT	0x54
+#define ATMEL_TSADCC_Z2DAT	0x58
+
+#define ATMEL_TSADCC_CONVERSION_END		(ATMEL_TSADCC_EOC(3))
+
+/* Register definitions based on AT91SAM9X5 preliminary draft datasheet */
+#define	  ATMEL_TSADCC_TRACKTIM		(0x0f << 24)	/* Tracking Time */
+
+#define ATMEL_TSADCC_ISR	0x30	/* Interrupt Status register */
+#define	  ATMEL_TSADCC_XRDY		(1 << 20)	/* Measure XPOS Ready */
+#define	  ATMEL_TSADCC_YRDY		(1 << 21)	/* Measure YPOS Ready */
+#define	  ATMEL_TSADCC_PRDY		(1 << 22)	/* Measure Pressure Ready */
+#define	  ATMEL_TSADCC_COMPE		(1 << 26)	/* Comparison Event */
+#define	  ATMEL_TSADCC_PEN		(1 << 29)	/* Pen Contact */
+#define	  ATMEL_TSADCC_NOPEN		(1 << 30)	/* No Pen Contact */
+#define	  ATMEL_TSADCC_PENDET_STATUS	(1 << 31)	/* Pen Detect Status (not interrupt source) */
+
+#define ATMEL_TSADCC_TSMR	0xb0
+#define	  ATMEL_TSADCC_TSMODE		(3 <<  0)	/* Touch Screen Mode */
+#define	    ATMEL_TSADCC_TSMODE_NO		(0 << 0)	/* No Touch Screen */
+#define	    ATMEL_TSADCC_TSMODE_4WIRE_NO_PRESS	(1 << 0)	/* 4-wire Touch Screen without pressure measurement */
+#define	    ATMEL_TSADCC_TSMODE_4WIRE_PRESS	(2 << 0)	/* 4-wire Touch Screen with pressure measurement */
+#define	    ATMEL_TSADCC_TSMODE_5WIRE		(3 << 0)	/* 5-wire Touch Screen */
+#define	  ATMEL_TSADCC_TSAV		(3 <<  4)	/* Touch Screen Average */
+#define	    ATMEL_TSADCC_TSAV_1			(0 << 4)	/* No filtering. Only one conversion ADC per measure */
+#define	    ATMEL_TSADCC_TSAV_2			(1 << 4)	/* Averages 2 ADC conversions */
+#define	    ATMEL_TSADCC_TSAV_4			(2 << 4)	/* Averages 4 ADC conversions */
+#define	    ATMEL_TSADCC_TSAV_8			(3 << 4)	/* Averages 8 ADC conversions */
+#define	  ATMEL_TSADCC_TSSCTIM		(0x0f << 16)	/* Touch Screen switches closure time */
+
+#define	  ATMEL_TSADCC_NOTSDMA		(1 << 22)	/* No Touchscreen DMA */
+#define	  ATMEL_TSADCC_PENDET_DIS	(0 << 24)	/* Pen contact detection disable */
+#define	  ATMEL_TSADCC_PENDET_ENA	(1 << 24)	/* Pen contact detection enable */
+
+#define ATMEL_TSADCC_XPOSR	0xb4
+#define	  ATMEL_TSADCC_XSCALE		(0x3ff << 16)	/* Scale of X Position */
+
+#define ATMEL_TSADCC_YPOSR	0xb8
+#define	  ATMEL_TSADCC_YPOS		(0x3ff <<  0)	/* Y Position */
+#define	  ATMEL_TSADCC_YSCALE		(0x3ff << 16)	/* Scale of Y Position */
+
+#define ATMEL_TSADCC_PRESSR	0xbc	/* Touchscreen Pressure Register */
+#define	  ATMEL_TSADCC_PRESSR_Z1	(0x3ff <<  0)	/* Data of Z1 Measurement */
+#define	  ATMEL_TSADCC_PRESSR_Z2	(0x3ff << 16)	/* Data of Z2 Measurement */
+
+/* 9x5 ADC registers which conflict with previous definition */
+#ifdef CONFIG_ARCH_AT91SAM9X5
+#undef	 ATMEL_TSADCC_TRGR
+#undef	 ATMEL_TSADCC_SR
+#define ATMEL_TSADCC_SR		ATMEL_TSADCC_ISR
+#define ATMEL_TSADCC_TRGR	0xc0
+
+/* For code compatiable, redefine with 9x5 value */
+#undef	  ATMEL_TSADCC_STARTUP
+#define	  ATMEL_TSADCC_STARTUP		(0x0f << 16)	/* Startup Time */
+#undef	  ATMEL_TSADCC_DRDY
+#define	  ATMEL_TSADCC_DRDY		(1 << 24)	/* Data Ready */
+#undef	  ATMEL_TSADCC_GOVRE
+#define	  ATMEL_TSADCC_GOVRE		(1 << 25)	/* General Overrun */
+#undef	  ATMEL_TSADCC_TSFREQ
+#define	  ATMEL_TSADCC_TSFREQ		(0x0f <<  8)	/* Touch Screen Frequency */
+#undef	  ATMEL_TSADCC_PENDET
+#define	  ATMEL_TSADCC_PENDET		(1 << 24)	/* Pen Contact Detection Enable */
+#undef	  ATMEL_TSADCC_XPOS
+#define	  ATMEL_TSADCC_XPOS		(0x3ff <<  0)	/* X Position */
+
+#undef	  ATMEL_TSADCC_NOCNT
+#define	  ATMEL_TSADCC_NOCNT	ATMEL_TSADCC_NOPEN
+#undef	  ATMEL_TSADCC_PENCNT
+#define	  ATMEL_TSADCC_PENCNT	ATMEL_TSADCC_PEN
+#undef	  ATMEL_TSADCC_CONVERSION_END
+#define	  ATMEL_TSADCC_CONVERSION_END	(ATMEL_TSADCC_XRDY | ATMEL_TSADCC_YRDY | ATMEL_TSADCC_PRDY)
+
+#endif
+
+/* Retrieve prescaler value */
+#define PRESCALER_VAL(x)	((x) >> 8)
+
+#endif /* __ATMEL_TSADCC_H__ */
Index: linux-2.6.35/drivers/input/keyboard/Kconfig
===================================================================
--- linux-2.6.35/drivers/input/keyboard/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/input/keyboard/Kconfig	(revision 150)
@@ -124,6 +124,16 @@
 	  right-hand column will be interpreted as the key shown in the
 	  left-hand column.
 
+config KEYBOARD_QT1070
+        tristate "Atmel AT42QT1070 Touch Sensor Chip"
+        depends on I2C && EXPERIMENTAL
+        help
+          If you say yes here you get support for Atmel AT42QT1070 Touch
+          Sensor chip as a keyboard input.
+
+          This driver can also be built as a module. If so, the module
+          will be called qt1070.
+
 config KEYBOARD_QT2160
 	tristate "Atmel AT42QT2160 Touch Sensor Chip"
 	depends on I2C && EXPERIMENTAL
Index: linux-2.6.35/drivers/input/keyboard/qt1070.c
===================================================================
--- linux-2.6.35/drivers/input/keyboard/qt1070.c	(revision 0)
+++ linux-2.6.35/drivers/input/keyboard/qt1070.c	(revision 150)
@@ -0,0 +1,368 @@
+/*
+ *  qt1070.c - Atmel AT42QT1070 Touch Sense Controller
+ *
+ *  Copyright (C) 2010 Shen Bo <voice.shen@atmel.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/slab.h>
+#include <linux/irq.h>
+#include <linux/interrupt.h>
+#include <linux/jiffies.h>
+#include <linux/delay.h>
+
+/* QT1070 I2C Slave Address */
+#define QT1070_ADDR	0x1B
+
+/* Address for each register */
+#define CHIP_ID			0x00
+#define		QT1070_CHIP_ID		0x2E
+
+#define FW_VERSION		0x01
+#define		QT1070_FW_VERSION	0x15
+
+#define DET_STATUS		0x02
+#define		CALIBRATE	0x80
+#define		OVER_FLOW	0x40
+#define		COMMS_EN	0x20
+#define		TOUCH		0x01
+
+#define KEY_STATUS		0x03
+#define 		KEY0		0x01
+#define 		KEY1		0x02
+#define 		KEY2		0x04
+#define 		KEY3		0x08
+#define 		KEY4		0x10
+#define 		KEY5		0x20
+#define 		KEY6		0x40
+
+/* Negative Threshold */
+#define NTHR_KEY0		0x20	//32
+#define NTHR_KEY1		0x21	//33
+#define NTHR_KEY2		0x22	//34
+#define NTHR_KEY3		0x23	//35
+#define NTHR_KEY4		0x24	//36
+#define NTHR_KEY5		0x25	//37
+#define NTHR_KEY6		0x26	//38
+
+/* Averaging Factor/Adjacent Key Suppression */
+#define AVE_AKS_KEY0	0x27
+#define AVE_AKS_KEY1	0x28
+#define AVE_AKS_KEY2	0x29
+#define AVE_AKS_KEY3	0x2A
+#define AVE_AKS_KEY4	0x2B
+#define AVE_AKS_KEY5	0x2C
+#define AVE_AKS_KEY6	0x2D
+#define		AKS0		0x01
+#define		AKS1		0x02
+#define		AVE0		0x04
+#define		AVE1		0x08
+#define		AVE2		0x10
+#define		AVE3		0x20
+#define		AVE4		0x40
+#define		AVE5		0x80
+
+/* Detection Integrator */
+#define DI_KEY0			0x2E
+#define DI_KEY1			0x2F
+#define DI_KEY2			0x30
+#define DI_KEY3			0x31
+#define DI_KEY4			0x32
+#define DI_KEY5			0x33
+#define DI_KEY6			0x34
+
+/* Max Cal/Guard Channel */
+#define MAX_GUARD		0x35
+#define		MAX_CAL	0x10
+
+/* Low power Mode */
+#define LP_MODE			0x36
+
+/* Max On Duration */
+#define MAX_ON_DU		0x37
+
+/* Calibrate */
+#define CALIBRATE_CMD	0x38
+
+/* Reset */
+#define nRESET			0x39
+
+static unsigned char qt1070_key2code[] = {
+	KEY_VOLUMEDOWN, KEY_VOLUMEUP, KEY_HOME, KEY_BACK,
+	KEY_4, KEY_5, KEY_6,
+};
+
+struct qt1070_data {
+	struct i2c_client *client;
+	struct input_dev *input;
+	struct delayed_work dwork;
+	spinlock_t lock;
+	unsigned char keycodes[ARRAY_SIZE(qt1070_key2code)];
+	unsigned char key;
+};
+
+static int qt1070_read(struct i2c_client *client, u8 reg)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte(client, reg);
+	if (ret) {
+		dev_err(&client->dev, "can not send request, returned %d\n", ret);
+		return ret;
+	}
+
+	ret = i2c_smbus_read_byte(client);
+	if (ret < 0) {
+		dev_err(&client->dev, "can not read register, returned %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int qt1070_write(struct i2c_client *client, u8 reg, u8 data)
+{
+	int ret;
+
+	ret = i2c_smbus_write_byte(client, reg);
+	if (ret) {
+		dev_err(&client->dev, "can not send request, returned %d\n", ret);
+		return ret;
+	}
+
+	ret = i2c_smbus_write_byte(client, data);
+	if (ret) {
+		dev_err(&client->dev, "can not write register, returned %d\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static bool __devinit qt1070_identify(struct i2c_client *client)
+{
+	int id, ver;
+
+	/* Read Chip ID */
+	id = qt1070_read(client, CHIP_ID);
+	if (id != QT1070_CHIP_ID) {
+		dev_err(&client->dev, "ID %d not supported\n", id);
+		return false;
+	}
+
+	ver = qt1070_read(client, FW_VERSION);
+	if (ver < 0) {
+		dev_err(&client->dev, "could not read the firmware version\n");
+		return false;
+	}
+
+	dev_info(&client->dev, "AT42QT1070 firmware version %x\n", ver);
+
+	return true;
+}
+
+static int qt1070_read_key(struct qt1070_data *data)
+{
+	struct i2c_client *client = data->client;
+	struct input_dev *input = data->input;
+	u8 new_key, old_key, keyval;
+	int ret, i, mask;
+
+	/* Read the detected status register */
+	ret = qt1070_read(client, DET_STATUS);
+
+	/* Read which key changed */
+	ret = qt1070_read(client, KEY_STATUS);
+	old_key = data->key;
+	data->key = new_key = ret;
+
+	mask = 0x01;
+	for (i = 0; i < 7; i++) {
+		keyval = new_key & mask;
+		if ((old_key & mask) != keyval) {
+			input_report_key(input, data->keycodes[i], keyval);
+		}
+		mask <<= 1;
+	}
+	input_sync(input);
+
+	return 0;
+}
+
+static irqreturn_t qt1070_irq(int irq, void *data)
+{
+	struct qt1070_data *qt1070 = data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&qt1070->lock, flags);
+
+	cancel_delayed_work(&qt1070->dwork);
+	schedule_delayed_work(&qt1070->dwork, 0);
+
+	spin_unlock_irqrestore(&qt1070->lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static void qt1070_schedule_read(struct qt1070_data *data)
+{
+	spin_lock_irq(&data->lock);
+	schedule_delayed_work(&data->dwork, 0);
+	spin_unlock_irq(&data->lock);
+}
+
+static void qt1070_worker(struct delayed_work *work)
+{
+	struct qt1070_data *data = container_of(work, struct qt1070_data, dwork.work);
+	qt1070_read_key(data);
+}
+
+static int __devinit qt1070_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct qt1070_data *data;
+	struct input_dev *input;
+	int i;
+	int err;
+
+	err = i2c_check_functionality(client->adapter, I2C_FUNC_SMBUS_BYTE); /*return 1 if support */
+	if (!err) {
+		dev_err(&client->dev, "%s adapter not supported\n", dev_driver_string(&client->adapter->dev));
+		return -ENODEV;
+	}
+
+	/* identify the qt1070 chip */
+	if (!qt1070_identify(client))
+		return -ENODEV;
+
+	data = kzalloc(sizeof(struct qt1070_data), GFP_KERNEL);
+	input = input_allocate_device();
+	if (!data || !input) {
+		dev_err(&client->dev, "insufficient memory\n");
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	data->client = client;
+	data->input = input;
+	INIT_DELAYED_WORK(&data->dwork, qt1070_worker);
+	spin_lock_init(&data->lock);
+
+	input->name = "AT42QT1070 Touch Sense Keyboard";
+	input->id.bustype = BUS_I2C;
+
+	/* Add the keycode */
+	input->keycode = data->keycodes;
+	input->keycodesize = sizeof(data->keycodes[0]);
+	input->keycodemax = ARRAY_SIZE(qt1070_key2code);
+
+	__set_bit(EV_KEY, input->evbit);
+	__clear_bit(EV_REP, input->evbit);
+	for (i = 0; i < ARRAY_SIZE(qt1070_key2code); i++) {
+		data->keycodes[i] = qt1070_key2code[i];
+		__set_bit(qt1070_key2code[i], input->keybit);
+	}
+
+	__clear_bit(KEY_RESERVED, input->keybit);
+
+	/* Calibrate device */
+	err = qt1070_write(client, CALIBRATE_CMD, 1);
+	if (err) {
+		dev_err(&client->dev, "Failure to calibrate device\n");
+		goto err_free_mem;
+	}
+	msleep(100);
+
+	if (client->irq) {
+		err = request_irq(client->irq, qt1070_irq, 0, "qt1070", data);
+		if (err) {
+			dev_err(&client->dev, "fail to request irq\n");
+			goto err_free_mem;
+		}
+	}
+
+	/* register the input device */
+	err = input_register_device(data->input);
+	if (err) {
+		dev_err(&client->dev, "Failed to register input device\n");
+		goto err_free_irq;
+	}
+
+	i2c_set_clientdata(client, data);
+
+	/* read to clear the chang line */
+	qt1070_schedule_read(data);
+
+	return 0;
+
+err_free_irq:
+	if (client->irq)
+		free_irq(client->irq, data);
+err_free_mem:
+	input_free_device(input);
+	kfree(data);
+	return err;
+}
+
+static int __devexit qt1070_remove(struct i2c_client *client)
+{
+	struct qt1070_data *data = i2c_get_clientdata(client);
+
+	/* Release IRQ */
+	if (client->irq)
+		free_irq(client->irq, data);
+
+	input_unregister_device(data->input);
+	kfree(data);
+
+	i2c_set_clientdata(client, NULL);
+
+	return 0;
+}
+
+static const struct i2c_device_id qt1070_id[] = {
+	{ "qt1070", 0 },
+	{ },
+};
+
+static struct i2c_driver qt1070_driver = {
+	.driver = {
+		.name = "qt1070",
+		.owner = THIS_MODULE,
+	},
+	.id_table	= qt1070_id,
+	.probe = qt1070_probe,
+	.remove = __devexit_p(qt1070_remove),
+};
+
+static int __init qt1070_init(void)
+{
+	return i2c_add_driver(&qt1070_driver);
+}
+module_init(qt1070_init);
+
+static void __exit qt1070_exit(void)
+{
+	i2c_del_driver(&qt1070_driver);
+}
+module_exit(qt1070_exit);
+
+MODULE_AUTHOR("Shen Bo <voice.shen@atmel.com>");
+MODULE_DESCRIPTION("Driver for AT42QT1070 Touch sensor");
+MODULE_LICENSE("GPL");
Index: linux-2.6.35/drivers/input/keyboard/Makefile
===================================================================
--- linux-2.6.35/drivers/input/keyboard/Makefile	(revision 149)
+++ linux-2.6.35/drivers/input/keyboard/Makefile	(revision 150)
@@ -32,6 +32,7 @@
 obj-$(CONFIG_KEYBOARD_PXA27x)		+= pxa27x_keypad.o
 obj-$(CONFIG_KEYBOARD_PXA930_ROTARY)	+= pxa930_rotary.o
 obj-$(CONFIG_KEYBOARD_QT2160)		+= qt2160.o
+obj-$(CONFIG_KEYBOARD_QT1070)           += qt1070.o
 obj-$(CONFIG_KEYBOARD_SH_KEYSC)		+= sh_keysc.o
 obj-$(CONFIG_KEYBOARD_STOWAWAY)		+= stowaway.o
 obj-$(CONFIG_KEYBOARD_SUNKBD)		+= sunkbd.o
Index: linux-2.6.35/drivers/video/atmel_lcdfb.c
===================================================================
--- linux-2.6.35/drivers/video/atmel_lcdfb.c	(revision 149)
+++ linux-2.6.35/drivers/video/atmel_lcdfb.c	(revision 150)
@@ -1,7 +1,7 @@
 /*
  *  Driver for AT91/AT32 LCD Controller
  *
- *  Copyright (C) 2007 Atmel Corporation
+ *  Copyright (C) 2007-2010 Atmel Corporation
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file COPYING in the main directory of this archive for
@@ -24,6 +24,7 @@
 #include <mach/gpio.h>
 
 #include <video/atmel_lcdc.h>
+#include <mach/atmel_hlcdfb.h>
 
 #define lcdc_readl(sinfo, reg)		__raw_readl((sinfo)->mmio+(reg))
 #define lcdc_writel(sinfo, reg, val)	__raw_writel((val), (sinfo)->mmio+(reg))
@@ -72,6 +73,9 @@
 		| ATMEL_LCDC_POL_POSITIVE
 		| ATMEL_LCDC_ENA_PWMENABLE;
 
+static const u32 contrast_pwm_ctr = LCDC_LCDCFG6_PWMPOL
+		| (ATMEL_LCDC_CVAL_DEFAULT << LCDC_LCDCFG6_PWMCVAL_OFFSET);
+
 #ifdef CONFIG_BACKLIGHT_ATMEL_LCDC
 
 /* some bl->props field just changed */
@@ -80,6 +84,7 @@
 	struct atmel_lcdfb_info *sinfo = bl_get_data(bl);
 	int			power = sinfo->bl_power;
 	int			brightness = bl->props.brightness;
+	u32			reg;
 
 	/* REVISIT there may be a meaningful difference between
 	 * fb_blank and power ... there seem to be some cases
@@ -90,14 +95,25 @@
 	else if (bl->props.power != sinfo->bl_power)
 		power = bl->props.power;
 
-	if (brightness < 0 && power == FB_BLANK_UNBLANK)
-		brightness = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
-	else if (power != FB_BLANK_UNBLANK)
+	if (brightness < 0 && power == FB_BLANK_UNBLANK) {
+		if (cpu_is_at91sam9x5())
+			brightness = lcdc_readl(sinfo, ATMEL_LCDC_LCDCFG6)
+				     >> LCDC_LCDCFG6_PWMCVAL_OFFSET;
+		else
+			brightness = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
+	} else if (power != FB_BLANK_UNBLANK) {
 		brightness = 0;
+	}
 
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, brightness);
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR,
-			brightness ? contrast_ctr : 0);
+	if (cpu_is_at91sam9x5()) {
+		reg = lcdc_readl(sinfo, ATMEL_LCDC_LCDCFG6) & ~LCDC_LCDCFG6_PWMCVAL;
+		reg |= brightness << LCDC_LCDCFG6_PWMCVAL_OFFSET;
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG6, reg);
+	} else {
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, brightness);
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR,
+				brightness ? contrast_ctr : 0);
+	}
 
 	bl->props.fb_blank = bl->props.power = sinfo->bl_power = power;
 
@@ -108,7 +124,10 @@
 {
 	struct atmel_lcdfb_info *sinfo = bl_get_data(bl);
 
-	return lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
+	if (cpu_is_at91sam9x5())
+		return lcdc_readl(sinfo, ATMEL_LCDC_LCDCFG6) >> LCDC_LCDCFG6_PWMCVAL_OFFSET;
+	else
+		return lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
 }
 
 static struct backlight_ops atmel_lcdc_bl_ops = {
@@ -163,10 +182,14 @@
 
 static void init_contrast(struct atmel_lcdfb_info *sinfo)
 {
-	/* have some default contrast/backlight settings */
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, contrast_ctr);
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, ATMEL_LCDC_CVAL_DEFAULT);
-
+	if (cpu_is_at91sam9x5()) {
+		/* have some default contrast/backlight settings */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG6, contrast_pwm_ctr);
+	} else {
+		/* have some default contrast/backlight settings */
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, contrast_ctr);
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_VAL, ATMEL_LCDC_CVAL_DEFAULT);
+	}
 	if (sinfo->lcdcon_is_backlight)
 		init_backlight(sinfo);
 }
@@ -208,32 +231,78 @@
 
 static void atmel_lcdfb_stop_nowait(struct atmel_lcdfb_info *sinfo)
 {
-	/* Turn off the LCD controller and the DMA controller */
-	lcdc_writel(sinfo, ATMEL_LCDC_PWRCON,
-			sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET);
+	if (cpu_is_at91sam9x5()) {
+		/* Disable DISP signal */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDDIS, LCDC_LCDDIS_DISPDIS);
+		while ((lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_DISPSTS))
+			msleep(1);
+		/* Disable synchronization */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDDIS, LCDC_LCDDIS_SYNCDIS);
+		while ((lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_LCDSTS))
+			msleep(1);
+		/* Disable pixel clock */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDDIS, LCDC_LCDDIS_CLKDIS);
+		while ((lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_CLKSTS))
+			msleep(1);
+		/* Disable PWM */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDDIS, LCDC_LCDDIS_PWMDIS);
+		while ((lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_PWMSTS))
+			msleep(1);
+	} else {
+		/* Turn off the LCD controller and the DMA controller */
+		lcdc_writel(sinfo, ATMEL_LCDC_PWRCON,
+				sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET);
 
-	/* Wait for the LCDC core to become idle */
-	while (lcdc_readl(sinfo, ATMEL_LCDC_PWRCON) & ATMEL_LCDC_BUSY)
-		msleep(10);
+		/* Wait for the LCDC core to become idle */
+		while (lcdc_readl(sinfo, ATMEL_LCDC_PWRCON) & ATMEL_LCDC_BUSY)
+			msleep(10);
 
-	lcdc_writel(sinfo, ATMEL_LCDC_DMACON, 0);
+		lcdc_writel(sinfo, ATMEL_LCDC_DMACON, 0);
+	}
 }
 
 static void atmel_lcdfb_stop(struct atmel_lcdfb_info *sinfo)
 {
 	atmel_lcdfb_stop_nowait(sinfo);
 
-	/* Wait for DMA engine to become idle... */
-	while (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)
-		msleep(10);
+	if (cpu_is_at91sam9x5()) {
+		/* Wait for the end of DMA transfer */
+		while (!(lcdc_readl(sinfo, ATMEL_LCDC_BASEISR) & LCDC_BASEISR_DMA))
+			msleep(10);
+	} else {
+		/* Wait for DMA engine to become idle... */
+		while (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)
+			msleep(10);
+	}
 }
 
 static void atmel_lcdfb_start(struct atmel_lcdfb_info *sinfo)
 {
-	lcdc_writel(sinfo, ATMEL_LCDC_DMACON, sinfo->default_dmacon);
-	lcdc_writel(sinfo, ATMEL_LCDC_PWRCON,
-		(sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET)
-		| ATMEL_LCDC_PWR);
+	u32	value;
+
+	if (cpu_is_at91sam9x5()) {
+		value = lcdc_readl(sinfo, ATMEL_LCDC_LCDEN);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDEN, value | LCDC_LCDEN_CLKEN);
+		while (!(lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_CLKSTS))
+			msleep(1);
+		value = lcdc_readl(sinfo, ATMEL_LCDC_LCDEN);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDEN, value | LCDC_LCDEN_SYNCEN);
+		while (!(lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_LCDSTS))
+			msleep(1);
+		value = lcdc_readl(sinfo, ATMEL_LCDC_LCDEN);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDEN, value | LCDC_LCDEN_DISPEN);
+		while (!(lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_DISPSTS))
+			msleep(1);
+		value = lcdc_readl(sinfo, ATMEL_LCDC_LCDEN);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDEN, value | LCDC_LCDEN_PWMEN);
+		while (!(lcdc_readl(sinfo, ATMEL_LCDC_LCDSR) & LCDC_LCDSR_PWMSTS))
+			msleep(1);
+	} else {
+		lcdc_writel(sinfo, ATMEL_LCDC_DMACON, sinfo->default_dmacon);
+		lcdc_writel(sinfo, ATMEL_LCDC_PWRCON,
+			(sinfo->guard_time << ATMEL_LCDC_GUARDT_OFFSET)
+			| ATMEL_LCDC_PWR);
+	}
 }
 
 static void atmel_lcdfb_update_dma(struct fb_info *info,
@@ -242,15 +311,32 @@
 	struct atmel_lcdfb_info *sinfo = info->par;
 	struct fb_fix_screeninfo *fix = &info->fix;
 	unsigned long dma_addr;
+	struct lcd_dma_desc *desc;
 
 	dma_addr = (fix->smem_start + var->yoffset * fix->line_length
 		    + var->xoffset * var->bits_per_pixel / 8);
 
 	dma_addr &= ~3UL;
 
-	/* Set framebuffer DMA base address and pixel offset */
-	lcdc_writel(sinfo, ATMEL_LCDC_DMABADDR1, dma_addr);
+	if (cpu_is_at91sam9x5()) {
+		/* Setup the DMA descriptor, this descriptor will loop to itself */
+		desc = (struct lcd_dma_desc *)sinfo->p_dma_desc;
 
+		desc->address = dma_addr;
+		/* Disable DMA transfer interrupt & descriptor loaded interrupt. */
+		desc->control = LCDC_BASECTRL_ADDIEN | LCDC_BASECTRL_DSCRIEN
+				| LCDC_BASECTRL_DMAIEN | LCDC_BASECTRL_DFETCH;
+		desc->next = sinfo->dma_desc_phys;
+
+		lcdc_writel(sinfo, ATMEL_LCDC_BASEADDR, dma_addr);
+		lcdc_writel(sinfo, ATMEL_LCDC_BASECTRL, desc->control);
+		lcdc_writel(sinfo, ATMEL_LCDC_BASENEXT, sinfo->dma_desc_phys);
+		lcdc_writel(sinfo, ATMEL_LCDC_BASECHER, LCDC_BASECHER_CHEN | LCDC_BASECHER_UPDATEEN);
+	} else {
+		/* Set framebuffer DMA base address and pixel offset */
+		lcdc_writel(sinfo, ATMEL_LCDC_DMABADDR1, dma_addr);
+	}
+
 	atmel_lcdfb_update_dma2d(sinfo, var);
 }
 
@@ -260,12 +346,18 @@
 
 	dma_free_writecombine(info->device, info->fix.smem_len,
 				info->screen_base, info->fix.smem_start);
+
+	if (cpu_is_at91sam9x5()) {
+		if (sinfo->p_dma_desc)
+			dma_free_writecombine(info->device, sizeof(struct lcd_dma_desc),
+						sinfo->p_dma_desc, sinfo->dma_desc_phys);
+	}
 }
 
 /**
  *	atmel_lcdfb_alloc_video_memory - Allocate framebuffer memory
  *	@sinfo: the frame buffer to allocate memory for
- * 	
+ *
  * 	This function is called only from the atmel_lcdfb_probe()
  * 	so no locking by fb_info->mm_lock around smem_len setting is needed.
  */
@@ -288,6 +380,19 @@
 
 	memset(info->screen_base, 0, info->fix.smem_len);
 
+	if (cpu_is_at91sam9x5()) {
+		sinfo->p_dma_desc = dma_alloc_writecombine(info->device,
+						sizeof(struct lcd_dma_desc),
+						(dma_addr_t *)&(sinfo->dma_desc_phys),
+						GFP_KERNEL);
+
+		if (!sinfo->p_dma_desc) {
+			dma_free_writecombine(info->device, info->fix.smem_len,
+						info->screen_base, info->fix.smem_start);
+			return -ENOMEM;
+		}
+	}
+
 	return 0;
 }
 
@@ -381,18 +486,33 @@
 	}
 
 	/* Saturate vertical and horizontal timings at maximum values */
-	var->vsync_len = min_t(u32, var->vsync_len,
-			(ATMEL_LCDC_VPW >> ATMEL_LCDC_VPW_OFFSET) + 1);
-	var->upper_margin = min_t(u32, var->upper_margin,
-			ATMEL_LCDC_VBP >> ATMEL_LCDC_VBP_OFFSET);
-	var->lower_margin = min_t(u32, var->lower_margin,
-			ATMEL_LCDC_VFP);
-	var->right_margin = min_t(u32, var->right_margin,
-			(ATMEL_LCDC_HFP >> ATMEL_LCDC_HFP_OFFSET) + 1);
-	var->hsync_len = min_t(u32, var->hsync_len,
-			(ATMEL_LCDC_HPW >> ATMEL_LCDC_HPW_OFFSET) + 1);
-	var->left_margin = min_t(u32, var->left_margin,
-			ATMEL_LCDC_HBP + 1);
+	if (cpu_is_at91sam9x5()) {
+		var->vsync_len = min_t(u32, var->vsync_len,
+				(LCDC_LCDCFG1_VSPW >> LCDC_LCDCFG1_VSPW_OFFSET) + 1);
+		var->upper_margin = min_t(u32, var->upper_margin,
+				(LCDC_LCDCFG2_VFPW >> LCDC_LCDCFG2_VFPW_OFFSET) + 1);
+		var->lower_margin = min_t(u32, var->lower_margin,
+				LCDC_LCDCFG2_VBPW >> LCDC_LCDCFG2_VBPW_OFFSET);
+		var->right_margin = min_t(u32, var->right_margin,
+				(LCDC_LCDCFG3_HBPW >> LCDC_LCDCFG3_HBPW_OFFSET) + 1);
+		var->hsync_len = min_t(u32, var->hsync_len,
+				(LCDC_LCDCFG1_HSPW >> LCDC_LCDCFG1_HSPW_OFFSET) + 1);
+		var->left_margin = min_t(u32, var->left_margin,
+				(LCDC_LCDCFG3_HFPW >> LCDC_LCDCFG3_HFPW_OFFSET) + 1);
+	} else {
+		var->vsync_len = min_t(u32, var->vsync_len,
+				(ATMEL_LCDC_VPW >> ATMEL_LCDC_VPW_OFFSET) + 1);
+		var->upper_margin = min_t(u32, var->upper_margin,
+				ATMEL_LCDC_VBP >> ATMEL_LCDC_VBP_OFFSET);
+		var->lower_margin = min_t(u32, var->lower_margin,
+				ATMEL_LCDC_VFP);
+		var->right_margin = min_t(u32, var->right_margin,
+				(ATMEL_LCDC_HFP >> ATMEL_LCDC_HFP_OFFSET) + 1);
+		var->hsync_len = min_t(u32, var->hsync_len,
+				(ATMEL_LCDC_HPW >> ATMEL_LCDC_HPW_OFFSET) + 1);
+		var->left_margin = min_t(u32, var->left_margin,
+				ATMEL_LCDC_HBP + 1);
+	}
 
 	/* Some parameters can't be zero */
 	var->vsync_len = max_t(u32, var->vsync_len, 1);
@@ -407,10 +527,53 @@
 	case 8:
 		var->red.offset = var->green.offset = var->blue.offset = 0;
 		var->red.length = var->green.length = var->blue.length
-			= var->bits_per_pixel;
+				= var->bits_per_pixel;
 		break;
+	case 12:
+		if (cpu_is_at91sam9x5()) {
+			/* RGB:444 mode */
+			var->red.offset = 8;
+			var->blue.offset = 0;
+			var->green.offset = 4;
+			var->red.length = var->green.length = var->blue.length = 4;
+		} else {
+			/*TODO: rework*/
+			BUG();
+		}
+		break;
 	case 15:
+		if (cpu_is_at91sam9x5()) {
+			/* RGB:555 mode */
+			var->red.offset = 10;
+			var->blue.offset = 0;
+			var->green.length = 5;
+			var->red.length = var->green.length = var->blue.length = 5;
+		} else {
+			/*TODO: rework*/
+			BUG();
+		}
+		break;
 	case 16:
+		if (cpu_is_at91sam9x5()) {
+			if (sinfo->alpha_enabled) {
+				/* ARGB:4444 mode */
+				var->red.offset = 8;
+				var->blue.offset = 0;
+				var->green.offset = 4;
+				var->transp.offset = 12;
+				var->red.length = var->green.length
+						= var->blue.length
+						= var->transp.length = 4;
+			} else {
+				/* RGB:565 mode */
+				var->red.offset = 11;
+				var->blue.offset = 0;
+				var->green.offset = 5;
+				var->green.length = 6;
+				var->red.length = var->blue.length = 5;
+			}
+			break;
+		}
 		if (sinfo->lcd_wiring_mode == ATMEL_LCDC_WIRING_RGB) {
 			/* RGB:565 mode */
 			var->red.offset = 11;
@@ -430,6 +593,7 @@
 		var->red.length = var->blue.length = 5;
 		break;
 	case 32:
+		/* TODO 32 & 24 modes */
 		var->transp.offset = 24;
 		var->transp.length = 8;
 		/* fall through */
@@ -466,6 +630,233 @@
 	atmel_lcdfb_start(sinfo);
 }
 
+static int atmel_lcdfb_setup_9x5_core(struct fb_info *info)
+{
+	struct atmel_lcdfb_info *sinfo = info->par;
+	unsigned long value;
+	unsigned long clk_value_khz;
+
+	dev_dbg(info->device, "%s:\n", __func__);
+	/* Set pixel clock */
+	clk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;
+
+	value = DIV_ROUND_UP(clk_value_khz, PICOS2KHZ(info->var.pixclock));
+
+	if (value < 1) {
+		dev_notice(info->device, "using system clock as pixel clock\n");
+		value = LCDC_LCDCFG0_CLKPOL | LCDC_LCDCFG0_CLKPWMSEL | LCDC_LCDCFG0_CGDISBASE;
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG0, value);
+	} else {
+		info->var.pixclock = KHZ2PICOS(clk_value_khz / value);
+		dev_dbg(info->device, "  updated pixclk:     %lu KHz\n",
+				PICOS2KHZ(info->var.pixclock));
+		value = value - 2;
+		dev_dbg(info->device, "  * programming CLKDIV = 0x%08lx\n",
+					value);
+		value = (value << LCDC_LCDCFG0_CLKDIV_OFFSET)
+			| LCDC_LCDCFG0_CLKPOL
+			| LCDC_LCDCFG0_CGDISBASE;
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG0, value);
+	}
+
+	/* Initialize control register 5 */
+	/* In 9x5, the default_lcdcon2 will use for LCDCFG5 */
+	value = sinfo->default_lcdcon2;
+	value |= (sinfo->guard_time << LCDC_LCDCFG5_GUARDTIME_OFFSET)
+		| LCDC_LCDCFG5_DISPDLY
+		| LCDC_LCDCFG5_VSPDLYS;
+
+	if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+		value |= LCDC_LCDCFG5_HSPOL;
+	if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+		value |= LCDC_LCDCFG5_VSPOL;
+
+	dev_dbg(info->device, "  * LCDC_LCDCFG5 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG5, value);
+
+	/* Vertical & Horizontal Timing */
+	value = (info->var.vsync_len - 1) << LCDC_LCDCFG1_VSPW_OFFSET;
+	value |= (info->var.hsync_len - 1) << LCDC_LCDCFG1_HSPW_OFFSET;
+	dev_dbg(info->device, "  * LCDC_LCDCFG1 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG1, value);
+
+	value = (info->var.lower_margin) << LCDC_LCDCFG2_VBPW_OFFSET;
+	value |= (info->var.upper_margin - 1) << LCDC_LCDCFG2_VFPW_OFFSET;
+	dev_dbg(info->device, "  * LCDC_LCDCFG2 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG2, value);
+
+	value = (info->var.right_margin - 1) << LCDC_LCDCFG3_HBPW_OFFSET;
+	value |= (info->var.left_margin - 1) << LCDC_LCDCFG3_HFPW_OFFSET;
+	dev_dbg(info->device, "  * LCDC_LCDCFG3 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG3, value);
+
+	/* Display size */
+	value = (info->var.yres - 1) << LCDC_LCDCFG4_RPF_OFFSET;
+	value |= (info->var.xres - 1) << LCDC_LCDCFG4_PPL_OFFSET;
+	dev_dbg(info->device, "  * LCDC_LCDCFG4 = %08lx\n", value);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDCFG4, value);
+
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECFG0, LCDC_BASECFG0_BLEN_AHB_INCR4 | LCDC_BASECFG0_DLBO);
+	switch (info->var.bits_per_pixel) {
+	case 12:
+		value = LCDC_BASECFG1_RGBMODE_12BPP_RGB_444;
+		break;
+	case 16:
+		if (info->var.transp.offset != 0)
+			value = LCDC_BASECFG1_RGBMODE_16BPP_ARGB_4444;
+		else
+			value = LCDC_BASECFG1_RGBMODE_16BPP_RGB_565;
+		break;
+	case 18:
+		value = LCDC_BASECFG1_RGBMODE_18BPP_RGB_666_PACKED;
+		break;
+	case 24:
+		value = LCDC_BASECFG1_RGBMODE_24BPP_RGB_888_PACKED;
+		break;
+	case 32:
+		value = LCDC_BASECFG1_RGBMODE_32BPP_ARGB_8888;
+		break;
+	default:
+		BUG();
+		break;
+	}
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECFG1, value);
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECFG2, 0);
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECFG3, 0);	/* Default color */
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECFG4, LCDC_BASECFG4_DMA);
+
+	/* Disable all interrupts */
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDIDR, ~0UL);
+	lcdc_writel(sinfo, ATMEL_LCDC_BASEIDR, ~0UL);
+	/* Enable BASE LAYER overflow interrupts, if want to enable DMA interrupt, also need set it at LCDC_BASECTRL reg */
+	lcdc_writel(sinfo, ATMEL_LCDC_BASEIER, LCDC_BASEIER_OVR);
+	lcdc_writel(sinfo, ATMEL_LCDC_LCDIER, LCDC_LCDIER_FIFOERRIE | LCDC_LCDIER_BASEIE);
+
+	return 0;
+}
+
+static int atmel_lcdfb_setup_core(struct fb_info *info)
+{
+	struct atmel_lcdfb_info *sinfo = info->par;
+	unsigned long hozval_linesz;
+	unsigned long value;
+	unsigned long clk_value_khz;
+	unsigned long pix_factor = 2;
+
+	if (cpu_is_at91sam9x5()) {
+		return atmel_lcdfb_setup_9x5_core(info);
+	} else {
+		/* ...set frame size and burst length = 8 words (?) */
+		value = (info->var.yres * info->var.xres * info->var.bits_per_pixel) / 32;
+		value |= ((ATMEL_LCDC_DMA_BURST_LEN - 1) << ATMEL_LCDC_BLENGTH_OFFSET);
+		lcdc_writel(sinfo, ATMEL_LCDC_DMAFRMCFG, value);
+
+		/* Set pixel clock */
+		if (cpu_is_at91sam9g45() && !cpu_is_at91sam9g45es())
+			pix_factor = 1;
+
+		clk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;
+
+		value = DIV_ROUND_UP(clk_value_khz, PICOS2KHZ(info->var.pixclock));
+
+		if (value < pix_factor) {
+			dev_notice(info->device, "Bypassing pixel clock divider\n");
+			lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1, ATMEL_LCDC_BYPASS);
+		} else {
+			value = (value / pix_factor) - 1;
+			dev_dbg(info->device, "  * programming CLKVAL = 0x%08lx\n",
+					value);
+			lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1,
+					value << ATMEL_LCDC_CLKVAL_OFFSET);
+			info->var.pixclock =
+				KHZ2PICOS(clk_value_khz / (pix_factor * (value + 1)));
+			dev_dbg(info->device, "  updated pixclk:     %lu KHz\n",
+						PICOS2KHZ(info->var.pixclock));
+		}
+
+
+		/* Initialize control register 2 */
+		value = sinfo->default_lcdcon2;
+
+		if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
+			value |= ATMEL_LCDC_INVLINE_INVERTED;
+		if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
+			value |= ATMEL_LCDC_INVFRAME_INVERTED;
+
+		switch (info->var.bits_per_pixel) {
+		case 1:
+			value |= ATMEL_LCDC_PIXELSIZE_1;
+			break;
+		case 2:
+			value |= ATMEL_LCDC_PIXELSIZE_2;
+			break;
+		case 4:
+			value |= ATMEL_LCDC_PIXELSIZE_4;
+			break;
+		case 8:
+			value |= ATMEL_LCDC_PIXELSIZE_8;
+			break;
+		case 15: /* fall through */
+		case 16:
+			value |= ATMEL_LCDC_PIXELSIZE_16;
+			break;
+		case 24:
+			value |= ATMEL_LCDC_PIXELSIZE_24;
+			break;
+		case 32:
+			value |= ATMEL_LCDC_PIXELSIZE_32;
+			break;
+		default:
+			BUG();
+			break;
+		}
+		dev_dbg(info->device, "  * LCDCON2 = %08lx\n", value);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDCON2, value);
+
+		/* Vertical timing */
+		value = (info->var.vsync_len - 1) << ATMEL_LCDC_VPW_OFFSET;
+		value |= info->var.upper_margin << ATMEL_LCDC_VBP_OFFSET;
+		value |= info->var.lower_margin;
+		dev_dbg(info->device, "  * LCDTIM1 = %08lx\n", value);
+		lcdc_writel(sinfo, ATMEL_LCDC_TIM1, value);
+
+		/* Horizontal timing */
+		value = (info->var.right_margin - 1) << ATMEL_LCDC_HFP_OFFSET;
+		value |= (info->var.hsync_len - 1) << ATMEL_LCDC_HPW_OFFSET;
+		value |= (info->var.left_margin - 1);
+		dev_dbg(info->device, "  * LCDTIM2 = %08lx\n", value);
+		lcdc_writel(sinfo, ATMEL_LCDC_TIM2, value);
+
+		/* Horizontal value (aka line size) */
+		hozval_linesz = compute_hozval(info->var.xres,
+					lcdc_readl(sinfo, ATMEL_LCDC_LCDCON2));
+
+		/* Display size */
+		value = (hozval_linesz - 1) << ATMEL_LCDC_HOZVAL_OFFSET;
+		value |= info->var.yres - 1;
+		dev_dbg(info->device, "  * LCDFRMCFG = %08lx\n", value);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDFRMCFG, value);
+
+		/* FIFO Threshold: Use formula from data sheet */
+		value = ATMEL_LCDC_FIFO_SIZE - (2 * ATMEL_LCDC_DMA_BURST_LEN + 3);
+		lcdc_writel(sinfo, ATMEL_LCDC_FIFO, value);
+
+		/* Toggle LCD_MODE every frame */
+		lcdc_writel(sinfo, ATMEL_LCDC_MVAL, 0);
+
+		/* Disable all interrupts */
+		lcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);
+		/* Enable FIFO & DMA errors */
+		lcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI | ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);
+
+		/* ...wait for DMA engine to become idle... */
+		while (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)
+			msleep(10);
+
+		return 0;
+	}
+}
+
 /**
  *      atmel_lcdfb_set_par - Alters the hardware state.
  *      @info: frame buffer structure that represents a single frame buffer
@@ -483,11 +874,7 @@
 static int atmel_lcdfb_set_par(struct fb_info *info)
 {
 	struct atmel_lcdfb_info *sinfo = info->par;
-	unsigned long hozval_linesz;
-	unsigned long value;
-	unsigned long clk_value_khz;
 	unsigned long bits_per_line;
-	unsigned long pix_factor = 2;
 
 	might_sleep();
 
@@ -512,99 +899,9 @@
 	dev_dbg(info->device, "  * update DMA engine\n");
 	atmel_lcdfb_update_dma(info, &info->var);
 
-	/* ...set frame size and burst length = 8 words (?) */
-	value = (info->var.yres * info->var.xres * info->var.bits_per_pixel) / 32;
-	value |= ((ATMEL_LCDC_DMA_BURST_LEN - 1) << ATMEL_LCDC_BLENGTH_OFFSET);
-	lcdc_writel(sinfo, ATMEL_LCDC_DMAFRMCFG, value);
-
 	/* Now, the LCDC core... */
+	atmel_lcdfb_setup_core(info);
 
-	/* Set pixel clock */
-	if (cpu_is_at91sam9g45() && !cpu_is_at91sam9g45es())
-		pix_factor = 1;
-
-	clk_value_khz = clk_get_rate(sinfo->lcdc_clk) / 1000;
-
-	value = DIV_ROUND_UP(clk_value_khz, PICOS2KHZ(info->var.pixclock));
-
-	if (value < pix_factor) {
-		dev_notice(info->device, "Bypassing pixel clock divider\n");
-		lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1, ATMEL_LCDC_BYPASS);
-	} else {
-		value = (value / pix_factor) - 1;
-		dev_dbg(info->device, "  * programming CLKVAL = 0x%08lx\n",
-				value);
-		lcdc_writel(sinfo, ATMEL_LCDC_LCDCON1,
-				value << ATMEL_LCDC_CLKVAL_OFFSET);
-		info->var.pixclock =
-			KHZ2PICOS(clk_value_khz / (pix_factor * (value + 1)));
-		dev_dbg(info->device, "  updated pixclk:     %lu KHz\n",
-					PICOS2KHZ(info->var.pixclock));
-	}
-
-
-	/* Initialize control register 2 */
-	value = sinfo->default_lcdcon2;
-
-	if (!(info->var.sync & FB_SYNC_HOR_HIGH_ACT))
-		value |= ATMEL_LCDC_INVLINE_INVERTED;
-	if (!(info->var.sync & FB_SYNC_VERT_HIGH_ACT))
-		value |= ATMEL_LCDC_INVFRAME_INVERTED;
-
-	switch (info->var.bits_per_pixel) {
-		case 1:	value |= ATMEL_LCDC_PIXELSIZE_1; break;
-		case 2: value |= ATMEL_LCDC_PIXELSIZE_2; break;
-		case 4: value |= ATMEL_LCDC_PIXELSIZE_4; break;
-		case 8: value |= ATMEL_LCDC_PIXELSIZE_8; break;
-		case 15: /* fall through */
-		case 16: value |= ATMEL_LCDC_PIXELSIZE_16; break;
-		case 24: value |= ATMEL_LCDC_PIXELSIZE_24; break;
-		case 32: value |= ATMEL_LCDC_PIXELSIZE_32; break;
-		default: BUG(); break;
-	}
-	dev_dbg(info->device, "  * LCDCON2 = %08lx\n", value);
-	lcdc_writel(sinfo, ATMEL_LCDC_LCDCON2, value);
-
-	/* Vertical timing */
-	value = (info->var.vsync_len - 1) << ATMEL_LCDC_VPW_OFFSET;
-	value |= info->var.upper_margin << ATMEL_LCDC_VBP_OFFSET;
-	value |= info->var.lower_margin;
-	dev_dbg(info->device, "  * LCDTIM1 = %08lx\n", value);
-	lcdc_writel(sinfo, ATMEL_LCDC_TIM1, value);
-
-	/* Horizontal timing */
-	value = (info->var.right_margin - 1) << ATMEL_LCDC_HFP_OFFSET;
-	value |= (info->var.hsync_len - 1) << ATMEL_LCDC_HPW_OFFSET;
-	value |= (info->var.left_margin - 1);
-	dev_dbg(info->device, "  * LCDTIM2 = %08lx\n", value);
-	lcdc_writel(sinfo, ATMEL_LCDC_TIM2, value);
-
-	/* Horizontal value (aka line size) */
-	hozval_linesz = compute_hozval(info->var.xres,
-					lcdc_readl(sinfo, ATMEL_LCDC_LCDCON2));
-
-	/* Display size */
-	value = (hozval_linesz - 1) << ATMEL_LCDC_HOZVAL_OFFSET;
-	value |= info->var.yres - 1;
-	dev_dbg(info->device, "  * LCDFRMCFG = %08lx\n", value);
-	lcdc_writel(sinfo, ATMEL_LCDC_LCDFRMCFG, value);
-
-	/* FIFO Threshold: Use formula from data sheet */
-	value = ATMEL_LCDC_FIFO_SIZE - (2 * ATMEL_LCDC_DMA_BURST_LEN + 3);
-	lcdc_writel(sinfo, ATMEL_LCDC_FIFO, value);
-
-	/* Toggle LCD_MODE every frame */
-	lcdc_writel(sinfo, ATMEL_LCDC_MVAL, 0);
-
-	/* Disable all interrupts */
-	lcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);
-	/* Enable FIFO & DMA errors */
-	lcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI | ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);
-
-	/* ...wait for DMA engine to become idle... */
-	while (lcdc_readl(sinfo, ATMEL_LCDC_DMACON) & ATMEL_LCDC_DMABUSY)
-		msleep(10);
-
 	atmel_lcdfb_start(sinfo);
 
 	dev_dbg(info->device, "  * DONE\n");
@@ -726,14 +1023,32 @@
 	struct fb_info *info = dev_id;
 	struct atmel_lcdfb_info *sinfo = info->par;
 	u32 status;
+	u32 baselayer_status;
 
-	status = lcdc_readl(sinfo, ATMEL_LCDC_ISR);
-	if (status & ATMEL_LCDC_UFLWI) {
-		dev_warn(info->device, "FIFO underflow %#x\n", status);
-		/* reset DMA and FIFO to avoid screen shifting */
-		schedule_work(&sinfo->task);
+	if (cpu_is_at91sam9x5()) {
+		/* Check for error status via interrupt.*/
+		status = lcdc_readl(sinfo, ATMEL_LCDC_LCDISR);
+		if (status & LCDC_LCDISR_FIFOERR) {
+			dev_warn(info->device, "FIFO underflow %#x\n", status);
+		} else if (status & LCDC_LCDISR_BASE) {
+			/* Check base layer's overflow error. */
+			baselayer_status = lcdc_readl(sinfo, ATMEL_LCDC_BASEISR);
+
+			if (baselayer_status & LCDC_BASEISR_OVR)
+				dev_warn(info->device, "base layer overflow %#x\n",
+							baselayer_status);
+
+		}
+	} else {
+		status = lcdc_readl(sinfo, ATMEL_LCDC_ISR);
+		if (status & ATMEL_LCDC_UFLWI) {
+			dev_warn(info->device, "FIFO underflow %#x\n", status);
+			/* reset DMA and FIFO to avoid screen shifting */
+			schedule_work(&sinfo->task);
+		}
+		lcdc_writel(sinfo, ATMEL_LCDC_ICR, status);
 	}
-	lcdc_writel(sinfo, ATMEL_LCDC_ICR, status);
+
 	return IRQ_HANDLED;
 }
 
@@ -873,6 +1188,8 @@
 
 	/* Initialize video memory */
 	map = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	sinfo->p_dma_desc = NULL;
+	sinfo->dma_desc_phys = 0;
 	if (map) {
 		/* use a pre-allocated memory buffer */
 		info->fix.smem_start = map->start;
@@ -983,7 +1300,7 @@
 	exit_backlight(sinfo);
 	iounmap(sinfo->mmio);
 release_mem:
- 	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
 free_fb:
 	if (map)
 		iounmap(info->screen_base);
@@ -1028,7 +1345,7 @@
 	fb_dealloc_cmap(&info->cmap);
 	free_irq(sinfo->irq_base, info);
 	iounmap(sinfo->mmio);
- 	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
+	release_mem_region(info->fix.mmio_start, info->fix.mmio_len);
 	if (platform_get_resource(pdev, IORESOURCE_MEM, 1)) {
 		iounmap(info->screen_base);
 		release_mem_region(info->fix.smem_start, info->fix.smem_len);
@@ -1053,10 +1370,19 @@
 	 * We don't want to handle interrupts while the clock is
 	 * stopped. It may take forever.
 	 */
-	lcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);
+	if (cpu_is_at91sam9x5()) {
+		/* Disabel  DMA */
+		lcdc_writel(sinfo, ATMEL_LCDC_BASECHDR, LCDC_BASECHDR_CHDIS);
+		/* Disable all interrupts */
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDIDR, ~0UL);
+		lcdc_writel(sinfo, ATMEL_LCDC_BASEIDR, ~0UL);
+	} else {
+		lcdc_writel(sinfo, ATMEL_LCDC_IDR, ~0UL);
 
-	sinfo->saved_lcdcon = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, 0);
+		sinfo->saved_lcdcon = lcdc_readl(sinfo, ATMEL_LCDC_CONTRAST_VAL);
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, 0);
+	}
+
 	if (sinfo->atmel_lcdfb_power_control)
 		sinfo->atmel_lcdfb_power_control(0);
 
@@ -1070,17 +1396,32 @@
 {
 	struct fb_info *info = platform_get_drvdata(pdev);
 	struct atmel_lcdfb_info *sinfo = info->par;
-
+	int ret;
+	
 	atmel_lcdfb_start_clock(sinfo);
 	atmel_lcdfb_start(sinfo);
 	if (sinfo->atmel_lcdfb_power_control)
 		sinfo->atmel_lcdfb_power_control(1);
-	lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, sinfo->saved_lcdcon);
 
-	/* Enable FIFO & DMA errors */
-	lcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI
-			| ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);
+	if (cpu_is_at91sam9x5()) {
+		/* Enable fifo error & BASE LAYER overflow & DMA interrupts */
+		lcdc_writel(sinfo, ATMEL_LCDC_BASEIER, LCDC_BASEIER_OVR | LCDC_BASEIER_DMA);
+		lcdc_writel(sinfo, ATMEL_LCDC_LCDIER, LCDC_LCDIER_FIFOERRIE | LCDC_LCDIER_BASEIE);
+	} else {
+		lcdc_writel(sinfo, ATMEL_LCDC_CONTRAST_CTR, sinfo->saved_lcdcon);
 
+		/* Enable FIFO & DMA errors */
+		lcdc_writel(sinfo, ATMEL_LCDC_IER, ATMEL_LCDC_UFLWI
+				| ATMEL_LCDC_OWRI | ATMEL_LCDC_MERI);
+	}
+	atmel_lcdfb_check_var(&info->var, info);
+
+	ret = fb_set_var(info, &info->var);
+	if (ret) {
+		dev_warn(&pdev->dev, "unable to set display parameters\n");
+		return ret;
+	}
+	lcdc_writel(sinfo, ATMEL_LCDC_BASECHER, LCDC_BASECHER_CHEN);
 	return 0;
 }
 
Index: linux-2.6.35/drivers/mmc/core/sdio_ops.c
===================================================================
--- linux-2.6.35/drivers/mmc/core/sdio_ops.c	(revision 149)
+++ linux-2.6.35/drivers/mmc/core/sdio_ops.c	(revision 150)
@@ -170,10 +170,14 @@
 
 	mmc_wait_for_req(card->host, &mrq);
 
-	if (cmd.error)
+	if (cmd.error) {
+		printk(KERN_ERR "cmd.error\n");
 		return cmd.error;
-	if (data.error)
+	}
+	if (data.error) {
+		printk(KERN_ERR "data.error\n");
 		return data.error;
+	}
 
 	if (mmc_host_is_spi(card->host)) {
 		/* host driver already reported errors */
Index: linux-2.6.35/drivers/mmc/host/Kconfig
===================================================================
--- linux-2.6.35/drivers/mmc/host/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/mmc/host/Kconfig	(revision 150)
@@ -228,7 +228,7 @@
 
 config MMC_ATMELMCI_DMA
 	bool "Atmel MCI DMA support (EXPERIMENTAL)"
-	depends on MMC_ATMELMCI && AVR32 && DMA_ENGINE && EXPERIMENTAL
+	depends on MMC_ATMELMCI && (AVR32 || ARCH_AT91SAM9X5) && DMA_ENGINE && EXPERIMENTAL
 	help
 	  Say Y here to have the Atmel MCI driver use a DMA engine to
 	  do data transfers and thus increase the throughput and
Index: linux-2.6.35/drivers/mmc/host/atmel-mci-regs.h
===================================================================
--- linux-2.6.35/drivers/mmc/host/atmel-mci-regs.h	(revision 149)
+++ linux-2.6.35/drivers/mmc/host/atmel-mci-regs.h	(revision 150)
@@ -31,6 +31,7 @@
 # define MCI_MR_PDCFBYTE	(  1 << 13)	/* Force Byte Transfer */
 # define MCI_MR_PDCPADV		(  1 << 14)	/* Padding Value */
 # define MCI_MR_PDCMODE		(  1 << 15)	/* PDC-oriented Mode */
+# define MCI_MR_CLKODD(x)	((x) << 16)	/* LSB of clock divider */
 #define MCI_DTOR		0x0008	/* Data Timeout */
 # define MCI_DTOCYC(x)		((x) <<  0)	/* Data Timeout Cycles */
 # define MCI_DTOMUL(x)		((x) <<  4)	/* Data Timeout Multiplier */
Index: linux-2.6.35/drivers/mmc/host/atmel-mci.c
===================================================================
--- linux-2.6.35/drivers/mmc/host/atmel-mci.c	(revision 149)
+++ linux-2.6.35/drivers/mmc/host/atmel-mci.c	(revision 150)
@@ -235,7 +235,7 @@
  */
 static inline bool atmci_is_mci2(void)
 {
-	if (cpu_is_at91sam9g45())
+	if (cpu_is_at91sam9g45() || cpu_is_at91sam9x5())
 		return true;
 
 	return false;
@@ -543,6 +543,36 @@
 			cmdr |= MCI_CMDR_TRDIR_READ;
 	}
 
+#if 1
+	if (cmd->opcode == 53) {
+		cmdr &= ~(7 << 19);
+		if (data->blocks == 1)
+			cmdr |= MCI_CMDR_SDIO_BYTE;
+		else
+			cmdr |= MCI_CMDR_SDIO_BLOCK;
+	}
+#endif
+
+#if 1
+	if (cmd->opcode == 53) {
+		cmdr &= ~(7 << 19);
+		if (data->blocks == 1)
+			cmdr |= MCI_CMDR_SDIO_BYTE;
+		else
+			cmdr |= MCI_CMDR_SDIO_BLOCK;
+	}
+#endif
+
+#if 1
+	if (cmd->opcode == 53) {
+		cmdr &= ~(7 << 19);
+		if (data->blocks == 1)
+			cmdr |= MCI_CMDR_SDIO_BYTE;
+		else
+			cmdr |= MCI_CMDR_SDIO_BLOCK;
+	}
+#endif
+
 	return cmdr;
 }
 
@@ -810,8 +840,12 @@
 		atmci_set_timeout(host, slot, data);
 
 		/* Must set block count/size before sending command */
-		mci_writel(host, BLKR, MCI_BCNT(data->blocks)
+		if (mrq->cmd->opcode == 53) {
+			mci_writel(host, BLKR, MCI_BCNT(data->blksz));
+		} else {
+			mci_writel(host, BLKR, MCI_BCNT(data->blocks)
 				| MCI_BLKLEN(data->blksz));
+		}
 		dev_vdbg(&slot->mmc->class_dev, "BLKR=0x%08x\n",
 			MCI_BCNT(data->blocks) | MCI_BLKLEN(data->blksz));
 
@@ -849,8 +883,8 @@
 static void atmci_queue_request(struct atmel_mci *host,
 		struct atmel_mci_slot *slot, struct mmc_request *mrq)
 {
-	dev_vdbg(&slot->mmc->class_dev, "queue request: state=%d\n",
-			host->state);
+	dev_vdbg(&slot->mmc->class_dev, "queue request: state=%d, cmd: %d\n",
+			host->state, mrq->cmd->opcode);
 
 	spin_lock_bh(&host->lock);
 	slot->mrq = mrq;
@@ -936,16 +970,29 @@
 		}
 
 		/* Calculate clock divider */
-		clkdiv = DIV_ROUND_UP(host->bus_hz, 2 * clock_min) - 1;
-		if (clkdiv > 255) {
-			dev_warn(&mmc->class_dev,
-				"clock %u too slow; using %lu\n",
-				clock_min, host->bus_hz / (2 * 256));
-			clkdiv = 255;
+		if (!cpu_is_at91sam9x5()) {
+			clkdiv = DIV_ROUND_UP(host->bus_hz, 2 * clock_min) - 1;
+			if (clkdiv > 255) {
+				dev_warn(&mmc->class_dev,
+					"clock %u too slow; using %lu\n",
+					clock_min, host->bus_hz / (2 * 256));
+				clkdiv = 255;
+			}
+
+			host->mode_reg = MCI_MR_CLKDIV(clkdiv);
+		} else {
+			clkdiv = DIV_ROUND_UP(host->bus_hz, clock_min) - 2;
+			if (clkdiv > 511) {
+				dev_warn(&mmc->class_dev,
+					"clock %u too slow; using %lu\n",
+					clock_min, host->bus_hz / (511 + 2));
+				clkdiv = 511;
+			}
+
+			host->mode_reg = MCI_MR_CLKDIV(clkdiv >> 1)
+					| MCI_MR_CLKODD(clkdiv & 1);
 		}
 
-		host->mode_reg = MCI_MR_CLKDIV(clkdiv);
-
 		/*
 		 * WRPROOF and RDPROOF prevent overruns/underruns by
 		 * stopping the clock when the FIFO is full/empty.
@@ -1116,8 +1163,9 @@
 
 	if (status & MCI_RTOE)
 		cmd->error = -ETIMEDOUT;
-	else if ((cmd->flags & MMC_RSP_CRC) && (status & MCI_RCRCE))
+	else if ((cmd->flags & MMC_RSP_CRC) && (status & MCI_RCRCE)) {
 		cmd->error = -EILSEQ;
+	}
 	else if (status & (MCI_RINDE | MCI_RDIRE | MCI_RENDE))
 		cmd->error = -EIO;
 	else
@@ -1310,7 +1358,7 @@
 							"data timeout error\n");
 					data->error = -ETIMEDOUT;
 				} else if (status & MCI_DCRCE) {
-					dev_dbg(&host->pdev->dev,
+					dev_err(&host->pdev->dev,
 							"data CRC error\n");
 					data->error = -EILSEQ;
 				} else {
@@ -1609,7 +1657,7 @@
 
 	mmc->ops = &atmci_ops;
 	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 512);
-	mmc->f_max = host->bus_hz / 2;
+	mmc->f_max = 20000000;
 	mmc->ocr_avail	= MMC_VDD_32_33 | MMC_VDD_33_34;
 	if (sdio_irq)
 		mmc->caps |= MMC_CAP_SDIO_IRQ;
Index: linux-2.6.35/drivers/misc/Kconfig
===================================================================
--- linux-2.6.35/drivers/misc/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/misc/Kconfig	(revision 150)
@@ -73,6 +73,7 @@
 config ATMEL_TCB_CLKSRC
 	bool "TC Block Clocksource"
 	depends on ATMEL_TCLIB && GENERIC_TIME
+	select ATMEL_TCB_CLKSRC_32BIT if ARCH_AT91SAM9X5
 	default y
 	help
 	  Select this to get a high precision clocksource based on a
@@ -95,6 +96,9 @@
 	  TC can be used for other purposes, such as PWM generation and
 	  interval timing.
 
+config ATMEL_TCB_CLKSRC_32BIT
+	boolean
+
 config IBM_ASM
 	tristate "Device driver for IBM RSA service processor"
 	depends on X86 && PCI && INPUT && EXPERIMENTAL
Index: linux-2.6.35/drivers/misc/atmel-ssc.c
===================================================================
--- linux-2.6.35/drivers/misc/atmel-ssc.c	(revision 149)
+++ linux-2.6.35/drivers/misc/atmel-ssc.c	(revision 150)
@@ -101,6 +101,7 @@
 		retval = -EINVAL;
 		goto out_clk;
 	}
+	ssc->phybase = regs->start;
 
 	/* disable all interrupts */
 	clk_enable(ssc->clk);
Index: linux-2.6.35/drivers/rtc/Kconfig
===================================================================
--- linux-2.6.35/drivers/rtc/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/rtc/Kconfig	(revision 150)
@@ -729,16 +729,16 @@
 	  AT32AP700x family processors.
 
 config RTC_DRV_AT91RM9200
-	tristate "AT91RM9200 or AT91SAM9RL"
-	depends on ARCH_AT91RM9200 || ARCH_AT91SAM9RL
+	tristate "AT91RM9200 or some AT91SAM9 chips"
+	depends on ARCH_AT91RM9200 || ARCH_AT91SAM9RL || ARCH_AT91SAM9X5
 	help
 	  Driver for the internal RTC (Realtime Clock) module found on
-	  Atmel AT91RM9200's and AT91SAM9RL chips. On SAM9RL chips
-	  this is powered by the backup power supply.
+	  Atmel AT91RM9200's and some AT91SAM9 chips. On
+	  AT91SAM9 chips this is powered by the backup power supply.
 
 config RTC_DRV_AT91SAM9
 	tristate "AT91SAM9x/AT91CAP9"
-	depends on ARCH_AT91 && !(ARCH_AT91RM9200 || ARCH_AT91X40)
+	depends on ARCH_AT91 && !(ARCH_AT91RM9200 || ARCH_AT91X40 || ARCH_AT91SAM9X5)
 	help
 	  RTC driver for the Atmel AT91SAM9x and AT91CAP9 internal RTT
 	  (Real Time Timer). These timers are powered by the backup power
Index: linux-2.6.35/drivers/rtc/rtc-at91rm9200.c
===================================================================
--- linux-2.6.35/drivers/rtc/rtc-at91rm9200.c	(revision 149)
+++ linux-2.6.35/drivers/rtc/rtc-at91rm9200.c	(revision 150)
@@ -32,7 +32,11 @@
 
 #include <mach/at91_rtc.h>
 
+#if defined(CONFIG_ARCH_AT91SAM9X5)
+#include <mach/at91sam9x5_rtc_workaround.h>
+#endif
 
+
 #define AT91_RTC_EPOCH		1900UL	/* just like arch/arm/common/rtctime.c */
 
 static DECLARE_COMPLETION(at91_rtc_updated);
Index: linux-2.6.35/drivers/dma/Kconfig
===================================================================
--- linux-2.6.35/drivers/dma/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/dma/Kconfig	(revision 150)
@@ -70,7 +70,7 @@
 
 config AT_HDMAC
 	tristate "Atmel AHB DMA support"
-	depends on ARCH_AT91SAM9RL || ARCH_AT91SAM9G45
+	depends on ARCH_AT91SAM9RL || ARCH_AT91SAM9G45 || ARCH_AT91SAM9X5
 	select DMA_ENGINE
 	help
 	  Support the Atmel AHB DMA controller.  This can be integrated in
Index: linux-2.6.35/drivers/dma/at_hdmac.c
===================================================================
--- linux-2.6.35/drivers/dma/at_hdmac.c	(revision 149)
+++ linux-2.6.35/drivers/dma/at_hdmac.c	(revision 150)
@@ -14,6 +14,9 @@
  * The driver has currently been tested with the Atmel AT91SAM9RL
  * and AT91SAM9G45 series.
  */
+#define DEBUG 12
+//#define VERBOSE_DEBUG 12
+//#define VERBOSE 12
 
 #include <linux/clk.h>
 #include <linux/dmaengine.h>
@@ -37,8 +40,7 @@
 
 #define	ATC_DEFAULT_CFG		(ATC_FIFOCFG_HALFFIFO)
 #define	ATC_DEFAULT_CTRLA	(0)
-#define	ATC_DEFAULT_CTRLB	(ATC_SIF(0)	\
-				|ATC_DIF(1))
+#define	ATC_DEFAULT_CTRLB	(ATC_SIF(MEM_IF) | ATC_DIF(MEM_IF))
 
 /*
  * Initial number of descriptors to allocate for each channel. This could
@@ -107,10 +109,11 @@
 {
 	struct at_desc *desc, *_desc;
 	struct at_desc *ret = NULL;
+	unsigned long flags;
 	unsigned int i = 0;
 	LIST_HEAD(tmp_list);
 
-	spin_lock_bh(&atchan->lock);
+	spin_lock_irqsave(&atchan->lock, flags);
 	list_for_each_entry_safe(desc, _desc, &atchan->free_list, desc_node) {
 		i++;
 		if (async_tx_test_ack(&desc->txd)) {
@@ -121,7 +124,7 @@
 		dev_dbg(chan2dev(&atchan->chan_common),
 				"desc %p not ACKed\n", desc);
 	}
-	spin_unlock_bh(&atchan->lock);
+	spin_unlock_irqrestore(&atchan->lock, flags);
 	dev_vdbg(chan2dev(&atchan->chan_common),
 		"scanned %u descriptors on freelist\n", i);
 
@@ -129,9 +132,9 @@
 	if (!ret) {
 		ret = atc_alloc_descriptor(&atchan->chan_common, GFP_ATOMIC);
 		if (ret) {
-			spin_lock_bh(&atchan->lock);
+			spin_lock_irqsave(&atchan->lock, flags);
 			atchan->descs_allocated++;
-			spin_unlock_bh(&atchan->lock);
+			spin_unlock_irqrestore(&atchan->lock, flags);
 		} else {
 			dev_err(chan2dev(&atchan->chan_common),
 					"not enough descriptors available\n");
@@ -150,8 +153,9 @@
 {
 	if (desc) {
 		struct at_desc *child;
+		unsigned long flags;
 
-		spin_lock_bh(&atchan->lock);
+		spin_lock_irqsave(&atchan->lock, flags);
 		list_for_each_entry(child, &desc->tx_list, desc_node)
 			dev_vdbg(chan2dev(&atchan->chan_common),
 					"moving child desc %p to freelist\n",
@@ -160,7 +164,7 @@
 		dev_vdbg(chan2dev(&atchan->chan_common),
 			 "moving desc %p to freelist\n", desc);
 		list_add(&desc->desc_node, &atchan->free_list);
-		spin_unlock_bh(&atchan->lock);
+		spin_unlock_irqrestore(&atchan->lock, flags);
 	}
 }
 
@@ -237,23 +241,19 @@
 static void
 atc_chain_complete(struct at_dma_chan *atchan, struct at_desc *desc)
 {
-	dma_async_tx_callback		callback;
-	void				*param;
 	struct dma_async_tx_descriptor	*txd = &desc->txd;
 
 	dev_vdbg(chan2dev(&atchan->chan_common),
 		"descriptor %u complete\n", txd->cookie);
 
 	atchan->completed_cookie = txd->cookie;
-	callback = txd->callback;
-	param = txd->callback_param;
 
 	/* move children to free_list */
 	list_splice_init(&desc->tx_list, &atchan->free_list);
 	/* move myself to free_list */
 	list_move(&desc->desc_node, &atchan->free_list);
 
-	/* unmap dma addresses */
+	/* unmap dma addresses (not on slave channels) */
 	if (!atchan->chan_common.private) {
 		struct device *parent = chan2parent(&atchan->chan_common);
 		if (!(txd->flags & DMA_COMPL_SKIP_DEST_UNMAP)) {
@@ -278,13 +278,20 @@
 		}
 	}
 
-	/*
-	 * The API requires that no submissions are done from a
-	 * callback, so we don't need to drop the lock here
-	 */
-	if (callback)
-		callback(param);
+	/* for cyclic transfers,
+	 * no need to replay callback function while stopping */
+	if (!test_bit(ATC_IS_CYCLIC, &atchan->status)) {
+		dma_async_tx_callback	callback = txd->callback;
+		void			*param = txd->callback_param;
 
+		/*
+		 * The API requires that no submissions are done from a
+		 * callback, so we don't need to drop the lock here
+		 */
+		if (callback)
+			callback(param);
+	}
+
 	dma_run_dependencies(txd);
 }
 
@@ -419,27 +426,43 @@
 	atc_chain_complete(atchan, bad_desc);
 }
 
+/**
+ * atc_handle_cyclic - at the end of a period, run callback function
+ * @atchan: channel used for cyclic operations
+ *
+ * Called with atchan->lock held and bh disabled
+ */
+static void atc_handle_cyclic(struct at_dma_chan *atchan)
+{
+	struct at_desc			*first = atc_first_active(atchan);
+	struct dma_async_tx_descriptor	*txd = &first->txd;
+	dma_async_tx_callback		callback = txd->callback;
+	void				*param = txd->callback_param;
 
+	dev_vdbg(chan2dev(&atchan->chan_common),
+			"new cyclic period llp 0x%08x\n",
+			channel_readl(atchan, DSCR));
+
+	if (callback)
+		callback(param);
+}
+
 /*--  IRQ & Tasklet  ---------------------------------------------------*/
 
 static void atc_tasklet(unsigned long data)
 {
 	struct at_dma_chan *atchan = (struct at_dma_chan *)data;
+	unsigned long flags;
 
-	/* Channel cannot be enabled here */
-	if (atc_chan_is_enabled(atchan)) {
-		dev_err(chan2dev(&atchan->chan_common),
-			"BUG: channel enabled in tasklet\n");
-		return;
-	}
-
-	spin_lock(&atchan->lock);
-	if (test_and_clear_bit(0, &atchan->error_status))
+	spin_lock_irqsave(&atchan->lock, flags);
+	if (test_and_clear_bit(ATC_IS_ERROR, &atchan->status))
 		atc_handle_error(atchan);
+	else if (test_bit(ATC_IS_CYCLIC, &atchan->status))
+		atc_handle_cyclic(atchan);
 	else
 		atc_advance_work(atchan);
 
-	spin_unlock(&atchan->lock);
+	spin_unlock_irqrestore(&atchan->lock, flags);
 }
 
 static irqreturn_t at_dma_interrupt(int irq, void *dev_id)
@@ -464,12 +487,13 @@
 
 		for (i = 0; i < atdma->dma_common.chancnt; i++) {
 			atchan = &atdma->chan[i];
-			if (pending & (AT_DMA_CBTC(i) | AT_DMA_ERR(i))) {
+			if (pending & (AT_DMA_BTC(i) | AT_DMA_ERR(i))) {
 				if (pending & AT_DMA_ERR(i)) {
 					/* Disable channel on AHB error */
-					dma_writel(atdma, CHDR, atchan->mask);
+					dma_writel(atdma, CHDR,
+						AT_DMA_RES(i) | atchan->mask);
 					/* Give information to tasklet */
-					set_bit(0, &atchan->error_status);
+					set_bit(ATC_IS_ERROR, &atchan->status);
 				}
 				tasklet_schedule(&atchan->tasklet);
 				ret = IRQ_HANDLED;
@@ -497,8 +521,9 @@
 	struct at_desc		*desc = txd_to_at_desc(tx);
 	struct at_dma_chan	*atchan = to_at_dma_chan(tx->chan);
 	dma_cookie_t		cookie;
+	unsigned long		flags;
 
-	spin_lock_bh(&atchan->lock);
+	spin_lock_irqsave(&atchan->lock, flags);
 	cookie = atc_assign_cookie(atchan, desc);
 
 	if (list_empty(&atchan->active_list)) {
@@ -512,7 +537,7 @@
 		list_add_tail(&desc->desc_node, &atchan->queue);
 	}
 
-	spin_unlock_bh(&atchan->lock);
+	spin_unlock_irqrestore(&atchan->lock, flags);
 
 	return cookie;
 }
@@ -549,7 +574,7 @@
 	}
 
 	ctrla =   ATC_DEFAULT_CTRLA;
-	ctrlb =   ATC_DEFAULT_CTRLB
+	ctrlb =   ATC_DEFAULT_CTRLB | ATC_IEN
 		| ATC_SRC_ADDR_MODE_INCR
 		| ATC_DST_ADDR_MODE_INCR
 		| ATC_FC_MEM2MEM;
@@ -583,7 +608,6 @@
 		desc->lli.ctrlb = ctrlb;
 
 		desc->txd.cookie = 0;
-		async_tx_ack(&desc->txd);
 
 		if (!first) {
 			first = desc;
@@ -604,7 +628,7 @@
 	/* set end-of-link to the last link descriptor of list*/
 	set_desc_eol(desc);
 
-	desc->txd.flags = flags; /* client is in control of this ack */
+	first->txd.flags = flags; /* client is in control of this ack */
 
 	return &first->txd;
 
@@ -640,7 +664,8 @@
 	struct scatterlist	*sg;
 	size_t			total_len = 0;
 
-	dev_vdbg(chan2dev(chan), "prep_slave_sg: %s f0x%lx\n",
+	dev_vdbg(chan2dev(chan), "prep_slave_sg (%d): %s f0x%lx\n",
+			sg_len,
 			direction == DMA_TO_DEVICE ? "TO DEVICE" : "FROM DEVICE",
 			flags);
 
@@ -652,14 +677,14 @@
 	reg_width = atslave->reg_width;
 
 	ctrla = ATC_DEFAULT_CTRLA | atslave->ctrla;
-	ctrlb = ATC_DEFAULT_CTRLB | ATC_IEN;
+	ctrlb = ATC_IEN;
 
 	switch (direction) {
 	case DMA_TO_DEVICE:
 		ctrla |=  ATC_DST_WIDTH(reg_width);
 		ctrlb |=  ATC_DST_ADDR_MODE_FIXED
 			| ATC_SRC_ADDR_MODE_INCR
-			| ATC_FC_MEM2PER;
+			| ATC_FC_MEM2PER | ATC_SIF(MEM_IF) | ATC_DIF(PER_IF);
 		reg = atslave->tx_reg;
 		for_each_sg(sgl, sg, sg_len, i) {
 			struct at_desc	*desc;
@@ -670,7 +695,7 @@
 			if (!desc)
 				goto err_desc_get;
 
-			mem = sg_phys(sg);
+			mem = sg_dma_address(sg);
 			len = sg_dma_len(sg);
 			mem_width = 2;
 			if (unlikely(mem & 3 || len & 3))
@@ -700,7 +725,7 @@
 		ctrla |=  ATC_SRC_WIDTH(reg_width);
 		ctrlb |=  ATC_DST_ADDR_MODE_INCR
 			| ATC_SRC_ADDR_MODE_FIXED
-			| ATC_FC_PER2MEM;
+			| ATC_FC_PER2MEM | ATC_SIF(PER_IF) | ATC_DIF(MEM_IF);
 
 		reg = atslave->rx_reg;
 		for_each_sg(sgl, sg, sg_len, i) {
@@ -712,7 +737,7 @@
 			if (!desc)
 				goto err_desc_get;
 
-			mem = sg_phys(sg);
+			mem = sg_dma_address(sg);
 			len = sg_dma_len(sg);
 			mem_width = 2;
 			if (unlikely(mem & 3 || len & 3))
@@ -722,7 +747,7 @@
 			desc->lli.daddr = mem;
 			desc->lli.ctrla = ctrla
 					| ATC_DST_WIDTH(mem_width)
-					| len >> mem_width;
+					| len >> reg_width;
 			desc->lli.ctrlb = ctrlb;
 
 			if (!first) {
@@ -749,8 +774,8 @@
 	first->txd.cookie = -EBUSY;
 	first->len = total_len;
 
-	/* last link descriptor of list is responsible of flags */
-	prev->txd.flags = flags; /* client is in control of this ack */
+	/* first link descriptor of list is responsible of flags */
+	first->txd.flags = flags; /* client is in control of this ack */
 
 	return &first->txd;
 
@@ -760,42 +785,220 @@
 	return NULL;
 }
 
+/**
+ * atc_dma_cyclic_prep - prepare the cyclic DMA transfer
+ * @chan: the DMA channel to prepare
+ * @buf_addr: physical DMA address where the buffer starts
+ * @buf_len: total number of bytes for the entire buffer
+ * @period_len: number of bytes for each period
+ * @direction: transfer direction, to or from device
+ */
+static struct dma_async_tx_descriptor *
+atc_prep_dma_cyclic(struct dma_chan *chan, dma_addr_t buf_addr, size_t buf_len,
+		size_t period_len, enum dma_data_direction direction)
+{
+	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
+	struct at_dma_slave	*atslave = chan->private;
+	struct at_desc		*first = NULL;
+	struct at_desc		*prev = NULL;
+	unsigned long		was_cyclic;
+	unsigned int		periods = buf_len / period_len;
+	unsigned int		reg_width;
+	u32			ctrla;
+	u32			ctrlb = 0;
+	unsigned int		i;
+
+	dev_vdbg(chan2dev(chan), "prep_dma_cyclic: %s buf@0x%08x - %d (%d/%d)\n",
+			direction == DMA_TO_DEVICE ? "TO DEVICE" : "FROM DEVICE",
+			buf_addr,
+			periods, buf_len, period_len);
+
+	if (unlikely(!atslave || !buf_len || !period_len)) {
+		dev_dbg(chan2dev(chan), "prep_dma_cyclic: length is zero!\n");
+		return NULL;
+	}
+
+	was_cyclic = test_and_set_bit(ATC_IS_CYCLIC, &atchan->status);
+	if (was_cyclic) {
+		dev_dbg(chan2dev(chan), "prep_dma_cyclic: channel in use!\n");
+		return NULL;
+	}
+
+	reg_width = atslave->reg_width;
+
+	/* Check for too big/unaligned periods and unaligned DMA buffer */
+	if (period_len > (ATC_BTSIZE_MAX << reg_width))
+		goto err_out;
+	if (unlikely(period_len & ((1 << reg_width) - 1)))
+		goto err_out;
+	if (unlikely(buf_addr & ((1 << reg_width) - 1)))
+		goto err_out;
+	if (unlikely(!(direction & (DMA_TO_DEVICE | DMA_FROM_DEVICE))))
+		goto err_out;
+
+	/* prepare common CRTLA value */
+	ctrla =   ATC_DEFAULT_CTRLA | atslave->ctrla
+		| ATC_DST_WIDTH(reg_width)
+		| ATC_SRC_WIDTH(reg_width)
+		| period_len >> reg_width;
+
+	/* build cyclic linked list */
+	for (i = 0; i < periods; i++) {
+		struct at_desc	*desc;
+
+		desc = atc_desc_get(atchan);
+		if (!desc)
+			goto err_desc_get;
+
+		switch (direction) {
+		case DMA_TO_DEVICE:
+			desc->lli.saddr = buf_addr + (period_len * i);
+			desc->lli.daddr = atslave->tx_reg;
+			desc->lli.ctrla = ctrla;
+			desc->lli.ctrlb = ctrlb
+					| ATC_DST_ADDR_MODE_FIXED
+					| ATC_SRC_ADDR_MODE_INCR
+					| ATC_FC_MEM2PER
+					| ATC_SIF(MEM_IF) | ATC_DIF(PER_IF);
+			break;
+
+		case DMA_FROM_DEVICE:
+			desc->lli.saddr = atslave->rx_reg;
+			desc->lli.daddr = buf_addr + (period_len * i);
+			desc->lli.ctrla = ctrla;
+			desc->lli.ctrlb = ctrlb
+					| ATC_DST_ADDR_MODE_INCR
+					| ATC_SRC_ADDR_MODE_FIXED
+					| ATC_FC_PER2MEM
+					| ATC_SIF(PER_IF) | ATC_DIF(MEM_IF);
+			break;
+
+		default:
+			return NULL;
+		}
+
+		if (!first) {
+			first = desc;
+		} else {
+			/* inform the HW lli about chaining */
+			prev->lli.dscr = desc->txd.phys;
+			/* insert the link descriptor to the LD ring */
+			list_add_tail(&desc->desc_node,
+					&first->tx_list);
+		}
+		prev = desc;
+	}
+
+	/* lets make a cyclic list */
+	prev->lli.dscr = first->txd.phys;
+
+	/* First descriptor of the chain embedds additional information */
+	first->txd.cookie = -EBUSY;
+	first->len = buf_len;
+
+	return &first->txd;
+
+err_desc_get:
+	dev_err(chan2dev(chan), "not enough descriptors available\n");
+	atc_desc_put(atchan, first);
+err_out:
+	clear_bit(ATC_IS_CYCLIC, &atchan->status);
+	return NULL;
+}
+
+
 static int atc_control(struct dma_chan *chan, enum dma_ctrl_cmd cmd,
 		       unsigned long arg)
 {
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	struct at_dma		*atdma = to_at_dma(chan->device);
-	struct at_desc		*desc, *_desc;
+	int			chan_id = atchan->chan_common.chan_id;
+	unsigned long		flags;
+
 	LIST_HEAD(list);
 
-	/* Only supports DMA_TERMINATE_ALL */
-	if (cmd != DMA_TERMINATE_ALL)
-		return -ENXIO;
+	dev_vdbg(chan2dev(chan), "atc_control (%d)\n", cmd);
 
-	/*
-	 * This is only called when something went wrong elsewhere, so
-	 * we don't really care about the data. Just disable the
-	 * channel. We still have to poll the channel enable bit due
-	 * to AHB/HSB limitations.
-	 */
-	spin_lock_bh(&atchan->lock);
+	if (cmd == DMA_PAUSE) {
+		spin_lock_irqsave(&atchan->lock, flags);
 
-	dma_writel(atdma, CHDR, atchan->mask);
+		dma_writel(atdma, CHER, AT_DMA_SUSP(chan_id));
+		set_bit(ATC_IS_PAUSED, &atchan->status);
 
-	/* confirm that this channel is disabled */
-	while (dma_readl(atdma, CHSR) & atchan->mask)
-		cpu_relax();
+		spin_unlock_irqrestore(&atchan->lock, flags);
+	} else if (cmd == DMA_RESUME) {
+		if (!test_bit(ATC_IS_PAUSED, &atchan->status))
+			return 0;
 
-	/* active_list entries will end up before queued entries */
-	list_splice_init(&atchan->queue, &list);
-	list_splice_init(&atchan->active_list, &list);
+		spin_lock_irqsave(&atchan->lock, flags);
 
-	spin_unlock_bh(&atchan->lock);
+		dma_writel(atdma, CHDR, AT_DMA_RES(chan_id));
+		clear_bit(ATC_IS_PAUSED, &atchan->status);
 
-	/* Flush all pending and queued descriptors */
-	list_for_each_entry_safe(desc, _desc, &list, desc_node)
-		atc_chain_complete(atchan, desc);
+		spin_unlock_irqrestore(&atchan->lock, flags);
+	} else if (cmd == DMA_SLAVE_CONFIG) {
+		struct dma_slave_config *dmaengine_cfg = (void *)arg;
+		struct at_dma_slave	*atslave = chan->private;
+		enum dma_slave_buswidth sdma_width;
+		enum at_dma_slave_width	atdma_width;
 
+		/* only modify transfer size width */
+		if (!atslave)
+			return -ENXIO;
+
+		if (dmaengine_cfg->direction == DMA_FROM_DEVICE) {
+			sdma_width = dmaengine_cfg->src_addr_width;
+		} else {
+			sdma_width = dmaengine_cfg->dst_addr_width;
+		}
+
+		switch (sdma_width) {
+		case DMA_SLAVE_BUSWIDTH_1_BYTE:
+			atdma_width = AT_DMA_SLAVE_WIDTH_8BIT;
+			break;
+		case DMA_SLAVE_BUSWIDTH_2_BYTES:
+			atdma_width = AT_DMA_SLAVE_WIDTH_16BIT;
+			break;
+		case DMA_SLAVE_BUSWIDTH_4_BYTES:
+			atdma_width = AT_DMA_SLAVE_WIDTH_32BIT;
+			break;
+		default:
+			return -EINVAL;
+		}
+		atslave->reg_width = atdma_width;
+	} else if (cmd == DMA_TERMINATE_ALL) {
+		struct at_desc	*desc, *_desc;
+		/*
+		 * This is only called when something went wrong elsewhere, so
+		 * we don't really care about the data. Just disable the
+		 * channel. We still have to poll the channel enable bit due
+		 * to AHB/HSB limitations.
+		 */
+		spin_lock_irqsave(&atchan->lock, flags);
+
+		dma_writel(atdma, CHDR, AT_DMA_RES(chan_id) | atchan->mask);
+
+		/* confirm that this channel is disabled */
+		while (dma_readl(atdma, CHSR) & atchan->mask)
+			cpu_relax();
+
+		/* active_list entries will end up before queued entries */
+		list_splice_init(&atchan->queue, &list);
+		list_splice_init(&atchan->active_list, &list);
+
+		/* Flush all pending and queued descriptors */
+		list_for_each_entry_safe(desc, _desc, &list, desc_node)
+			atc_chain_complete(atchan, desc);
+
+		clear_bit(ATC_IS_PAUSED, &atchan->status);
+		/* if channel dedicated to cyclic operations, free it */
+		clear_bit(ATC_IS_CYCLIC, &atchan->status);
+
+		spin_unlock_irqrestore(&atchan->lock, flags);
+	} else {
+		return -ENXIO;
+	}
+
 	return 0;
 }
 
@@ -817,9 +1020,10 @@
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
 	dma_cookie_t		last_used;
 	dma_cookie_t		last_complete;
+	unsigned long		flags;
 	enum dma_status		ret;
 
-	spin_lock_bh(&atchan->lock);
+	spin_lock_irqsave(&atchan->lock, flags);
 
 	last_complete = atchan->completed_cookie;
 	last_used = chan->cookie;
@@ -834,11 +1038,19 @@
 		ret = dma_async_is_complete(cookie, last_complete, last_used);
 	}
 
-	spin_unlock_bh(&atchan->lock);
+	spin_unlock_irqrestore(&atchan->lock, flags);
 
-	dma_set_tx_state(txstate, last_complete, last_used, 0);
-	dev_vdbg(chan2dev(chan), "tx_status: %d (d%d, u%d)\n",
-		 cookie, last_complete ? last_complete : 0,
+	if (ret != DMA_SUCCESS)
+		dma_set_tx_state(txstate, last_complete, last_used,
+			atc_first_active(atchan)->len);
+	else
+		dma_set_tx_state(txstate, last_complete, last_used, 0);
+
+	if (test_bit(ATC_IS_PAUSED, &atchan->status))
+		ret = DMA_PAUSED;
+
+	dev_vdbg(chan2dev(chan), "tx_status %d: cookie = %d (d%d, u%d)\n",
+		 ret, cookie, last_complete ? last_complete : 0,
 		 last_used ? last_used : 0);
 
 	return ret;
@@ -851,14 +1063,19 @@
 static void atc_issue_pending(struct dma_chan *chan)
 {
 	struct at_dma_chan	*atchan = to_at_dma_chan(chan);
+	unsigned long		flags;
 
 	dev_vdbg(chan2dev(chan), "issue_pending\n");
 
+	/* Not needed for cyclic transfers */
+	if (test_bit(ATC_IS_CYCLIC, &atchan->status))
+		return;
+
+	spin_lock_irqsave(&atchan->lock, flags);
 	if (!atc_chan_is_enabled(atchan)) {
-		spin_lock_bh(&atchan->lock);
 		atc_advance_work(atchan);
-		spin_unlock_bh(&atchan->lock);
 	}
+	spin_unlock_irqrestore(&atchan->lock, flags);
 }
 
 /**
@@ -874,6 +1091,7 @@
 	struct at_dma		*atdma = to_at_dma(chan->device);
 	struct at_desc		*desc;
 	struct at_dma_slave	*atslave;
+	unsigned long		flags;
 	int			i;
 	u32			cfg;
 	LIST_HEAD(tmp_list);
@@ -917,11 +1135,11 @@
 		list_add_tail(&desc->desc_node, &tmp_list);
 	}
 
-	spin_lock_bh(&atchan->lock);
+	spin_lock_irqsave(&atchan->lock, flags);
 	atchan->descs_allocated = i;
 	list_splice(&tmp_list, &atchan->free_list);
 	atchan->completed_cookie = chan->cookie = 1;
-	spin_unlock_bh(&atchan->lock);
+	spin_unlock_irqrestore(&atchan->lock, flags);
 
 	/* channel parameters */
 	channel_writel(atchan, CFG, cfg);
@@ -960,6 +1178,7 @@
 	}
 	list_splice_init(&atchan->free_list, &list);
 	atchan->descs_allocated = 0;
+	atchan->status = 0;
 
 	dev_vdbg(chan2dev(chan), "free_chan_resources: done\n");
 }
@@ -1093,10 +1312,15 @@
 	if (dma_has_cap(DMA_MEMCPY, atdma->dma_common.cap_mask))
 		atdma->dma_common.device_prep_dma_memcpy = atc_prep_dma_memcpy;
 
-	if (dma_has_cap(DMA_SLAVE, atdma->dma_common.cap_mask)) {
+	if (dma_has_cap(DMA_SLAVE, atdma->dma_common.cap_mask))
 		atdma->dma_common.device_prep_slave_sg = atc_prep_slave_sg;
+
+	if (dma_has_cap(DMA_CYCLIC, atdma->dma_common.cap_mask))
+		atdma->dma_common.device_prep_dma_cyclic = atc_prep_dma_cyclic;
+
+	if (dma_has_cap(DMA_SLAVE, atdma->dma_common.cap_mask) ||
+	    dma_has_cap(DMA_CYCLIC, atdma->dma_common.cap_mask))
 		atdma->dma_common.device_control = atc_control;
-	}
 
 	dma_writel(atdma, EN, AT_DMA_ENABLE);
 
@@ -1210,7 +1434,7 @@
 {
 	return platform_driver_probe(&at_dma_driver, at_dma_probe);
 }
-module_init(at_dma_init);
+subsys_initcall(at_dma_init);
 
 static void __exit at_dma_exit(void)
 {
Index: linux-2.6.35/drivers/dma/at_hdmac_regs.h
===================================================================
--- linux-2.6.35/drivers/dma/at_hdmac_regs.h	(revision 149)
+++ linux-2.6.35/drivers/dma/at_hdmac_regs.h	(revision 150)
@@ -103,6 +103,8 @@
 /* Bitfields in CTRLB */
 #define	ATC_SIF(i)		(0x3 & (i))	/* Src tx done via AHB-Lite Interface i */
 #define	ATC_DIF(i)		((0x3 & (i)) <<  4)	/* Dst tx done via AHB-Lite Interface i */
+#define MEM_IF			0		/* specify AHB interface 0 as memory interface */
+#define PER_IF			1		/* specify AHB interface 1 as peripheral interface */
 #define	ATC_SRC_PIP		(0x1 <<  8)	/* Source Picture-in-Picture enabled */
 #define	ATC_DST_PIP		(0x1 << 12)	/* Destination Picture-in-Picture enabled */
 #define	ATC_SRC_DSCR_DIS	(0x1 << 16)	/* Src Descriptor fetch disable */
@@ -181,12 +183,23 @@
 /*--  Channels  --------------------------------------------------------*/
 
 /**
+ * atc_status - information bits stored in channel status flag
+ *
+ * Manipulated with atomic operations.
+ */
+enum atc_status {
+	ATC_IS_ERROR = 0,
+	ATC_IS_PAUSED = 1,
+	ATC_IS_CYCLIC = 24,
+};
+
+/**
  * struct at_dma_chan - internal representation of an Atmel HDMAC channel
  * @chan_common: common dmaengine channel object members
  * @device: parent device
  * @ch_regs: memory mapped register base
  * @mask: channel index in a mask
- * @error_status: transmit error status information from irq handler
+ * @status: transmit status information from irq/prep* functions
  *                to tasklet (use atomic operations)
  * @tasklet: bottom half to finish transaction work
  * @lock: serializes enqueue/dequeue operations to descriptors lists
@@ -201,7 +214,7 @@
 	struct at_dma		*device;
 	void __iomem		*ch_regs;
 	u8			mask;
-	unsigned long		error_status;
+	unsigned long		status;
 	struct tasklet_struct	tasklet;
 
 	spinlock_t		lock;
@@ -309,8 +322,8 @@
 	struct at_dma	*atdma = to_at_dma(atchan->chan_common.device);
 	u32		ebci;
 
-	/* enable interrupts on buffer chain completion & error */
-	ebci =    AT_DMA_CBTC(atchan->chan_common.chan_id)
+	/* enable interrupts on buffer transfer completion & error */
+	ebci =    AT_DMA_BTC(atchan->chan_common.chan_id)
 		| AT_DMA_ERR(atchan->chan_common.chan_id);
 	if (on)
 		dma_writel(atdma, EBCIER, ebci);
@@ -347,7 +360,12 @@
  */
 static void set_desc_eol(struct at_desc *desc)
 {
-	desc->lli.ctrlb |= ATC_SRC_DSCR_DIS | ATC_DST_DSCR_DIS;
+	u32 ctrlb = desc->lli.ctrlb;
+
+	ctrlb &= ~ATC_IEN;
+	ctrlb |= ATC_SRC_DSCR_DIS | ATC_DST_DSCR_DIS;
+
+	desc->lli.ctrlb = ctrlb;
 	desc->lli.dscr = 0;
 }
 
Index: linux-2.6.35/drivers/dma/dmaengine.c
===================================================================
--- linux-2.6.35/drivers/dma/dmaengine.c	(revision 149)
+++ linux-2.6.35/drivers/dma/dmaengine.c	(revision 150)
@@ -692,6 +692,8 @@
 		!device->device_prep_dma_interrupt);
 	BUG_ON(dma_has_cap(DMA_SLAVE, device->cap_mask) &&
 		!device->device_prep_slave_sg);
+	BUG_ON(dma_has_cap(DMA_CYCLIC, device->cap_mask) &&
+		!device->device_prep_dma_cyclic);
 	BUG_ON(dma_has_cap(DMA_SLAVE, device->cap_mask) &&
 		!device->device_control);
 
Index: linux-2.6.35/drivers/clocksource/tcb_clksrc.c
===================================================================
--- linux-2.6.35/drivers/clocksource/tcb_clksrc.c	(revision 149)
+++ linux-2.6.35/drivers/clocksource/tcb_clksrc.c	(revision 150)
@@ -20,6 +20,9 @@
  *     with a base rate of 5+ MHz, packaged as a clocksource (with
  *     resolution better than 200 nsec).
  *
+ *   - Some chips support 32 bit counter in one channel, then the second
+ *     channel is not used.
+ *
  *   - The third channel may be used to provide a 16-bit clockevent
  *     source, used in either periodic or oneshot mode.  This runs
  *     at 32 KiHZ, and can handle delays of up to two seconds.
@@ -45,10 +48,15 @@
 	u32		lower, upper;
 
 	raw_local_irq_save(flags);
+#ifndef CONFIG_ATMEL_TCB_CLKSRC_32BIT
 	do {
 		upper = __raw_readl(tcaddr + ATMEL_TC_REG(1, CV));
 		lower = __raw_readl(tcaddr + ATMEL_TC_REG(0, CV));
 	} while (upper != __raw_readl(tcaddr + ATMEL_TC_REG(1, CV)));
+#else
+	upper = 0;
+	lower = __raw_readl(tcaddr + ATMEL_TC_REG(0, CV));
+#endif
 
 	raw_local_irq_restore(flags);
 	return (upper << 16) | lower;
@@ -271,14 +279,21 @@
 	__raw_writel(best_divisor_idx			/* likely divide-by-8 */
 			| ATMEL_TC_WAVE
 			| ATMEL_TC_WAVESEL_UP		/* free-run */
+#ifndef CONFIG_ATMEL_TCB_CLKSRC_32BIT
 			| ATMEL_TC_ACPA_SET		/* TIOA0 rises at 0 */
-			| ATMEL_TC_ACPC_CLEAR,		/* (duty cycle 50%) */
+			| ATMEL_TC_ACPC_CLEAR		/* (duty cycle 50%) */
+#endif
+			,
 			tcaddr + ATMEL_TC_REG(0, CMR));
+
+#ifndef CONFIG_ATMEL_TCB_CLKSRC_32BIT
 	__raw_writel(0x0000, tcaddr + ATMEL_TC_REG(0, RA));
 	__raw_writel(0x8000, tcaddr + ATMEL_TC_REG(0, RC));
+#endif
 	__raw_writel(0xff, tcaddr + ATMEL_TC_REG(0, IDR));	/* no irqs */
 	__raw_writel(ATMEL_TC_CLKEN, tcaddr + ATMEL_TC_REG(0, CCR));
 
+#ifndef CONFIG_ATMEL_TCB_CLKSRC_32BIT
 	/* channel 1:  waveform mode, input TIOA0 */
 	__raw_writel(ATMEL_TC_XC1			/* input: TIOA0 */
 			| ATMEL_TC_WAVE
@@ -287,8 +302,10 @@
 	__raw_writel(0xff, tcaddr + ATMEL_TC_REG(1, IDR));	/* no irqs */
 	__raw_writel(ATMEL_TC_CLKEN, tcaddr + ATMEL_TC_REG(1, CCR));
 
-	/* chain channel 0 to channel 1, then reset all the timers */
+	/* chain channel 0 to channel 1 */
 	__raw_writel(ATMEL_TC_TC1XC1S_TIOA0, tcaddr + ATMEL_TC_BMR);
+#endif
+	/* reset all the timers */
 	__raw_writel(ATMEL_TC_SYNC, tcaddr + ATMEL_TC_BCR);
 
 	/* and away we go! */
Index: linux-2.6.35/drivers/net/Kconfig
===================================================================
--- linux-2.6.35/drivers/net/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/net/Kconfig	(revision 150)
@@ -221,7 +221,7 @@
 
 config MACB
 	tristate "Atmel MACB support"
-	depends on AVR32 || ARCH_AT91SAM9260 || ARCH_AT91SAM9263 || ARCH_AT91SAM9G20 || ARCH_AT91SAM9G45 || ARCH_AT91CAP9
+	depends on AVR32 || ARCH_AT91SAM9260 || ARCH_AT91SAM9263 || ARCH_AT91SAM9G20 || ARCH_AT91SAM9G45 || ARCH_AT91SAM9X5 || ARCH_AT91CAP9
 	select PHYLIB
 	help
 	  The Atmel MACB ethernet interface is found on many AT32 and AT91
Index: linux-2.6.35/drivers/usb/Kconfig
===================================================================
--- linux-2.6.35/drivers/usb/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/usb/Kconfig	(revision 150)
@@ -62,6 +62,7 @@
 	default y if ARCH_IXP4XX
 	default y if ARCH_W90X900
 	default y if ARCH_AT91SAM9G45
+	default y if ARCH_AT91SAM9X5
 	default y if ARCH_MXC
 	default y if ARCH_OMAP3
 	default PCI
Index: linux-2.6.35/drivers/usb/gadget/atmel_usba_udc.c
===================================================================
--- linux-2.6.35/drivers/usb/gadget/atmel_usba_udc.c	(revision 149)
+++ linux-2.6.35/drivers/usb/gadget/atmel_usba_udc.c	(revision 150)
@@ -2014,6 +2014,9 @@
 			} else {
 				disable_irq(gpio_to_irq(udc->vbus_pin));
 			}
+		} else {
+			/* gpio_request fail so use -EINVAL for gpio_is_valid */
+			udc->vbus_pin = -EINVAL;
 		}
 	}
 
Index: linux-2.6.35/drivers/usb/gadget/Kconfig
===================================================================
--- linux-2.6.35/drivers/usb/gadget/Kconfig	(revision 149)
+++ linux-2.6.35/drivers/usb/gadget/Kconfig	(revision 150)
@@ -124,7 +124,7 @@
 
 config USB_GADGET_AT91
 	boolean "Atmel AT91 USB Device Port"
-	depends on ARCH_AT91 && !ARCH_AT91SAM9RL && !ARCH_AT91CAP9 && !ARCH_AT91SAM9G45
+	depends on ARCH_AT91 && !ARCH_AT91SAM9RL && !ARCH_AT91CAP9 && !ARCH_AT91SAM9G45 && !ARCH_AT91SAM9X5
 	select USB_GADGET_SELECTED
 	help
 	   Many Atmel AT91 processors (such as the AT91RM2000) have a
@@ -143,7 +143,7 @@
 config USB_GADGET_ATMEL_USBA
 	boolean "Atmel USBA"
 	select USB_GADGET_DUALSPEED
-	depends on AVR32 || ARCH_AT91CAP9 || ARCH_AT91SAM9RL || ARCH_AT91SAM9G45
+	depends on AVR32 || ARCH_AT91CAP9 || ARCH_AT91SAM9RL || ARCH_AT91SAM9G45 || ARCH_AT91SAM9X5
 	help
 	  USBA is the integrated high-speed USB Device controller on
 	  the AT32AP700x, some AT91SAM9 and AT91CAP9 processors from Atmel.